[{"path":[]},{"path":"/AGENTS.html","id":"project-structure--module-organization","dir":"","previous_headings":"","what":"Project Structure & Module Organization","title":"Repository Guidelines","text":"Core simulation decision logic lives R/ (state_management.R, interim_logic.R, simulation_driver.R). Statistical helpers posterior samplers predictive calculations sit alongside . Tests tests/testthat, documentation topics man/ longer-form walkthroughs vignettes/. Artifacts pkgdown live _pkgdown.yml, renv/ pins package dependencies reproducible runs. Keep auxiliary scripts (e.g., scenario grids) project root inst/ pollute package namespace.","code":""},{"path":"/AGENTS.html","id":"build-test-and-development-commands","dir":"","previous_headings":"","what":"Build, Test, and Development Commands","title":"Repository Guidelines","text":"Use devtools::load_all() iterative work; refreshes package namespace without reinstalling. Run devtools::test() targeted validation devtools::check() publishing ensure R CMD check passes cleanly. local script runs, Rscript path//file.R keeps environments isolated. major updates, devtools::install() followed library(evolveTrial) mirrors user experience. pkgdown::build_site() regenerates browsable documentation substantive API changes land.","code":""},{"path":"/AGENTS.html","id":"coding-style--naming-conventions","dir":"","previous_headings":"","what":"Coding Style & Naming Conventions","title":"Repository Guidelines","text":"Follow tidyverse-style R code: two-space indentation, { line, snake_case identifiers (min_person_time_frac_per_arm). Reuse package utilities %||% coalesce_num() instead re-implementing fallbacks. Keep diagnostic message() calls concise prefixed (e.g., [vsREF gate]). adding arguments, thread run_simulation_pure() formals downstream helpers can pick via modifyList().","code":""},{"path":"/AGENTS.html","id":"testing-guidelines","dir":"","previous_headings":"","what":"Testing Guidelines","title":"Repository Guidelines","text":"New decision logic gating tweaks must include regression tests tests/testthat/. Prioritize scenarios stress multi-arm comparisons, proportional gate scaling, predictive probability fallbacks. Use deterministic seeds (e.g., set.seed(4242)) low simulation counts unit tests; save large grids ad-hoc scripts. Document required outputs (PET, alpha, expected N) expectations future refactors flag behavior shifts early.","code":""},{"path":"/AGENTS.html","id":"commit--pull-request-guidelines","dir":"","previous_headings":"","what":"Commit & Pull Request Guidelines","title":"Repository Guidelines","text":"Write imperative, present-tense commit titles ~72 characters (see git log: “Add one-time interval rebalancing support”). Group related edits—code, docs, tests—single commit feasible. PRs summarize design intent, note simulation diagnostics (attach key rows res[...]), call configuration changes affecting calibration. Link upstream issues design discussions future agents understand rationale. requesting review, ensure devtools::check() clean results.txt intermediate files ignored removed.","code":""},{"path":"/CLAUDE.html","id":null,"dir":"","previous_headings":"","what":"CLAUDE.md","title":"CLAUDE.md","text":"file provides guidance Claude Code (claude.ai/code) working code repository.","code":""},{"path":"/CLAUDE.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"CLAUDE.md","text":"evolveTrial R package Bayesian adaptive platform/umbrella clinical trial simulation design analysis. specializes progression-free survival (PFS) endpoints using piecewise exponential models single-arm (vs historical control) multi-arm (vs-reference) decision logic.","code":""},{"path":[]},{"path":"/CLAUDE.html","id":"core-simulation-architecture","dir":"","previous_headings":"Package Structure","what":"Core Simulation Architecture","title":"CLAUDE.md","text":"simulation engine built around three main components: State Management (R/state_management.R): make_state() function creates trial state containers tracking arm status (recruiting/stopped), patient registries, enrollment counts. slice_arm_data_at_time() function provides time-based snapshots patient data interim analyses, computing interval metrics via calculate_interval_metrics_fast(). Interim Logic (R/interim_logic.R): interim_check() function decision engine evaluates efficacy futility scheduled looks. branches compare_arms_option: vs-reference path: Compares experimental arms reference/control arm using calculate_current_probs_vs_ref(), evaluating per-arm gates (min_events_per_arm, min_median_followup_per_arm, min_person_time_frac_per_arm) single-arm path: Evaluates arms independently historical control targets using calculate_current_probs_hc(), optional predictive probability fallbacks R/predictive_probabilities.R Simulation Driver (R/simulation_driver.R): run_simulation_pure() function workhorse orchestrates Monte Carlo replicates, enrolling patients via piecewise exponential data generation (R/data_generation.R), applying interim checks calendar beats person-time milestones, accumulating operating characteristics (type error, power, PET, expected N).","code":""},{"path":"/CLAUDE.html","id":"statistical-helpers","dir":"","previous_headings":"Package Structure","what":"Statistical Helpers","title":"CLAUDE.md","text":"Posterior Sampling (R/posterior_helpers.R): draw_posterior_hazard_samples() draws Gamma posteriors interval hazards; calculate_median_survival_piecewise() converts hazard vectors median survival times (handles open-ended tail extrapolation) Predictive Probabilities (R/predictive_probabilities.R): calculate_predicted_success_prob_vs_hc() performs forward simulation current posterior final analysis PH Models: use_ph_model_vs_ref = TRUE, vs-reference comparisons use joint proportional-hazards model log hazard ratio priors","code":""},{"path":"/CLAUDE.html","id":"design-analysis-workflow","dir":"","previous_headings":"Package Structure","what":"Design Analysis Workflow","title":"CLAUDE.md","text":"Parameter Grid Setup: Define design grids (efficacy/futility thresholds, gates, sample sizes) Simulation: run_scenarios() wraps run_simulation_pure() batch execution across scenarios (see R/design_analysis.R) Calibration: grid_calibrate() searches efficacy/futility threshold combinations meet target type error constraints; calibrate_alpha() performs single-dimension searches Reporting: pretty_scenario_matrix() pivots results scenario × arm tables; export_scenario_table_to_excel() export_scenario_table_to_png() generate formatted outputs","code":""},{"path":"/CLAUDE.html","id":"gate-diagnostics","dir":"","previous_headings":"Package Structure","what":"Gate Diagnostics","title":"CLAUDE.md","text":"early stopping fails occur, often means information gates postpone first informative look. Use estimate_vsref_gate_timing() (R/gate_diagnostics.R) get lower-bound heuristics vs-reference gates (min_events_per_arm, min_median_followup_per_arm, min_person_time_frac_per_arm) can satisfied deterministic accrual. See README.Rmd examples.","code":""},{"path":[]},{"path":"/CLAUDE.html","id":"package-development","dir":"","previous_headings":"Development Commands","what":"Package Development","title":"CLAUDE.md","text":"","code":"# Iterative development (refreshes namespace without reinstall) devtools::load_all()  # Run tests devtools::test()  # Full R CMD check before publishing devtools::check()  # Install locally to mirror user experience devtools::install() library(evolveTrial)  # Regenerate documentation site after API changes pkgdown::build_site()  # Render README.Rmd to README.md devtools::build_readme()"},{"path":"/CLAUDE.html","id":"running-scripts","dir":"","previous_headings":"Development Commands","what":"Running Scripts","title":"CLAUDE.md","text":"","code":"# Isolated environment for scenario grids or one-off analyses Rscript path/to/script.R"},{"path":"/CLAUDE.html","id":"testing","dir":"","previous_headings":"Development Commands","what":"Testing","title":"CLAUDE.md","text":"","code":"# Run a single test file testthat::test_file(\"tests/testthat/test-estimate-vsref-gates.R\")  # Run tests matching a pattern testthat::test_local(filter = \"utils\")"},{"path":"/CLAUDE.html","id":"coding-conventions","dir":"","previous_headings":"","what":"Coding Conventions","title":"CLAUDE.md","text":"Style: Follow tidyverse conventions (two-space indentation, { line, snake_case identifiers like min_person_time_frac_per_arm) Utilities: Reuse package helpers (%||% fallback, coalesce_num() numeric coalescing, resolve_gate_vec() gate parameter resolution) instead reimplementing Diagnostics: Keep message() calls concise prefixed (e.g., [vsREF gate]) Argument Threading: adding parameters, add run_simulation_pure() formals downstream helpers can access via modifyList() Documentation: Use roxygen2 markdown format; document exported functions user-facing helpers Parameter Naming: Use harmonized naming scheme across comparison paths (e.g., efficacy_threshold_hc_prob, futility_threshold_hc_prob)","code":""},{"path":"/CLAUDE.html","id":"simulation-configuration","dir":"","previous_headings":"","what":"Simulation Configuration","title":"CLAUDE.md","text":"Key design parameters threaded run_simulation_pure() interim_check(): Arms & Comparison: arm_names, reference_arm_name, compare_arms_option (TRUE = vs-reference, FALSE = single-arm) Truth & Priors: weibull_shape_true_arms, weibull_median_true_arms, prior_alpha_params_model, prior_beta_params_model vs-reference: efficacy_threshold_vs_ref_prob, futility_threshold_vs_ref_prob, compare_arms_futility_margin single-arm: efficacy_threshold_hc_prob, futility_threshold_hc_prob, null_median_arms, futility_median_arms Deprecated (still supported warnings): efficacy_threshold_current_prob_hc, posterior_futility_threshold_hc Per-arm gates: min_events_per_arm, min_median_followup_per_arm, min_person_time_frac_per_arm (used vs-reference single-arm) Legacy global gates: min_events_hc, min_median_followup_hc, min_patients_for_analysis (single-arm ) Deprecated (still supported warnings): min_events_for_analysis, min_median_followup Proportional Scaling: min_events_per_arm min_person_time_frac_per_arm scalar, automatically scaled randomization_probs account unbalanced randomization Scheduling: interim_calendar_beat (fixed spacing) person_time_milestones (data-driven) Sample Size: max_total_patients_per_arm, cohort_size_per_arm, overall_accrual_rate, randomization_probs","code":""},{"path":"/CLAUDE.html","id":"gate-scaling-behavior","dir":"","previous_headings":"","what":"Gate Scaling Behavior","title":"CLAUDE.md","text":"recent updates, vs-reference single-arm paths apply proportional gate scaling scalar gate values provided: gets scaled: min_events_per_arm min_person_time_frac_per_arm (provided scalars) doesn’t get scaled: min_median_followup_per_arm (followup time independent randomization ratio) scaling works: specify min_events_per_arm = 10 randomization_probs = c(Control = 0.3, Treatment = 0.7), helper resolve_gate_vec() (R/gate_diagnostics.R) scale gates proportionally: arms lower randomization probabilities get proportionally lower gates use named vectors: override proportional scaling, provide named vector (e.g., min_events_per_arm = c(Control = 8, Treatment = 12)) ensures fairness comparing arms unbalanced randomization, unifies behavior across comparison paths.","code":""},{"path":"/CLAUDE.html","id":"testing-approach","dir":"","previous_headings":"","what":"Testing Approach","title":"CLAUDE.md","text":"New decision logic gating features require regression tests tests/testthat/. Prioritize: - Multi-arm comparisons reference arm switches - Proportional gate scaling across unbalanced arms (see test-single-arm-gates.R test-path-parity.R) - Predictive probability fallback triggers - Use deterministic seeds (set.seed(4242)) low simulation counts (e.g., num_simulations = 50) unit tests - Document required outputs (PET, alpha, expected N) expect_*() calls catch behavior shifts - Parity tests ensure single-arm vs-reference paths maintain consistent behavior","code":""},{"path":"/CLAUDE.html","id":"project-management","dir":"","previous_headings":"","what":"Project Management","title":"CLAUDE.md","text":"Dependencies: Managed via renv/ reproducibility; renv::restore() sync Documentation: man/ holds function docs; vignettes/ contains long-form guides; _pkgdown.yml configures browsable site Artifacts: Keep ad-hoc scenario grids analysis scripts project root inst/; exclude package namespace Commit Style: Imperative, present-tense titles 72 characters (e.g., “Add one-time interval rebalancing support”); group related code/docs/tests single commits; link upstream issues context","code":""},{"path":[]},{"path":"/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement naim.rashid84@gmail.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to evolveTrial","title":"Contributing to evolveTrial","text":"outlines propose change evolveTrial. detailed discussion contributing tidyverse packages, please see development contributing guide code review principles.","code":""},{"path":"/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to evolveTrial","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ’ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"/CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to evolveTrial","text":"want make bigger change, ’s good idea first file issue make sure someone team agrees ’s needed. ’ve found bug, please file issue illustrates bug minimal reprex (also help write unit test, needed). See guide create great issue advice.","code":""},{"path":"/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to evolveTrial","text":"Fork package clone onto computer. haven’t done , recommend using usethis::create_from_github(\"naimurashid/evolveTrial\", fork = TRUE). Install development dependencies devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e. just first header). Follow style described https://style.tidyverse.org/news.html.","code":""},{"path":"/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to evolveTrial","text":"New code follow tidyverse style guide. can use Air apply style, please don’t restyle code nothing PR. use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":"/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to evolveTrial","text":"Please note evolveTrial project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 Naim Rashid Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":null,"dir":"","previous_headings":"","what":"evolveTrial Percentile Enhancement Specification","title":"evolveTrial Percentile Enhancement Specification","text":"STATUS: ✅ IMPLEMENTED (2025-12-07)","code":""},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"evolveTrial Percentile Enhancement Specification","text":"document specifies add exact sample size percentile calculation run_simulation_pure() minimal computational overhead. implementation completed following specification. Key functions modified: - run_simulation_pure() - Added return_percentiles percentile_probs parameters - run_scenarios() - Added pass-support percentile parameters","code":""},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"problem-statement","dir":"","previous_headings":"","what":"Problem Statement","title":"evolveTrial Percentile Enhancement Specification","text":"Currently, evolveTrial returns aggregate statistics (mean EN, power, type error). statistical SAP sections, need distribution sample sizes across simulations, specifically: - Min, 25th percentile, Median, 75th percentile, 90th percentile, Max","code":""},{"path":[]},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"option-a-accumulate-raw-values-recommended","dir":"","previous_headings":"Design Decision: Accumulate Raw Values vs Online Quantile Estimation","what":"Option A: Accumulate Raw Values (Recommended)","title":"evolveTrial Percentile Enhancement Specification","text":"Store per-replicate sample sizes vector, compute percentiles end. Memory cost: ~8 bytes × n_reps × n_arms = ~80KB 10,000 reps × 1 arm Pros: - Exact percentiles - Simple implementation - Memory cost trivial typical use cases (10K-50K reps) - Supports arbitrary percentile queries post-hoc Cons: - Memory scales n_reps (negligible)","code":""},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"option-b-online-quantile-estimation-p²-algorithm","dir":"","previous_headings":"Design Decision: Accumulate Raw Values vs Online Quantile Estimation","what":"Option B: Online Quantile Estimation (P² Algorithm)","title":"evolveTrial Percentile Enhancement Specification","text":"Estimate quantiles incrementally without storing values. Memory cost: O(1) per tracked percentile Pros: - Constant memory regardless n_reps Cons: - Approximate, exact - complex implementation - Fixed percentiles must chosen upfront - P² can accuracy issues heavy-tailed distributions","code":""},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"recommendation","dir":"","previous_headings":"Design Decision: Accumulate Raw Values vs Online Quantile Estimation","what":"Recommendation","title":"evolveTrial Percentile Enhancement Specification","text":"Use Option (accumulate raw values). memory overhead negligible (<1MB even 100K reps), get exact results simple implementation.","code":""},{"path":[]},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"id_1-add-new-parameter-to-run_simulation_pure","dir":"","previous_headings":"Implementation Plan","what":"1. Add New Parameter to run_simulation_pure()","title":"evolveTrial Percentile Enhancement Specification","text":"","code":"run_simulation_pure <- function(     num_simulations,     # ... existing params ...     return_percentiles = FALSE,  # NEW: Return sample size percentiles     percentile_probs = c(0, 0.25, 0.5, 0.75, 0.9, 1.0),  # NEW: Which percentiles to compute     # ... )"},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"id_2-initialize-storage-only-when-return_percentiles--true","dir":"","previous_headings":"Implementation Plan","what":"2. Initialize Storage (only when return_percentiles = TRUE)","title":"evolveTrial Percentile Enhancement Specification","text":"existing initialization (around line 430):","code":"# Percentile tracking (when enabled) if (isTRUE(return_percentiles)) {   # Pre-allocate vectors for all replicates   all_final_n <- vector(\"list\", length(arm_names))   names(all_final_n) <- arm_names   for (arm in arm_names) {     all_final_n[[arm]] <- numeric(num_simulations)   } }"},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"id_3-modify-simulate_chunk-to-return-raw-values","dir":"","previous_headings":"Implementation Plan","what":"3. Modify simulate_chunk() to Return Raw Values","title":"evolveTrial Percentile Enhancement Specification","text":"simulate_chunk(), add collection per-replicate values enabled:","code":"simulate_chunk <- function(sim_indices, seed = NULL, tick = function() {}) {   # ... existing code ...    # NEW: Track per-replicate sample sizes for percentiles   chunk_final_n_raw <- if (collect_raw) {     lapply(arm_names, function(arm) numeric(length(sim_indices)))   } else NULL   if (!is.null(chunk_final_n_raw)) names(chunk_final_n_raw) <- arm_names    for (i in seq_along(sim_indices)) {     # ... existing simulation code ...      # After computing final_n_vec (around line 626):     chunk_sum_final_n <- chunk_sum_final_n + final_n_vec      # NEW: Store raw values for percentile calculation     if (!is.null(chunk_final_n_raw)) {       for (arm in arm_names) {         chunk_final_n_raw[[arm]][i] <- final_n_vec[arm]       }     }      # ... rest of loop ...   }    # Return structure (around line 637):   list(     sum_final_n = chunk_sum_final_n,     # ... existing fields ...     final_n_raw = chunk_final_n_raw  # NEW (NULL if not collecting)   ) }"},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"id_4-modify-aggregate_results-to-combine-raw-vectors","dir":"","previous_headings":"Implementation Plan","what":"4. Modify aggregate_results() to Combine Raw Vectors","title":"evolveTrial Percentile Enhancement Specification","text":"","code":"aggregate_results <- function(partials) {   # ... existing aggregation ...    # NEW: Combine raw vectors across chunks   if (!is.null(partials[[1]]$final_n_raw)) {     for (arm in arm_names) {       all_final_n[[arm]] <<- unlist(lapply(partials, function(p) p$final_n_raw[[arm]]))     }   } }"},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"id_5-compute-and-return-percentiles","dir":"","previous_headings":"Implementation Plan","what":"5. Compute and Return Percentiles","title":"evolveTrial Percentile Enhancement Specification","text":"aggregate_results() call (around line 775), add percentile computation:","code":"# Compute percentiles if requested percentiles_result <- NULL if (isTRUE(return_percentiles) && !is.null(all_final_n)) {   percentiles_result <- lapply(arm_names, function(arm) {     quantile(all_final_n[[arm]], probs = percentile_probs, na.rm = TRUE)   })   names(percentiles_result) <- arm_names }  # Modify return (around line 798) if (isTRUE(return_percentiles)) {   return(list(     summary = results_data,     percentiles = list(       N = percentiles_result,       probs = percentile_probs     )   )) } else {   return(results_data) }"},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"id_6-update-run_scenarios-to-support-percentiles","dir":"","previous_headings":"Implementation Plan","what":"6. Update run_scenarios() to Support Percentiles","title":"evolveTrial Percentile Enhancement Specification","text":"run_scenarios(), pass percentile parameters:","code":"run_scenarios <- function(base_args, scens, parallel = FALSE, seed = NULL,                           return_percentiles = FALSE,                           percentile_probs = c(0, 0.25, 0.5, 0.75, 0.9, 1.0)) {   # ... existing code ...    for (i in seq_along(scens)) {     args_i <- modifyList(base_args, scens[[i]])     args_i$return_percentiles <- return_percentiles     args_i$percentile_probs <- percentile_probs      res <- do.call(run_simulation_pure, args_i)      if (return_percentiles) {       all_results[[i]] <- res$summary       all_percentiles[[i]] <- res$percentiles     } else {       all_results[[i]] <- res     }   }    # Return   if (return_percentiles) {     list(       summary = do.call(rbind, all_results),       percentiles = all_percentiles     )   } else {     do.call(rbind, all_results)   } }"},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"usage-example","dir":"","previous_headings":"","what":"Usage Example","title":"evolveTrial Percentile Enhancement Specification","text":"","code":"# Run with percentile collection result <- run_simulation_pure(   num_simulations = 10000,   # ... other params ...   return_percentiles = TRUE,   percentile_probs = c(0, 0.25, 0.5, 0.75, 0.9, 1.0) )  # Access results summary_df <- result$summary  # Same as before percentiles <- result$percentiles$N  # List by arm  # For single-arm: # percentiles$Experimental gives: c(min, 25th, median, 75th, 90th, max)"},{"path":[]},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"memory","dir":"","previous_headings":"Performance Impact","what":"Memory","title":"evolveTrial Percentile Enhancement Specification","text":"10,000 reps × 1 arm: ~80 KB 10,000 reps × 3 arms: ~240 KB 100,000 reps × 3 arms: ~2.4 MB negligible compared simulation state memory.","code":""},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"cpu","dir":"","previous_headings":"Performance Impact","what":"CPU","title":"evolveTrial Percentile Enhancement Specification","text":"Storage: One assignment per replicate per arm (~negligible) Percentile computation: O(n log n) sorting, done end 10,000 reps: <10ms additional time","code":""},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"backward-compatibility","dir":"","previous_headings":"Performance Impact","what":"Backward Compatibility","title":"evolveTrial Percentile Enhancement Specification","text":"return_percentiles = FALSE (default), behavior identical current version Return type changes return_percentiles = TRUE","code":""},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"testing","dir":"","previous_headings":"","what":"Testing","title":"evolveTrial Percentile Enhancement Specification","text":"Add tests verify: 1. Percentiles correct (compare known distributions) 2. Means computed raw values match Exp_N 3. Parallel sequential modes give consistent results 4. Default behavior unchanged","code":""},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"files-to-modify","dir":"","previous_headings":"","what":"Files to Modify","title":"evolveTrial Percentile Enhancement Specification","text":"R/simulation_driver.R - Main changes run_simulation_pure() R/design_analysis.R - Update run_scenarios() wrapper man/run_simulation_pure.Rd - Document new parameters tests/testthat/test_percentiles.R - New test file","code":""},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"estimated-effort","dir":"","previous_headings":"","what":"Estimated Effort","title":"evolveTrial Percentile Enhancement Specification","text":"Implementation: 2-3 hours Testing: 1-2 hours Documentation: 30 minutes Total: ~4-5 hours","code":""},{"path":"/PROFILING_RESULTS.html","id":null,"dir":"","previous_headings":"","what":"evolveTrial Profiling Results","title":"evolveTrial Profiling Results","text":"Date: 2025-12-03 Profiler: R Rprof (sequential execution visibility)","code":""},{"path":"/PROFILING_RESULTS.html","id":"executive-summary","dir":"","previous_headings":"","what":"Executive Summary","title":"evolveTrial Profiling Results","text":"Profiling reveals main bottleneck evolveTrial PSOCK cluster spawn/teardown overhead, simulation logic . call run_simulation_pure() parallel_replicates = TRUE creates destroys parallel cluster, adds significant overhead called repeatedly (e.g., Bayesian optimization loops).","code":""},{"path":[]},{"path":[]},{"path":"/PROFILING_RESULTS.html","id":"id_1-psock-cluster-spawnteardown-critical","dir":"","previous_headings":"Identified Bottlenecks","what":"1. PSOCK Cluster Spawn/Teardown (CRITICAL)","title":"evolveTrial Profiling Results","text":"Location: R/simulation_driver.R lines 689-705 Impact: - BO evaluation creates/destroys cluster - Worker processes must load evolveTrial package time - PSOCK requires full R process spawn + socket communication","code":"cl <- parallel::makeCluster(workers, type = cluster_type) on.exit(parallel::stopCluster(cl), add = TRUE) parallel::clusterCall(cl, function(pkg) {   suppressPackageStartupMessages(require(pkg, character.only = TRUE)) }, pkg_name)"},{"path":"/PROFILING_RESULTS.html","id":"id_2-jit-compilation-overhead","dir":"","previous_headings":"Identified Bottlenecks","what":"2. JIT Compilation Overhead","title":"evolveTrial Profiling Results","text":"Location: Throughout R code Profile evidence: - h, tryInline, cmpCall, cmp, genCode, cmpfun top functions - findCenvVar, cb$makelabel, putconst show compiler activity Impact: - Functions recompiled worker process - caching compiled bytecode across calls","code":""},{"path":"/PROFILING_RESULTS.html","id":"id_3-invisible-worker-time","dir":"","previous_headings":"Identified Bottlenecks","what":"3. Invisible Worker Time","title":"evolveTrial Profiling Results","text":"Issue: Rprof runs parent process; PSOCK workers separate R processes Result: - 40.59 sec total, 0.08 sec visible profiler - directly profile happens inside simulate_chunk()","code":""},{"path":[]},{"path":[]},{"path":"/PROFILING_RESULTS.html","id":"id_1-implement-cluster-pooling","dir":"","previous_headings":"Optimization Recommendations > High Priority (Large Impact)","what":"1. Implement Cluster Pooling","title":"evolveTrial Profiling Results","text":"Add option reuse persistent cluster across multiple BO evaluations: Expected improvement: 10-50x faster repeated calls","code":"# New API option run_simulation_pure(..., cluster = NULL)  # If NULL, use internal pooling  # Usage pattern cl <- evolveTrial::get_cluster(workers = 8)  # Create once for (i in 1:100) {   run_simulation_pure(..., cluster = cl)  # Reuse } evolveTrial::release_cluster(cl)  # Cleanup"},{"path":"/PROFILING_RESULTS.html","id":"id_2-use-fork-instead-of-psock-on-linux","dir":"","previous_headings":"Optimization Recommendations > High Priority (Large Impact)","what":"2. Use FORK Instead of PSOCK on Linux","title":"evolveTrial Profiling Results","text":"FORK clusters share memory don’t require serialization: Benefits: - package loading workers (inherited) - data serialization (copy--write) - Much faster startup Expected improvement: 2-5x Linux/macOS","code":"cluster_type <- if (.Platform$OS.type == \"unix\") \"FORK\" else \"PSOCK\""},{"path":"/PROFILING_RESULTS.html","id":"id_3-threshold-for-sequential-execution","dir":"","previous_headings":"Optimization Recommendations > High Priority (Large Impact)","what":"3. Threshold for Sequential Execution","title":"evolveTrial Profiling Results","text":"small rep counts, sequential faster parallel overhead:","code":"# Rule of thumb: parallel_replicates makes sense only if: # num_simulations * time_per_rep > cluster_overhead (typically 5-10 sec) if (num_simulations < 50) {   parallel_replicates <- FALSE }"},{"path":[]},{"path":"/PROFILING_RESULTS.html","id":"id_4-pre-compile-critical-functions","dir":"","previous_headings":"Optimization Recommendations > Medium Priority","what":"4. Pre-compile Critical Functions","title":"evolveTrial Profiling Results","text":"Add package .onLoad():","code":".onLoad <- function(libname, pkgname) {   # Pre-compile hot path functions   assign(\"simulate_chunk\", compiler::cmpfun(simulate_chunk), envir = parent.env(environment()))   assign(\"interim_check\", compiler::cmpfun(interim_check), envir = parent.env(environment()))   # etc. }"},{"path":"/PROFILING_RESULTS.html","id":"id_5-export-cluster-for-external-use","dir":"","previous_headings":"Optimization Recommendations > Medium Priority","what":"5. Export Cluster for External Use","title":"evolveTrial Profiling Results","text":"Allow BO packages manage cluster lifecycle:","code":"#' Create a reusable evolveTrial cluster #' @export create_simulation_cluster <- function(workers = NULL, cluster_type = \"auto\") {   workers <- workers %||% max(1L, parallel::detectCores() - 1L)   if (cluster_type == \"auto\") {     cluster_type <- if (.Platform$OS.type == \"unix\") \"FORK\" else \"PSOCK\"   }   cl <- parallel::makeCluster(workers, type = cluster_type)   parallel::clusterEvalQ(cl, library(evolveTrial))   class(cl) <- c(\"evolveTrial_cluster\", class(cl))   cl }"},{"path":[]},{"path":"/PROFILING_RESULTS.html","id":"id_6-internal-simulation-optimization","dir":"","previous_headings":"Optimization Recommendations > Low Priority","what":"6. Internal Simulation Optimization","title":"evolveTrial Profiling Results","text":"simulate_chunk() function appears efficient (~1.2 ms/rep run sequentially). C++ implementations posterior sampling already place. Potential micro-optimizations: - Vectorize patient enrollment loop - Pre-allocate result matrices - Use integer arithmetic possible","code":""},{"path":"/PROFILING_RESULTS.html","id":"implemented-optimizations-2025-12-03","dir":"","previous_headings":"","what":"Implemented Optimizations (2025-12-03)","title":"evolveTrial Profiling Results","text":"three high-priority optimizations implemented R/simulation_driver.R:","code":""},{"path":"/PROFILING_RESULTS.html","id":"id_1-cluster-pooling-","dir":"","previous_headings":"Implemented Optimizations (2025-12-03)","what":"1. Cluster Pooling ✅","title":"evolveTrial Profiling Results","text":"New parameter cluster added run_simulation_pure() accept external cluster: New exported functions: - create_simulation_cluster(workers, cluster_type) - Create reusable cluster - release_cluster(cluster) - Clean cluster resources","code":"# Create cluster once for all BO evaluations cl <- evolveTrial::create_simulation_cluster(workers = 8)  # Use in repeated BO evaluations (100+ calls) for (i in 1:100) {   result <- run_simulation_pure(     num_simulations = 500,     ...,     parallel_replicates = TRUE,     cluster = cl  # Reuses cluster, no spawn/teardown overhead   ) }  # Clean up when done evolveTrial::release_cluster(cl)"},{"path":"/PROFILING_RESULTS.html","id":"id_2-fork-auto-detection-","dir":"","previous_headings":"Implemented Optimizations (2025-12-03)","what":"2. FORK Auto-Detection ✅","title":"evolveTrial Profiling Results","text":"Default cluster_type changed \"PSOCK\" \"auto\": Benefits Linux/macOS: - FORK inherits parent environment (package loading workers) - Copy--write memory (serialization overhead) - ~2-5x faster cluster startup","code":"# Auto-detection logic (in simulation_driver.R) if (cluster_type == \"auto\") {   cluster_type <- if (.Platform$OS.type == \"unix\") \"FORK\" else \"PSOCK\" }"},{"path":"/PROFILING_RESULTS.html","id":"id_3-sequential-threshold-","dir":"","previous_headings":"Implemented Optimizations (2025-12-03)","what":"3. Sequential Threshold ✅","title":"evolveTrial Profiling Results","text":"Increased threshold workers * 2 100 (configurable): Rationale: - Cluster spawn/teardown: ~5-10 sec - Sequential simulation: ~1-2 ms/rep - Breakeven ~100 reps typical config Configuration:","code":"# Threshold is configurable via option seq_threshold <- getOption(\"evolveTrial.sequential_threshold\", 100L)  if (num_simulations < seq_threshold) {   # Run sequentially - faster than parallel overhead   chunk_results <- list(simulate_chunk(...)) } # Lower threshold for fast machines options(evolveTrial.sequential_threshold = 50)  # Higher threshold if cluster overhead is high options(evolveTrial.sequential_threshold = 200)"},{"path":[]},{"path":"/PROFILING_RESULTS.html","id":"api-changes-summary","dir":"","previous_headings":"Implemented Optimizations (2025-12-03)","what":"API Changes Summary","title":"evolveTrial Profiling Results","text":"New parameters run_simulation_pure(): - cluster_type = c(\"auto\", \"PSOCK\", \"FORK\") - Default changed “auto” - cluster = NULL - Pass external cluster pooling New exported functions: - create_simulation_cluster() - Create persistent cluster - release_cluster() - Clean cluster New option: - evolveTrial.sequential_threshold - Override default threshold (100)","code":""},{"path":"/PROFILING_RESULTS.html","id":"files-created","dir":"","previous_headings":"","what":"Files Created","title":"evolveTrial Profiling Results","text":"tests/profile_sequential.R - Sequential profiling script PROFILING_RESULTS.md - document","code":""},{"path":"/PROFILING_RESULTS.html","id":"verification","dir":"","previous_headings":"","what":"Verification","title":"evolveTrial Profiling Results","text":"reproduce profiling: compare parallel (paper directory):","code":"cd /home/naimrashid/Downloads/evolveTrial Rscript tests/profile_sequential.R cd /home/naimrashid/Downloads/adaptive-trial-bo-paper Rscript scripts/profile_comprehensive.R"},{"path":"/REPORT_OF_BUGS.html","id":"identified-bugs","dir":"","previous_headings":"","what":"Identified Bugs","title":"NA","text":"Based examination commit 011a5d38616f3e24e75e5c8dd1f9c8863b8f5141 (“perf: C++ matrix median control arm posterior caching”), following potential bugs identified:","code":""},{"path":"/REPORT_OF_BUGS.html","id":"bug-1-inconsistency-in-interval_lengths-handling-for-ctrl_cache","dir":"","previous_headings":"Identified Bugs","what":"Bug 1: Inconsistency in interval_lengths handling for ctrl_cache","title":"NA","text":"Files Affected: * R/posterior_helpers.R * R/interim_logic.R Description: precompute_ctrl_posteriors function R/posterior_helpers.R calculates interval_lengths includes returned ctrl_cache list. cache passed sample_vs_ref_medians_independent (via sample_vs_ref_medians). However, within sample_vs_ref_medians_independent, interval_lengths recalculated beginning function using diff(args$interval_cutpoints_sim), even ctrl_cache provided. ctrl_cache$interval_lengths value, available, never used. re-calculated interval_lengths subsequently used median survival calculations (med_ctrl med_trt). Impact: args$interval_cutpoints_sim might constant within single simulation run, creates logical inconsistency. 1. Redundancy: Caching interval_lengths precompute_ctrl_posteriors becomes redundant. 2. Potential Error: , future scenario, args$interval_cutpoints_sim mutated interpreted differently time caching use, discrepancy lead incorrect median survival calculations erroneous trial results. subtle bug manifest specific, hard--debug conditions. Severity: Medium (Potential subtle, hard--trace errors; best, inefficient redundant caching). Proposed Fix (Conceptual): Modify sample_vs_ref_medians_independent conditionally use ctrl_cache$interval_lengths ctrl_cache provided, instead always recalculating .","code":"# In R/posterior_helpers.R, inside sample_vs_ref_medians_independent:  sample_vs_ref_medians_independent <- function(slCtrl, slTrt, args, num_samples,                                                ctrl_cache = NULL) {   # Determine interval_lengths: use cached if available, otherwise calculate   if (!is.null(ctrl_cache)) {     interval_lengths <- ctrl_cache$interval_lengths # Use cached value   } else {     interval_lengths <- diff(args$interval_cutpoints_sim) # Calculate if not cached   }    # ... rest of the function remains the same, using the determined interval_lengths }"},{"path":"/REPORT_OF_BUGS.html","id":"bug-2-potential-edge-case-differences-between-r-and-c-median-survival-calculations","dir":"","previous_headings":"Identified Bugs","what":"Bug 2: Potential edge case differences between R and C++ median survival calculations","title":"NA","text":"Files Affected: * R/posterior_helpers.R * R/interim_logic.R * R/predictive_probabilities.R * R/simulation_driver.R * R/posterior_cpp_dispatchers.R * (Potentially src/posterior_sampling.cpp similar C++ file, contains calculate_median_survival_matrix_cpp) Description: performance optimization commit (011a5d38616f3e24e75e5c8dd1f9c8863b8f5141) replaced multiple instances R’s apply(..., calculate_median_survival_piecewise, ...) direct calls C++ function calculate_median_survival_matrix_cpp. intended significant performance gains, transitioning core numerical calculations R C++ often introduces subtle discrepancies. Impact: C++ implementations, even designed replicate R logic, can sometimes exhibit different behaviors edge cases : * Handling NA/NaN/Inf values: R specific ways propagating handling ; C++ might require explicit checks. * Floating-point precision: Differences compiler optimizations default floating-point types might lead minor numerical discrepancies, especially small large numbers, many iterations. * Implicit Type Coercion: R’s type coercion rules complex; C++ stricter. * Input Validation: C++ function might different assumptions input dimensions, types, valid ranges R function replaces. differences lead subtle numerical deviations median survival times, affecting accuracy simulation results specific, potentially rare, input conditions. Without direct access comparison source code calculate_median_survival_piecewise (R) calculate_median_survival_matrix_cpp (C++), comprehensive comparative unit tests, difficult guarantee exact equivalence across possible scenarios. Severity: High (bug impacts core statistical calculations, potentially undermining validity simulation results. subtle nature makes hard detect without dedicated testing code review.) Verification/Mitigation: verify mitigate potential bug, following steps necessary: 1. Code Review: Thoroughly compare R source code calculate_median_survival_piecewise C++ source code calculate_median_survival_matrix_cpp (likely src/posterior_sampling.cpp related C++ file). 2. Comparative Unit Testing: Develop comprehensive suite unit tests generate various inputs (including edge cases like zero hazards, long intervals, short intervals, NA values hazard rates, etc.) run R C++ implementations, comparing outputs exact equivalence acceptable numerical tolerance. 3. Integration Testing: Ensure C++ function integrates seamlessly R ecosystem without unexpected side effects.","code":""},{"path":"/REPORT_OF_BUGS.html","id":"analysis-of-commit-bbc9032280efb1152e4372a4efc552a94ffb344b-update","dir":"","previous_headings":"Identified Bugs","what":"Analysis of Commit: bbc9032280efb1152e4372a4efc552a94ffb344b (“update”)","title":"NA","text":"Status: bugs found. (Commit fix).","code":""},{"path":"/REPORT_OF_BUGS.html","id":"analysis-of-commit-52d3b8585d99dac61063e3e0ccee3c88c2cb491b-update","dir":"","previous_headings":"Identified Bugs","what":"Analysis of Commit: 52d3b8585d99dac61063e3e0ccee3c88c2cb491b (“update”)","title":"NA","text":"Status: bugs found. (Implemented “Expected Events” tracking correctly).","code":""},{"path":"/REPORT_OF_BUGS.html","id":"analysis-of-commit-ee292d60c82df4259b3920dd90c874466645d72c-update","dir":"","previous_headings":"Identified Bugs","what":"Analysis of Commit: ee292d60c82df4259b3920dd90c874466645d72c (“update”)","title":"NA","text":"Status: bugs found. (Configuration change: .Rprofile.disabled).","code":""},{"path":"/REPORT_OF_BUGS.html","id":"analysis-of-commit-ab59ae17306185f1e84345de598878bf356169b3-update","dir":"","previous_headings":"Identified Bugs","what":"Analysis of Commit: ab59ae17306185f1e84345de598878bf356169b3 (“update”)","title":"NA","text":"Status: bugs found. (Added binary GPG key).","code":""},{"path":"/REPORT_OF_BUGS.html","id":"analysis-of-commit-aa22a4f8ae5bc4a709117b3ffb3e5d4e40176dcd-feat-perform-comprehensive-code-review","dir":"","previous_headings":"Identified Bugs","what":"Analysis of Commit: aa22a4f8ae5bc4a709117b3ffb3e5d4e40176dcd (“feat: Perform comprehensive code review…”)","title":"NA","text":"Overview: major refactoring commit harmonized parameter names, split interim_check function, cleaned state_management.R. Findings: * Code Safety: commit introduces stricter requirements args$max_total_patients_per_arm (must named vector) gates_pass_for_both_arms. robust improvement. * Logic Correctness: interim_check_vs_ref function correctly constructs two-arm context (args_gate$arm_names) calling gate checking helper. prevents ambiguity multi-arm trials. * Parameter Handling: Deprecated parameters correctly mapped new harmonized equivalents warnings, ensuring backward compatibility encouraging migration. * Conclusion: bugs found. refactoring appears careful structurally sound.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Naim Rashid. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Rashid N (2025). evolveTrial: Adaptive Clinical Trial Utilities. R package version 0.0.0.9000.","code":"@Manual{,   title = {evolveTrial: Adaptive Clinical Trial Utilities},   author = {Naim Rashid},   year = {2025},   note = {R package version 0.0.0.9000}, }"},{"path":"/index.html","id":"evolvetrial","dir":"","previous_headings":"","what":"Adaptive Clinical Trial Utilities","title":"Adaptive Clinical Trial Utilities","text":"evolveTrial provides utilities designing simulating Bayesian adaptive platform umbrella clinical trials time--event endpoints. package supports ARPA-H ADAPT breast cancer platform trial design.","code":""},{"path":"/index.html","id":"key-features","dir":"","previous_headings":"","what":"Key Features","title":"Adaptive Clinical Trial Utilities","text":"Multi-arm adaptive trials: Simulate trials comparing experimental arms reference arm proportional hazards Single-arm vs historical control: Evaluate efficacy relative historical benchmarks Bayesian decision rules: Interim stopping efficacy futility based posterior probabilities Piecewise exponential hazards: Flexible time--event modeling interval-specific hazards Information gates: Control interim timing via minimum events, median follow-, person-time requirements Operating characteristics: Type error, power, expected sample size, probability early termination C++ acceleration: Posterior sampling hazard computations via Rcpp high performance","code":""},{"path":[]},{"path":"/index.html","id":"from-github-recommended","dir":"","previous_headings":"Installation","what":"From GitHub (Recommended)","title":"Adaptive Clinical Trial Utilities","text":"Install development version GitHub using one methods:","code":"# Using pak (fastest) install.packages(\"pak\") pak::pak(\"naimurashid/evolveTrial\")  # Or using remotes install.packages(\"remotes\") remotes::install_github(\"naimurashid/evolveTrial\")  # Or using devtools install.packages(\"devtools\") devtools::install_github(\"naimurashid/evolveTrial\")"},{"path":"/index.html","id":"dependencies","dir":"","previous_headings":"Installation","what":"Dependencies","title":"Adaptive Clinical Trial Utilities","text":"package requires: Core: data.table, ggplot2, magrittr, progress, tidyselect Suggested: dplyr, gt, openxlsx, ggrepel, knitr, rmarkdown dependencies installed automatically install evolveTrial.","code":""},{"path":"/index.html","id":"development-installation","dir":"","previous_headings":"Installation","what":"Development Installation","title":"Adaptive Clinical Trial Utilities","text":"development work latest features:","code":"# Clone the repository git clone https://github.com/naimurashid/evolveTrial.git  # Load in R session devtools::load_all(\"path/to/evolveTrial\")"},{"path":"/index.html","id":"diagnosing-interim-gating-choices","dir":"","previous_headings":"","what":"Diagnosing interim gating choices","title":"Adaptive Clinical Trial Utilities","text":"early stopping seem occur simulations, often information gates (minimum events, median follow-, required person-time) postpone first informative interim look late trial. helper estimate_vsref_gate_timing() gives quick lower-bound heuristics gates can satisfied deterministic accrual. configuration joint lower bound roughly 18 months, meaning 3-month calendar beats first eligible interim look occur near sixth look. Adjusting information gates (example lowering person-time fraction minimum median follow-) yields earlier opportunities efficacy/futility stopping.","code":"library(evolveTrial)  args <- list(   arm_names = c(\"Doublet\", \"Triplet\"),   reference_arm_name = \"Doublet\",   overall_accrual_rate = 3,   randomization_probs = c(Doublet = 0.5, Triplet = 0.5),   max_total_patients_per_arm = c(Doublet = 70, Triplet = 70),   max_follow_up_sim = 24,   min_events_per_arm = 8,   min_median_followup_per_arm = 3,   min_person_time_frac_per_arm = 0.15 )  estimate_vsref_gate_timing(args)"},{"path":[]},{"path":"/index.html","id":"example-1-multi-arm-trial-experimental-vs-reference","dir":"","previous_headings":"Minimal Working Examples","what":"Example 1: Multi-arm Trial (Experimental vs Reference)","title":"Adaptive Clinical Trial Utilities","text":"Simulate two-arm trial comparing Triplet therapy Doublet (reference) interim efficacy futility stopping:","code":"library(evolveTrial)  # Define trial arguments args <- list(   # Arm configuration   arm_names = c(\"Doublet\", \"Triplet\"),   reference_arm_name = \"Doublet\",   randomization_probs = c(Doublet = 0.5, Triplet = 0.5),   overall_accrual_rate = 3,    # Sample size limits   max_total_patients_per_arm = c(Doublet = 70, Triplet = 70),   max_follow_up_sim = 24,    # Piecewise hazards (8 3-month intervals)   pw_hazards = list(     Doublet = rep(0.12, 8),  # Median ~6 months     Triplet = rep(0.077, 8)  # Median ~9 months (HR = 0.67)   ),   interval_width = 3,    # Bayesian decision thresholds   efficacy_prob_threshold_vsref = 0.99,   futility_prob_threshold_vsref = 0.10,    # Information gates   min_events_per_arm = 8,   min_median_followup_per_arm = 3,   min_person_time_frac_per_arm = 0.15,    # Interim schedule   beat_interval = 3,    # MCMC settings   n_posterior_draws = 5000 )  # Run Monte Carlo simulation (100 replicates for demo) result <- run_single_scenario(args, n_sim = 100, seed = 2025)  # View key operating characteristics summary(result) #> Power: ~80%, Type I error: ~10%, Expected N: ~85 per arm"},{"path":"/index.html","id":"example-2-single-arm-vs-historical-control","dir":"","previous_headings":"Minimal Working Examples","what":"Example 2: Single-arm vs Historical Control","title":"Adaptive Clinical Trial Utilities","text":"Evaluate single experimental arm historical median survival:","code":"library(evolveTrial)  # Define trial arguments for single-arm design args_sa <- list(   # Arm configuration (vs historical control)   arm_names = c(\"Control\", \"Experimental\"),   reference_arm_name = \"Control\",   use_historical_control = TRUE,   randomization_probs = c(Control = 0, Experimental = 1),   overall_accrual_rate = 2,    # Sample size   max_total_patients_per_arm = c(Control = 0, Experimental = 60),   max_follow_up_sim = 24,    # Hazards: Historical median 6 months, experimental median 9 months   pw_hazards = list(     Control = rep(0.116, 8),      # Historical: median 6 mo     Experimental = rep(0.077, 8)  # Expected: median 9 mo   ),   interval_width = 3,    # Decision thresholds vs historical   efficacy_prob_threshold_hc = 0.95,   futility_prob_threshold_hc = 0.05,    # Information gates   min_events_hc = 15,    # Interim schedule   beat_interval = 3,   n_posterior_draws = 5000 )  # Run simulation result_sa <- run_single_scenario(args_sa, n_sim = 100, seed = 2025)  # View operating characteristics summary(result_sa)"},{"path":"/index.html","id":"example-3-grid-search-for-optimal-thresholds","dir":"","previous_headings":"Minimal Working Examples","what":"Example 3: Grid Search for Optimal Thresholds","title":"Adaptive Clinical Trial Utilities","text":"Find efficacy/futility thresholds meet operating characteristic targets:","code":"library(evolveTrial)  # Base trial configuration args <- list(   arm_names = c(\"Control\", \"Experimental\"),   reference_arm_name = \"Control\",   use_historical_control = TRUE,   randomization_probs = c(Control = 0, Experimental = 1),   overall_accrual_rate = 2,   max_total_patients_per_arm = c(Control = 0, Experimental = 60),   max_follow_up_sim = 24,   pw_hazards = list(     Control = rep(0.116, 8),     Experimental = rep(0.077, 8)   ),   interval_width = 3,   min_events_hc = 15,   beat_interval = 3,   n_posterior_draws = 5000 )  # Define threshold grid grid <- expand.grid(   efficacy_prob_threshold_hc = c(0.90, 0.95, 0.99),   futility_prob_threshold_hc = c(0.05, 0.10, 0.15) )  # Evaluate grid (use evaluate_hc_grid for historical control) results <- evaluate_hc_grid(   base_args = args,   grid = grid,   n_sim = 500,   parallel = TRUE,   seed = 2025 )  # Filter feasible designs (type I <= 0.10, power >= 0.80) feasible <- filter_feasible_designs(   results,   alpha_cap = 0.10,   power_floor = 0.80 )  # Recommend optimal design (minimizes expected N) best <- recommend_design(feasible) print(best)"},{"path":[]},{"path":"/index.html","id":"package-structure","dir":"","previous_headings":"","what":"Package Structure","title":"Adaptive Clinical Trial Utilities","text":"","code":"evolveTrial/ ├── R/ │   ├── simulation_driver.R      # Main simulation functions │   ├── design_analysis.R        # Grid search and optimization │   ├── gate_diagnostics.R       # Information gate utilities │   ├── interim_logic.R          # Stopping rule implementation │   ├── posterior_helpers.R      # Bayesian posterior computations │   └── data_generation.R        # Time-to-event data generation ├── src/ │   └── *.cpp                    # C++ acceleration code └── vignettes/     └── design-overview.Rmd      # Detailed methodology"},{"path":"/index.html","id":"related-packages","dir":"","previous_headings":"","what":"Related Packages","title":"Adaptive Clinical Trial Utilities","text":"evolveBO: Bayesian optimization calibrating evolveTrial designs adaptive-trial-bo-paper: Research manuscript case studies","code":""},{"path":"/reference/adopt_calibration.html","id":null,"dir":"Reference","previous_headings":"","what":"Adopt a calibrated design configuration — adopt_calibration","title":"Adopt a calibrated design configuration — adopt_calibration","text":"Picks selected row grid_calibrate() returns updated arguments plus two-scenario list (null vs alternative) subsequent exploration.","code":""},{"path":"/reference/adopt_calibration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adopt a calibrated design configuration — adopt_calibration","text":"","code":"adopt_calibration(cal, base_args, null_med, alt_med, which = 1L)"},{"path":"/reference/adopt_calibration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adopt a calibrated design configuration — adopt_calibration","text":"cal Output grid_calibrate(). base_args Baseline argument list. null_med Control-arm median null. alt_med Experimental median alternative. Integer index specifying row cal$top adopt.","code":""},{"path":"/reference/adopt_calibration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adopt a calibrated design configuration — adopt_calibration","text":"list containing updated arguments (args_star), selected row (pick), two-scenario list (scens2).","code":""},{"path":"/reference/apply_recommended_to_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a recommended early-stopping configuration to the argument list — apply_recommended_to_args","title":"Apply a recommended early-stopping configuration to the argument list — apply_recommended_to_args","text":"Apply recommended early-stopping configuration argument list","code":""},{"path":"/reference/apply_recommended_to_args.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a recommended early-stopping configuration to the argument list — apply_recommended_to_args","text":"","code":"apply_recommended_to_args(args_star, rec_row)"},{"path":"/reference/apply_recommended_to_args.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a recommended early-stopping configuration to the argument list — apply_recommended_to_args","text":"args_star Baseline argument list (typically adopt_calibration()). rec_row Single-row data.table produced recommend_design_from_early().","code":""},{"path":"/reference/apply_recommended_to_args.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a recommended early-stopping configuration to the argument list — apply_recommended_to_args","text":"Modified argument list recommended early-stopping settings.","code":""},{"path":"/reference/binary_interim_decision.html","id":null,"dir":"Reference","previous_headings":"","what":"Binary interim decision check — binary_interim_decision","title":"Binary interim decision check — binary_interim_decision","text":"Evaluates whether stop efficacy futility interim look binary endpoint trial.","code":""},{"path":"/reference/binary_interim_decision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Binary interim decision check — binary_interim_decision","text":"","code":"binary_interim_decision(n_responses, n_total, args, diagnostics = FALSE)"},{"path":"/reference/binary_interim_decision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Binary interim decision check — binary_interim_decision","text":"n_responses Number responders n_total Total enrolled args Trial arguments containing thresholds diagnostics Print diagnostic messages","code":""},{"path":"/reference/binary_interim_decision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Binary interim decision check — binary_interim_decision","text":"List decision (\"continue\", \"stop_efficacy\", \"stop_futility\") probabilities","code":""},{"path":"/reference/calculate_binary_probs.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate binary endpoint interim probabilities — calculate_binary_probs","title":"Calculate binary endpoint interim probabilities — calculate_binary_probs","text":"Computes posterior probabilities efficacy futility decisions binary endpoint trials.","code":""},{"path":"/reference/calculate_binary_probs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate binary endpoint interim probabilities — calculate_binary_probs","text":"","code":"calculate_binary_probs(   n_responses,   n_total,   p0,   p1,   alpha_prior = 1,   beta_prior = 1 )"},{"path":"/reference/calculate_binary_probs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate binary endpoint interim probabilities — calculate_binary_probs","text":"n_responses Number responders observed n_total Total patients enrolled p0 Null hypothesis response rate (futility) p1 Alternative hypothesis response rate (efficacy target) alpha_prior Beta prior shape1 (default 1) beta_prior Beta prior shape2 (default 1)","code":""},{"path":"/reference/calculate_binary_probs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate binary endpoint interim probabilities — calculate_binary_probs","text":"List pr_eff (P(p > p0)) pr_fut (P(p < p1))","code":""},{"path":"/reference/calculate_interval_metrics_fast.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate interval-specific metrics from patient data — calculate_interval_metrics_fast","title":"Calculate interval-specific metrics from patient data — calculate_interval_metrics_fast","text":"Recalculates events person-time using lightweight base-R operations.","code":""},{"path":"/reference/calculate_interval_metrics_fast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate interval-specific metrics from patient data — calculate_interval_metrics_fast","text":"","code":"calculate_interval_metrics_fast(patient_data, interval_cutpoints)"},{"path":"/reference/calculate_interval_metrics_fast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate interval-specific metrics from patient data — calculate_interval_metrics_fast","text":"patient_data Data frame columns observed_time event_status. interval_cutpoints Numeric vector interval boundaries.","code":""},{"path":"/reference/calculate_interval_metrics_fast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate interval-specific metrics from patient data — calculate_interval_metrics_fast","text":"list events_per_interval person_time_per_interval vectors.","code":""},{"path":"/reference/calculate_median_survival_matrix_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate median survival for multiple hazard samples (C++ implementation) — calculate_median_survival_matrix_cpp","title":"Calculate median survival for multiple hazard samples (C++ implementation) — calculate_median_survival_matrix_cpp","text":"Vectorized version processes entire matrix posterior hazard samples. row posterior sample; column interval.","code":""},{"path":"/reference/calculate_median_survival_matrix_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate median survival for multiple hazard samples (C++ implementation) — calculate_median_survival_matrix_cpp","text":"","code":"calculate_median_survival_matrix_cpp(hazard_samples, interval_lengths)"},{"path":"/reference/calculate_median_survival_matrix_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate median survival for multiple hazard samples (C++ implementation) — calculate_median_survival_matrix_cpp","text":"hazard_samples Matrix num_samples rows num_intervals columns interval_lengths Numeric vector interval lengths (durations)","code":""},{"path":"/reference/calculate_median_survival_matrix_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate median survival for multiple hazard samples (C++ implementation) — calculate_median_survival_matrix_cpp","text":"Numeric vector median survival times (length num_samples)","code":""},{"path":"/reference/calculate_median_survival_piecewise.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate median survival for piecewise exponential model — calculate_median_survival_piecewise","title":"Calculate median survival for piecewise exponential model — calculate_median_survival_piecewise","text":"Computes median survival time piecewise exponential model. 0.5 survival reached end last interval, continue past last cutpoint last interval's hazard (open-ended tail). return Inf last hazard exactly zero.","code":""},{"path":"/reference/calculate_median_survival_piecewise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate median survival for piecewise exponential model — calculate_median_survival_piecewise","text":"","code":"calculate_median_survival_piecewise(hazard_rates, interval_lengths)"},{"path":"/reference/calculate_median_survival_piecewise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate median survival for piecewise exponential model — calculate_median_survival_piecewise","text":"hazard_rates Numeric vector hazard rates interval. interval_lengths Numeric vector interval lengths (durations).","code":""},{"path":"/reference/calculate_median_survival_piecewise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate median survival for piecewise exponential model — calculate_median_survival_piecewise","text":"Median survival time (numeric scalar, possibly Inf).","code":""},{"path":"/reference/calculate_median_survival_piecewise_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate median survival for piecewise exponential model (C++ implementation) — calculate_median_survival_piecewise_cpp","title":"Calculate median survival for piecewise exponential model (C++ implementation) — calculate_median_survival_piecewise_cpp","text":"Computes median survival time piecewise exponential model. 0.5 survival reached end last interval, continues past last cutpoint last interval's hazard (open-ended tail). returns Inf last hazard exactly zero.","code":""},{"path":"/reference/calculate_median_survival_piecewise_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate median survival for piecewise exponential model (C++ implementation) — calculate_median_survival_piecewise_cpp","text":"","code":"calculate_median_survival_piecewise_cpp(hazard_rates, interval_lengths)"},{"path":"/reference/calculate_median_survival_piecewise_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate median survival for piecewise exponential model (C++ implementation) — calculate_median_survival_piecewise_cpp","text":"hazard_rates Numeric vector hazard rates interval interval_lengths Numeric vector interval lengths (durations)","code":""},{"path":"/reference/calculate_median_survival_piecewise_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate median survival for piecewise exponential model (C++ implementation) — calculate_median_survival_piecewise_cpp","text":"Median survival time (numeric scalar, possibly Inf)","code":""},{"path":"/reference/calibrate_alpha.html","id":null,"dir":"Reference","previous_headings":"","what":"Calibrate interim and final thresholds for single-arm designs — calibrate_alpha","title":"Calibrate interim and final thresholds for single-arm designs — calibrate_alpha","text":"Sweeps candidate interim final posterior probability thresholds returns best combination achieving desired type error null scenario(s).","code":""},{"path":"/reference/calibrate_alpha.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calibrate interim and final thresholds for single-arm designs — calibrate_alpha","text":"","code":"calibrate_alpha(   base_args,   scens_null,   thr_grid_interim = c(0.9, 0.95, 0.975),   thr_grid_final = c(0.95, 0.975, 0.99),   sims = 300 )"},{"path":"/reference/calibrate_alpha.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calibrate interim and final thresholds for single-arm designs — calibrate_alpha","text":"base_args Baseline argument list passed run_scenarios(). scens_null Scenario list representing null hypotheses. thr_grid_interim Numeric vector interim success thresholds try. thr_grid_final Numeric vector final success thresholds try. sims Number simulations per candidate setting.","code":""},{"path":"/reference/calibrate_alpha.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calibrate interim and final thresholds for single-arm designs — calibrate_alpha","text":"list containing chosen thresholds corresponding estimated type error.","code":""},{"path":"/reference/compare_simon_to_bo.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate BO calibration against Simon enumeration — compare_simon_to_bo","title":"Validate BO calibration against Simon enumeration — compare_simon_to_bo","text":"Runs BO calibration binary simulator compares exact Simon design.","code":""},{"path":"/reference/compare_simon_to_bo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate BO calibration against Simon enumeration — compare_simon_to_bo","text":"","code":"compare_simon_to_bo(   p0,   p1,   alpha = 0.1,   beta = 0.2,   n_max_search = 100,   bo_fit = NULL,   num_sims = 10000 )"},{"path":"/reference/compare_simon_to_bo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate BO calibration against Simon enumeration — compare_simon_to_bo","text":"p0 Null response rate p1 Alternative response rate alpha Type error constraint beta Type II error constraint (1 - power) n_max_search Maximum N Simon search bo_fit Optional: pre-computed BO fit object num_sims Number simulations Monte Carlo validation","code":""},{"path":"/reference/compare_simon_to_bo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate BO calibration against Simon enumeration — compare_simon_to_bo","text":"Data frame comparing Simon (exact) vs BO (calibrated) designs","code":""},{"path":"/reference/create_simulation_cluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a reusable evolveTrial simulation cluster — create_simulation_cluster","title":"Create a reusable evolveTrial simulation cluster — create_simulation_cluster","text":"Creates parallel cluster optimized evolveTrial simulations. cluster can reused across multiple calls run_simulation_pure() passing via cluster parameter, avoiding overhead repeated cluster creation/destruction.","code":""},{"path":"/reference/create_simulation_cluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a reusable evolveTrial simulation cluster — create_simulation_cluster","text":"","code":"create_simulation_cluster(   workers = NULL,   cluster_type = c(\"auto\", \"FORK\", \"PSOCK\") )"},{"path":"/reference/create_simulation_cluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a reusable evolveTrial simulation cluster — create_simulation_cluster","text":"workers Integer; number worker processes. Defaults parallel::detectCores() - 1. cluster_type One \"auto\" (default), \"FORK\", \"PSOCK\". Auto selects FORK Unix systems (faster) PSOCK Windows.","code":""},{"path":"/reference/create_simulation_cluster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a reusable evolveTrial simulation cluster — create_simulation_cluster","text":"parallel cluster object can passed run_simulation_pure() via cluster parameter.","code":""},{"path":"/reference/create_simulation_cluster.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a reusable evolveTrial simulation cluster — create_simulation_cluster","text":"function particularly useful Bayesian optimization workflows run_simulation_pure() called hundreds times. creating cluster reusing , can eliminate 5-10 second cluster spawn/teardown overhead per call. FORK clusters (default Unix) significantly faster : Worker processes inherit parent environment (package loading) Data shared via copy--write (serialization overhead) Remember call release_cluster() done free resources.","code":""},{"path":[]},{"path":"/reference/create_simulation_cluster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a reusable evolveTrial simulation cluster — create_simulation_cluster","text":"","code":"if (FALSE) { # \\dontrun{ # Create cluster once cl <- create_simulation_cluster(workers = 8)  # Use in repeated BO evaluations for (i in 1:100) {   result <- run_simulation_pure(     num_simulations = 500,     ...,     parallel_replicates = TRUE,     cluster = cl   ) }  # Clean up release_cluster(cl) } # }"},{"path":"/reference/dot-use_cpp_posterior.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if C++ posterior sampling should be used — .use_cpp_posterior","title":"Check if C++ posterior sampling should be used — .use_cpp_posterior","text":"Checks environment variable EVOLVETRIAL_USE_CPP determine whether use C++ implementation (default: TRUE)","code":""},{"path":"/reference/dot-use_cpp_posterior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if C++ posterior sampling should be used — .use_cpp_posterior","text":"","code":".use_cpp_posterior()"},{"path":"/reference/dot-use_cpp_posterior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if C++ posterior sampling should be used — .use_cpp_posterior","text":"Logical indicating whether use C++ version","code":""},{"path":"/reference/draw_posterior_hazard_samples.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw posterior hazard samples (DISPATCHER) — draw_posterior_hazard_samples","title":"Draw posterior hazard samples (DISPATCHER) — draw_posterior_hazard_samples","text":"Routes C++ R implementation based EVOLVETRIAL_USE_CPP. Default: C++ better performance. Draws samples posterior distribution hazard rates interval Bayesian piecewise exponential model Gamma priors.","code":""},{"path":"/reference/draw_posterior_hazard_samples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw posterior hazard samples (DISPATCHER) — draw_posterior_hazard_samples","text":"","code":"draw_posterior_hazard_samples(   num_intervals,   events_per_interval,   person_time_per_interval,   prior_alpha_params,   prior_beta_params,   num_samples = 1000 )  draw_posterior_hazard_samples(   num_intervals,   events_per_interval,   person_time_per_interval,   prior_alpha_params,   prior_beta_params,   num_samples = 1000 )"},{"path":"/reference/draw_posterior_hazard_samples.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw posterior hazard samples (DISPATCHER) — draw_posterior_hazard_samples","text":"num_intervals Number intervals piecewise model. events_per_interval Integer vector observed events per interval. person_time_per_interval Numeric vector person-time risk per interval. prior_alpha_params Numeric vector Gamma prior shape parameters. prior_beta_params Numeric vector Gamma prior rate parameters. num_samples Number posterior samples draw (default 1000).","code":""},{"path":"/reference/draw_posterior_hazard_samples.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw posterior hazard samples (DISPATCHER) — draw_posterior_hazard_samples","text":"Matrix posterior hazard samples Matrix num_samples rows num_intervals columns hazard samples.","code":""},{"path":"/reference/draw_posterior_hazard_samples_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw posterior hazard samples (C++ implementation) — draw_posterior_hazard_samples_cpp","title":"Draw posterior hazard samples (C++ implementation) — draw_posterior_hazard_samples_cpp","text":"Draws samples posterior distribution hazard rates interval Bayesian piecewise exponential model Gamma priors.","code":""},{"path":"/reference/draw_posterior_hazard_samples_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw posterior hazard samples (C++ implementation) — draw_posterior_hazard_samples_cpp","text":"","code":"draw_posterior_hazard_samples_cpp(   num_intervals,   events_per_interval,   person_time_per_interval,   prior_alpha_params,   prior_beta_params,   num_samples )"},{"path":"/reference/draw_posterior_hazard_samples_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw posterior hazard samples (C++ implementation) — draw_posterior_hazard_samples_cpp","text":"num_intervals Number intervals piecewise model events_per_interval Integer vector observed events per interval person_time_per_interval Numeric vector person-time risk per interval prior_alpha_params Numeric vector Gamma prior shape parameters prior_beta_params Numeric vector Gamma prior rate parameters num_samples Number posterior samples draw","code":""},{"path":"/reference/draw_posterior_hazard_samples_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw posterior hazard samples (C++ implementation) — draw_posterior_hazard_samples_cpp","text":"Matrix num_samples rows num_intervals columns hazard samples","code":""},{"path":"/reference/draw_posterior_hazard_samples_r.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw posterior hazard samples (ORIGINAL R VERSION) — draw_posterior_hazard_samples_r","title":"Draw posterior hazard samples (ORIGINAL R VERSION) — draw_posterior_hazard_samples_r","text":"Draw posterior hazard samples (ORIGINAL R VERSION)","code":""},{"path":"/reference/draw_posterior_hazard_samples_r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw posterior hazard samples (ORIGINAL R VERSION) — draw_posterior_hazard_samples_r","text":"","code":"draw_posterior_hazard_samples_r(   num_intervals,   events_per_interval,   person_time_per_interval,   prior_alpha_params,   prior_beta_params,   num_samples = 1000 )"},{"path":"/reference/draw_posterior_response_rate.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw posterior samples for binary response rate — draw_posterior_response_rate","title":"Draw posterior samples for binary response rate — draw_posterior_response_rate","text":"Uses Beta-Binomial conjugacy sample posterior distribution response rate.","code":""},{"path":"/reference/draw_posterior_response_rate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw posterior samples for binary response rate — draw_posterior_response_rate","text":"","code":"draw_posterior_response_rate(   n_responses,   n_total,   alpha_prior = 1,   beta_prior = 1,   num_samples = 1000 )"},{"path":"/reference/draw_posterior_response_rate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw posterior samples for binary response rate — draw_posterior_response_rate","text":"n_responses Number responders n_total Total number patients alpha_prior Beta prior shape1 parameter (default 1 uniform) beta_prior Beta prior shape2 parameter (default 1 uniform) num_samples Number posterior samples draw","code":""},{"path":"/reference/draw_posterior_response_rate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw posterior samples for binary response rate — draw_posterior_response_rate","text":"Numeric vector posterior samples response rate","code":""},{"path":"/reference/draw_posterior_response_rate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Draw posterior samples for binary response rate — draw_posterior_response_rate","text":"Prior: Beta(alpha_prior, beta_prior) Likelihood: Binomial(n, p) Posterior: Beta(alpha_prior + successes, beta_prior + failures)","code":""},{"path":"/reference/estimate_vsref_gate_timing.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate when the vs-reference interim gates can be satisfied — estimate_vsref_gate_timing","title":"Estimate when the vs-reference interim gates can be satisfied — estimate_vsref_gate_timing","text":"Provides lower-bound heuristics -arm (vs-reference) interim gating criteria can satisfied deterministic accrual.","code":""},{"path":"/reference/estimate_vsref_gate_timing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate when the vs-reference interim gates can be satisfied — estimate_vsref_gate_timing","text":"","code":"estimate_vsref_gate_timing(args)"},{"path":"/reference/estimate_vsref_gate_timing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate when the vs-reference interim gates can be satisfied — estimate_vsref_gate_timing","text":"args named list following structure passed run_simulation_pure() / run_scenarios(). function uses entries relevant vs-reference gating, namely arm_names, reference_arm_name, overall_accrual_rate, randomization_probs, max_total_patients_per_arm, max_follow_up_sim, min_events_per_arm, min_median_followup_per_arm, min_person_time_frac_per_arm.","code":""},{"path":"/reference/estimate_vsref_gate_timing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate when the vs-reference interim gates can be satisfied — estimate_vsref_gate_timing","text":"list two components: per_arm: data frame containing per-arm accrual rate         heuristic lower-bound times (months) gating         component. joint_lower_bound: maximum per-arm lower bounds,         representing earliest calendar time gates         plausibly satisfied simultaneously heuristics.","code":""},{"path":"/reference/estimate_vsref_gate_timing.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate when the vs-reference interim gates can be satisfied — estimate_vsref_gate_timing","text":"calculations assume constant accrual rate overall_accrual_rate split according randomization_probs. Person-time requirements approximated using relationship PT \\(\\approx\\) rate \\(\\times\\) time\\(^2\\) / 2 steady accrual, median follow-requirement approximated using rule--thumb median follow-exceed roughly half calendar time uniform accrual.","code":""},{"path":"/reference/estimate_vsref_gate_timing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate when the vs-reference interim gates can be satisfied — estimate_vsref_gate_timing","text":"","code":"args <- list(   arm_names = c(\"Doublet\", \"Triplet\"),   reference_arm_name = \"Doublet\",   overall_accrual_rate = 3,   randomization_probs = c(Doublet = 0.5, Triplet = 0.5),   max_total_patients_per_arm = c(Doublet = 70, Triplet = 70),   max_follow_up_sim = 24,   min_events_per_arm = 8,   min_median_followup_per_arm = 3,   min_person_time_frac_per_arm = 0.15 ) estimate_vsref_gate_timing(args) #> $per_arm #>             Arm AccrualRate MinEvents TimeForEvents MinMedianFollowup #> Doublet Doublet         1.5         8      5.333333                 3 #> Triplet Triplet         1.5         8      5.333333                 3 #>         TimeForMedianFollowup MinPersonTimeMonths TimeForPersonTime #> Doublet                     6                 252           18.3303 #> Triplet                     6                 252           18.3303 #>  #> $joint_lower_bound #> [1] 18.3303 #>"},{"path":"/reference/evaluate_ph_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate PH-based grid of designs — evaluate_ph_grid","title":"Evaluate PH-based grid of designs — evaluate_ph_grid","text":"Helper sweeps probability thresholds, gate settings, HR margins, returning operating characteristics plus expected sample sizes per arm.","code":""},{"path":"/reference/evaluate_ph_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate PH-based grid of designs — evaluate_ph_grid","text":"","code":"evaluate_ph_grid(   base_args,   grid,   scens,   sims = 2000,   seed = 4242,   parallel = TRUE )"},{"path":"/reference/evaluate_ph_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate PH-based grid of designs — evaluate_ph_grid","text":"base_args Baseline argument list passed run_scenarios(). grid data.table/data.frame describing design grid.  Must include columns label, thr_eff, thr_fut, margin, min_ev, min_pt, optionally hr_margin. scens Scenario list (e.g., scenarios_from_grid()). sims Number simulations per grid row. seed RNG seed. parallel Logical; use parallel execution.","code":""},{"path":"/reference/evaluate_ph_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate PH-based grid of designs — evaluate_ph_grid","text":"data.table summarising Type error, power, PETs, expected N per arm, control-arm expectations, total expected N null/alt. Evaluate proportional-hazards vs-reference designs grid Runs supplied grid thresholds/margins scenario list, collecting operating characteristics design. data.table summarising alpha, power, PETs, expected sample sizes labelled design.","code":""},{"path":"/reference/evolveTrial-package.html","id":null,"dir":"Reference","previous_headings":"","what":"evolveTrial: Adaptive Clinical Trial Utilities — evolveTrial-package","title":"evolveTrial: Adaptive Clinical Trial Utilities — evolveTrial-package","text":"Helpers Bayesian adaptive platform/umbrella clinical trials, including simulation, decision rules, reporting.","code":""},{"path":"/reference/evolveTrial-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"evolveTrial: Adaptive Clinical Trial Utilities — evolveTrial-package","text":"Maintainer: Naim Rashid naim@unc.edu","code":""},{"path":"/reference/exp_arms_from_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract experimental arm names from an argument list — exp_arms_from_args","title":"Extract experimental arm names from an argument list — exp_arms_from_args","text":"Extract experimental arm names argument list","code":""},{"path":"/reference/exp_arms_from_args.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract experimental arm names from an argument list — exp_arms_from_args","text":"","code":"exp_arms_from_args(args)"},{"path":"/reference/exp_arms_from_args.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract experimental arm names from an argument list — exp_arms_from_args","text":"args Argument list containing arm_names reference_arm_name.","code":""},{"path":"/reference/exp_arms_from_args.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract experimental arm names from an argument list — exp_arms_from_args","text":"Character vector experimental arm names.","code":""},{"path":"/reference/explore_early_stopping_from_cal.html","id":null,"dir":"Reference","previous_headings":"","what":"Explore early stopping knobs around a calibrated design — explore_early_stopping_from_cal","title":"Explore early stopping knobs around a calibrated design — explore_early_stopping_from_cal","text":"Sweeps futility thresholds, information gates, interim schedules around calibrated design characterise trade-offs alpha, power, PETs.","code":""},{"path":"/reference/explore_early_stopping_from_cal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Explore early stopping knobs around a calibrated design — explore_early_stopping_from_cal","text":"","code":"explore_early_stopping_from_cal(   cal,   base_args,   null_med,   alt_med,   base = c(\"null+delta\", \"alt\"),   futility_delta_grid = c(0, 1, 2, 3),   fut_thr_grid = c(0.6, 0.7, 0.8, 0.9),   min_events_grid = c(12, 18),   min_medFU_grid = c(3, 4.5),   schedule_modes = c(\"calendar\", \"persontime\"),   beat_grid = c(3, 6),   pt_milestones_choices = list(c(0.3, 0.45, 0.6, 0.8, 1)),   latest_calendar_look_grid = c(Inf),   min_events_per_arm_grid = c(8, 12),   min_median_followup_per_arm_grid = c(0, 4.5),   min_person_time_frac_per_arm_grid = c(0, 0.25),   sims = 400,   seed = 123,   parallel = (.Platform$OS.type == \"unix\") )"},{"path":"/reference/explore_early_stopping_from_cal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Explore early stopping knobs around a calibrated design — explore_early_stopping_from_cal","text":"cal Calibration output grid_calibrate() similar. base_args Baseline argument list. null_med Control-arm median null. alt_med Experimental median alternative. base Futility baseline mode: \"null+delta\" \"alt\". futility_delta_grid Numeric vector deltas added null medians. fut_thr_grid Numeric vector futility probability thresholds. min_events_grid Global minimum event counts consider. min_medFU_grid Global minimum median follow-values. schedule_modes Character vector: \"calendar\", \"persontime\", . beat_grid Calendar beat schedules evaluate (months). pt_milestones_choices List person-time milestone vectors. latest_calendar_look_grid Backstop calendar times person-time schedules. min_events_per_arm_grid Per-arm minimum events gating. min_median_followup_per_arm_grid Per-arm minimum median follow-. min_person_time_frac_per_arm_grid Per-arm minimum person-time fractions. sims Number simulations per configuration. seed RNG seed. parallel Logical; use parallel processing.","code":""},{"path":"/reference/explore_early_stopping_from_cal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Explore early stopping knobs around a calibrated design — explore_early_stopping_from_cal","text":"data.table operating characteristics configuration.","code":""},{"path":"/reference/export_scenario_table_to_excel.html","id":null,"dir":"Reference","previous_headings":"","what":"Export a scenario summary table to Excel — export_scenario_table_to_excel","title":"Export a scenario summary table to Excel — export_scenario_table_to_excel","text":"Export scenario summary table Excel","code":""},{"path":"/reference/export_scenario_table_to_excel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Export a scenario summary table to Excel — export_scenario_table_to_excel","text":"","code":"export_scenario_table_to_excel(pretty_tbl, file_path = \"scenario_summary.xlsx\")"},{"path":"/reference/export_scenario_table_to_excel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Export a scenario summary table to Excel — export_scenario_table_to_excel","text":"pretty_tbl Data frame produced pretty_scenario_matrix(). file_path Output path Excel workbook.","code":""},{"path":"/reference/export_scenario_table_to_excel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Export a scenario summary table to Excel — export_scenario_table_to_excel","text":"Invisibly returns file_path.  Writes .xlsx file disk.","code":""},{"path":"/reference/export_scenario_table_to_png.html","id":null,"dir":"Reference","previous_headings":"","what":"Render the scenario summary table to a PNG image — export_scenario_table_to_png","title":"Render the scenario summary table to a PNG image — export_scenario_table_to_png","text":"Render scenario summary table PNG image","code":""},{"path":"/reference/export_scenario_table_to_png.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Render the scenario summary table to a PNG image — export_scenario_table_to_png","text":"","code":"export_scenario_table_to_png(   results_df,   file_path = \"scenario_summary.png\",   title = \"Bayesian Adaptive Design Summary\",   subtitle = NULL,   highlight_arm = \"Triplet\",   snapshot_engine = c(\"auto\", \"webshot2\", \"webshot\"),   vwidth = 1400,   vheight = 600,   zoom = 1 )"},{"path":"/reference/export_scenario_table_to_png.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Render the scenario summary table to a PNG image — export_scenario_table_to_png","text":"results_df Data frame returned run_scenarios(). file_path Output path PNG image. title Main title table. subtitle Optional subtitle. highlight_arm Arm name whose columns highlighted. snapshot_engine Rendering backend; one \"auto\", \"webshot2\", \"webshot\". vwidth Viewport width passed renderer. vheight Viewport height passed renderer. zoom Zoom factor passed renderer.","code":""},{"path":"/reference/export_scenario_table_to_png.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Render the scenario summary table to a PNG image — export_scenario_table_to_png","text":"Invisibly returns file_path.  Writes PNG (temporary HTML snapshot_engine = \"webshot\").","code":""},{"path":"/reference/filter_early_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter early-stopping designs by operating targets — filter_early_grid","title":"Filter early-stopping designs by operating targets — filter_early_grid","text":"Filter early-stopping designs operating targets","code":""},{"path":"/reference/filter_early_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter early-stopping designs by operating targets — filter_early_grid","text":"","code":"filter_early_grid(early_df, alpha_cap = 0.1, power_floor = 0.7)"},{"path":"/reference/filter_early_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter early-stopping designs by operating targets — filter_early_grid","text":"early_df data.table/data.frame produced explore_early_stopping_from_cal(). alpha_cap Maximum acceptable type error. power_floor Minimum acceptable power.","code":""},{"path":"/reference/filter_early_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter early-stopping designs by operating targets — filter_early_grid","text":"data.table containing subset meets supplied criteria.","code":""},{"path":"/reference/find_simon_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Find optimal Simon design — find_simon_design","title":"Find optimal Simon design — find_simon_design","text":"Searches Simon optimal minimax design meeting constraints. Uses optimized search early termination.","code":""},{"path":"/reference/find_simon_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find optimal Simon design — find_simon_design","text":"","code":"find_simon_design(   p0,   p1,   alpha = 0.1,   beta = 0.2,   n_max = 100,   criterion = c(\"optimal\", \"minimax\") )"},{"path":"/reference/find_simon_design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find optimal Simon design — find_simon_design","text":"p0 Null response rate p1 Alternative response rate alpha Maximum type error beta Maximum type II error (1 - power) n_max Maximum total sample size search criterion \"optimal\" (minimize EN null) \"minimax\" (minimize max N)","code":""},{"path":"/reference/find_simon_design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find optimal Simon design — find_simon_design","text":"Data frame design parameters operating characteristics","code":""},{"path":"/reference/get_binary_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Get binary trial metrics from registry — get_binary_metrics","title":"Get binary trial metrics from registry — get_binary_metrics","text":"Get binary trial metrics registry","code":""},{"path":"/reference/get_binary_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get binary trial metrics from registry — get_binary_metrics","text":"","code":"get_binary_metrics(registry_df, stage = NULL)"},{"path":"/reference/get_binary_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get binary trial metrics from registry — get_binary_metrics","text":"registry_df Binary registry data frame stage Optional: filter specific stage (1, 2, NULL )","code":""},{"path":"/reference/get_binary_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get binary trial metrics from registry — get_binary_metrics","text":"List n_enrolled, n_responses","code":""},{"path":"/reference/grid_calibrate.html","id":null,"dir":"Reference","previous_headings":"","what":"Calibrate historical-control thresholds over a grid — grid_calibrate","title":"Calibrate historical-control thresholds over a grid — grid_calibrate","text":"Evaluates grid interim/final thresholds superiority margins null alternative scenarios, returning full operating characteristics combination.","code":""},{"path":"/reference/grid_calibrate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calibrate historical-control thresholds over a grid — grid_calibrate","text":"","code":"grid_calibrate(   base_args,   null_med = 6,   alt_med = 9,   margins_abs = c(1, 2, 3),   interim_thr_grid = c(0.9, 0.95),   final_thr_grid = c(0.95, 0.975, 0.99),   sims = 400,   target_alpha = 0.1,   seed = 123,   parallel = TRUE )"},{"path":"/reference/grid_calibrate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calibrate historical-control thresholds over a grid — grid_calibrate","text":"base_args Baseline argument list passed run_scenarios(). null_med Control-arm median null hypothesis. alt_med Experimental median alternative. margins_abs Numeric vector absolute superiority margins (months). interim_thr_grid Interim success probabilities evaluate. final_thr_grid Final posterior success probabilities evaluate. sims Number simulations per grid point. target_alpha Target type error used ranking feasible designs. seed RNG seed. parallel Logical; run scenarios parallel.","code":""},{"path":"/reference/grid_calibrate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calibrate historical-control thresholds over a grid — grid_calibrate","text":"list components , feasible, top summarising grid results.","code":""},{"path":"/reference/make_state_binary.html","id":null,"dir":"Reference","previous_headings":"","what":"Create state container for binary endpoint trial — make_state_binary","title":"Create state container for binary endpoint trial — make_state_binary","text":"Create state container binary endpoint trial","code":""},{"path":"/reference/make_state_binary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create state container for binary endpoint trial — make_state_binary","text":"","code":"make_state_binary(arm_names, max_total_patients_per_arm)"},{"path":"/reference/make_state_binary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create state container for binary endpoint trial — make_state_binary","text":"arm_names Character vector arm names max_total_patients_per_arm Named integer vector max N per arm","code":""},{"path":"/reference/make_state_binary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create state container for binary endpoint trial — make_state_binary","text":"State list binary trial simulation","code":""},{"path":"/reference/ph_beta_mode_var.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute mode and variance of log-HR posterior for PH model (DISPATCHER) — ph_beta_mode_var","title":"Compute mode and variance of log-HR posterior for PH model (DISPATCHER) — ph_beta_mode_var","text":"Compute mode variance log-HR posterior PH model (DISPATCHER)","code":""},{"path":"/reference/ph_beta_mode_var.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute mode and variance of log-HR posterior for PH model (DISPATCHER) — ph_beta_mode_var","text":"","code":"ph_beta_mode_var(   E_C,   PT_C,   E_T,   PT_T,   alpha_prior,   beta_prior,   mu,   sigma,   tol = 1e-06,   max_iter = 50 )"},{"path":"/reference/ph_beta_mode_var_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute mode and variance of log-HR posterior for PH model (C++ implementation) — ph_beta_mode_var_cpp","title":"Compute mode and variance of log-HR posterior for PH model (C++ implementation) — ph_beta_mode_var_cpp","text":"Uses Newton-Raphson iteration find mode log-HR posterior proportional hazards model Gamma prior baseline hazards normal prior log-HR.","code":""},{"path":"/reference/ph_beta_mode_var_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute mode and variance of log-HR posterior for PH model (C++ implementation) — ph_beta_mode_var_cpp","text":"","code":"ph_beta_mode_var_cpp(   E_C,   PT_C,   E_T,   PT_T,   alpha_prior,   beta_prior,   mu,   sigma,   tol = 1e-06,   max_iter = 50L )"},{"path":"/reference/ph_beta_mode_var_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute mode and variance of log-HR posterior for PH model (C++ implementation) — ph_beta_mode_var_cpp","text":"E_C Integer vector control events per interval PT_C Numeric vector control person-time per interval E_T Integer vector treatment events per interval PT_T Numeric vector treatment person-time per interval alpha_prior Numeric vector Gamma prior shape parameters beta_prior Numeric vector Gamma prior rate parameters mu Log-HR prior mean sigma Log-HR prior SD tol Convergence tolerance (default 1e-6) max_iter Maximum Newton-Raphson iterations (default 50)","code":""},{"path":"/reference/ph_beta_mode_var_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute mode and variance of log-HR posterior for PH model (C++ implementation) — ph_beta_mode_var_cpp","text":"List \"mean\" \"sd\" log-HR posterior","code":""},{"path":"/reference/ph_beta_mode_var_r.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute mode and variance of log-HR posterior (ORIGINAL R VERSION) — ph_beta_mode_var_r","title":"Compute mode and variance of log-HR posterior (ORIGINAL R VERSION) — ph_beta_mode_var_r","text":"Compute mode variance log-HR posterior (ORIGINAL R VERSION)","code":""},{"path":"/reference/ph_beta_mode_var_r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute mode and variance of log-HR posterior (ORIGINAL R VERSION) — ph_beta_mode_var_r","text":"","code":"ph_beta_mode_var_r(   E_C,   PT_C,   E_T,   PT_T,   alpha_prior,   beta_prior,   mu,   sigma,   tol = 1e-06,   max_iter = 50 )"},{"path":"/reference/plot_calibration.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot power versus type I error for calibration grids — plot_calibration","title":"Plot power versus type I error for calibration grids — plot_calibration","text":"Visualises output grid_calibrate() plotting power type error, optionally highlighting Pareto frontiers feasible designs.","code":""},{"path":"/reference/plot_calibration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot power versus type I error for calibration grids — plot_calibration","text":"","code":"plot_calibration(cal, target_alpha = 0.1, label_top_n = 3)"},{"path":"/reference/plot_calibration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot power versus type I error for calibration grids — plot_calibration","text":"cal List returned grid_calibrate(). target_alpha Type error threshold display. label_top_n Number feasible designs annotate.","code":""},{"path":"/reference/plot_calibration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot power versus type I error for calibration grids — plot_calibration","text":"ggplot object.","code":""},{"path":"/reference/plot_early_tradeoff.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot early-stopping trade-offs — plot_early_tradeoff","title":"Plot early-stopping trade-offs — plot_early_tradeoff","text":"Visualises power versus type error early-stopping exploration grid.","code":""},{"path":"/reference/plot_early_tradeoff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot early-stopping trade-offs — plot_early_tradeoff","text":"","code":"plot_early_tradeoff(   early_df,   target_alpha = 0.1,   fix_min_ev = NULL,   fix_mfu = NULL,   fix_beat = NULL )"},{"path":"/reference/plot_early_tradeoff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot early-stopping trade-offs — plot_early_tradeoff","text":"early_df data.table/data.frame returned explore_early_stopping_from_cal(). target_alpha Type error target show reference line. fix_min_ev Optional scalar filter min_events. fix_mfu Optional scalar filter min_medFU. fix_beat Optional scalar filter calendar beats.","code":""},{"path":"/reference/plot_early_tradeoff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot early-stopping trade-offs — plot_early_tradeoff","text":"ggplot object (filtered data ggplot2 unavailable).","code":""},{"path":"/reference/precompute_ctrl_posteriors.html","id":null,"dir":"Reference","previous_headings":"","what":"Pre-compute control arm posteriors for caching in multi-arm comparisons — precompute_ctrl_posteriors","title":"Pre-compute control arm posteriors for caching in multi-arm comparisons — precompute_ctrl_posteriors","text":"PERFORMANCE: comparing multiple experimental arms control, function computes control posteriors avoid redundant computation.","code":""},{"path":"/reference/precompute_ctrl_posteriors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pre-compute control arm posteriors for caching in multi-arm comparisons — precompute_ctrl_posteriors","text":"","code":"precompute_ctrl_posteriors(slCtrl, args, num_samples)"},{"path":"/reference/precompute_ctrl_posteriors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pre-compute control arm posteriors for caching in multi-arm comparisons — precompute_ctrl_posteriors","text":"slCtrl Control arm slice slice_arm_data_at_time() args Trial arguments containing prior parameters num_samples Number posterior samples","code":""},{"path":"/reference/precompute_ctrl_posteriors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pre-compute control arm posteriors for caching in multi-arm comparisons — precompute_ctrl_posteriors","text":"List lamC (hazard samples matrix) medCtrl (median vector)","code":""},{"path":"/reference/pretty_scenario_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise simulation output by scenario and arm — pretty_scenario_matrix","title":"Summarise simulation output by scenario and arm — pretty_scenario_matrix","text":"Aggregates per-arm results returned run_scenarios() pivots wide table (one row per scenario) downstream reporting.","code":""},{"path":"/reference/pretty_scenario_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise simulation output by scenario and arm — pretty_scenario_matrix","text":"","code":"pretty_scenario_matrix(results_df)"},{"path":"/reference/pretty_scenario_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise simulation output by scenario and arm — pretty_scenario_matrix","text":"results_df Data frame/data.table produced run_scenarios() containing least scenario Arm_Name.","code":""},{"path":"/reference/pretty_scenario_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise simulation output by scenario and arm — pretty_scenario_matrix","text":"data.frame one row per scenario columns arm's key operating characteristics.","code":""},{"path":"/reference/prob_response_below.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate posterior probability that response rate is below threshold — prob_response_below","title":"Calculate posterior probability that response rate is below threshold — prob_response_below","text":"P(p < threshold | data) using Beta posterior","code":""},{"path":"/reference/prob_response_below.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate posterior probability that response rate is below threshold — prob_response_below","text":"","code":"prob_response_below(   n_responses,   n_total,   threshold,   alpha_prior = 1,   beta_prior = 1 )"},{"path":"/reference/prob_response_below.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate posterior probability that response rate is below threshold — prob_response_below","text":"n_responses Number responders n_total Total number patients threshold Response rate threshold alpha_prior Beta prior shape1 parameter (default 1) beta_prior Beta prior shape2 parameter (default 1)","code":""},{"path":"/reference/prob_response_below.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate posterior probability that response rate is below threshold — prob_response_below","text":"Posterior probability P(p < threshold)","code":""},{"path":"/reference/prob_response_exceeds.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate posterior probability that response rate exceeds threshold — prob_response_exceeds","title":"Calculate posterior probability that response rate exceeds threshold — prob_response_exceeds","text":"P(p > threshold | data) using Beta posterior","code":""},{"path":"/reference/prob_response_exceeds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate posterior probability that response rate exceeds threshold — prob_response_exceeds","text":"","code":"prob_response_exceeds(   n_responses,   n_total,   threshold,   alpha_prior = 1,   beta_prior = 1 )"},{"path":"/reference/prob_response_exceeds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate posterior probability that response rate exceeds threshold — prob_response_exceeds","text":"n_responses Number responders n_total Total number patients threshold Response rate threshold alpha_prior Beta prior shape1 parameter (default 1) beta_prior Beta prior shape2 parameter (default 1)","code":""},{"path":"/reference/prob_response_exceeds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate posterior probability that response rate exceeds threshold — prob_response_exceeds","text":"Posterior probability P(p > threshold)","code":""},{"path":"/reference/recommend_design_from_early.html","id":null,"dir":"Reference","previous_headings":"","what":"Recommend a single early-stopping design — recommend_design_from_early","title":"Recommend a single early-stopping design — recommend_design_from_early","text":"Selects top-performing row early-stopping grid subject alpha/power (optionally PET) constraints.","code":""},{"path":"/reference/recommend_design_from_early.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recommend a single early-stopping design — recommend_design_from_early","text":"","code":"recommend_design_from_early(   df,   alpha_cap = 0.1,   power_floor = 0.8,   pet_fut_cap = NULL )"},{"path":"/reference/recommend_design_from_early.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recommend a single early-stopping design — recommend_design_from_early","text":"df data.table/data.frame explore_early_stopping_from_cal(). alpha_cap Maximum acceptable type error. power_floor Minimum acceptable power. pet_fut_cap Optional cap alternative PET futility.","code":""},{"path":"/reference/recommend_design_from_early.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recommend a single early-stopping design — recommend_design_from_early","text":"data.table row describing recommended design.","code":""},{"path":"/reference/release_cluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Release an evolveTrial simulation cluster — release_cluster","title":"Release an evolveTrial simulation cluster — release_cluster","text":"Stops releases resources cluster created create_simulation_cluster().","code":""},{"path":"/reference/release_cluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Release an evolveTrial simulation cluster — release_cluster","text":"","code":"release_cluster(cluster)"},{"path":"/reference/release_cluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Release an evolveTrial simulation cluster — release_cluster","text":"cluster cluster object created create_simulation_cluster() parallel::makeCluster().","code":""},{"path":"/reference/release_cluster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Release an evolveTrial simulation cluster — release_cluster","text":"NULL invisibly.","code":""},{"path":[]},{"path":"/reference/resolve_gate_vec.html","id":null,"dir":"Reference","previous_headings":"","what":"Resolve gate parameter vector for specified arms with optional scaling — resolve_gate_vec","title":"Resolve gate parameter vector for specified arms with optional scaling — resolve_gate_vec","text":"Internal helper converts gate parameters (may scalar, named vector, positional vector) named numeric vector specified arms. Optionally applies proportional scaling based randomization probabilities.","code":""},{"path":"/reference/resolve_gate_vec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Resolve gate parameter vector for specified arms with optional scaling — resolve_gate_vec","text":"","code":"resolve_gate_vec(   raw,   target_arms,   all_arm_names,   randomization_probs = NULL,   default = 0,   scale = FALSE )"},{"path":"/reference/resolve_gate_vec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Resolve gate parameter vector for specified arms with optional scaling — resolve_gate_vec","text":"raw Raw gate parameter value (scalar, named vector, positional vector). target_arms Character vector arm names resolve gates . all_arm_names Character vector arm names trial (positional matching). randomization_probs Optional named numeric vector randomization probabilities. default Default value raw NULL (default 0). scale Logical; TRUE raw scalar/NULL, apply proportional scaling dividing arm's randomization probability maximum probability (default FALSE).","code":""},{"path":"/reference/resolve_gate_vec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Resolve gate parameter vector for specified arms with optional scaling — resolve_gate_vec","text":"Named numeric vector one element per arm target_arms.","code":""},{"path":"/reference/run_scenarios.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate a design across multiple scenarios — run_scenarios","title":"Evaluate a design across multiple scenarios — run_scenarios","text":"Merges scenario override list base_args, runs run_simulation_pure() every scenario, binds results single table.","code":""},{"path":"/reference/run_scenarios.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate a design across multiple scenarios — run_scenarios","text":"","code":"run_scenarios(base_args, scens, parallel = FALSE, seed = NULL)"},{"path":"/reference/run_scenarios.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate a design across multiple scenarios — run_scenarios","text":"base_args Named list arguments accepted run_simulation_pure(). scens List scenario override lists, typically scenarios_from_grid(). parallel Logical; TRUE uses parallel::mclapply() distribute scenarios across cores. seed Optional integer seed passed set.seed() simulations.","code":""},{"path":"/reference/run_scenarios.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate a design across multiple scenarios — run_scenarios","text":"data.table/data.frame containing combined operating characteristic summaries.  scenario column identifies originating scenario index.","code":""},{"path":"/reference/run_scenarios.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate a design across multiple scenarios — run_scenarios","text":"","code":"if (FALSE) { # \\dontrun{ base_args <- list(   num_simulations = 200,   arm_names = c(\"Doublet\", \"Triplet\"),   reference_arm_name = \"Doublet\",   compare_arms_option = TRUE,   weibull_shape_true_arms = c(Doublet = 1.2, Triplet = 1.2),   weibull_median_true_arms = c(Doublet = 6, Triplet = 6),   null_median_arms = c(Doublet = 6, Triplet = 6),   futility_median_arms = c(Doublet = 6, Triplet = 6),   interval_cutpoints_sim = seq(0, 24, by = 3),   max_follow_up_sim = 24,   censor_max_time_sim = 24,   prior_alpha_params_model = rep(0.5, 8),   prior_beta_params_model = rep(0.5, 8),   num_posterior_draws = 400,   cohort_size_per_arm = 1,   max_total_patients_per_arm = c(Doublet = 60, Triplet = 60),   min_patients_for_analysis = 10,   efficacy_stopping_rule_hc = TRUE,   efficacy_threshold_current_prob_hc = 0.95,   posterior_futility_threshold_hc = 0.8,   futility_stopping_rule_hc = TRUE,   efficacy_threshold_vs_ref_prob = 0.98,   futility_threshold_vs_ref_prob = 0.6,   compare_arms_futility_margin = 0.4,   overall_accrual_rate = 3,   randomization_probs = c(Doublet = 1/3, Triplet = 2/3),   min_follow_up_at_final = 0,   min_events_for_analysis = 0,   min_median_followup = 0,   interim_calendar_beat = 3,   pred_success_pp_threshold_hc = 1,   pred_futility_pp_threshold_hc = 0,   num_posterior_draws_pred = 200 )  scens <- scenarios_from_grid(list(   weibull_median_true_arms = list(     c(Doublet = 6, Triplet = 6),     c(Doublet = 6, Triplet = 9)   ) ))  run_scenarios(base_args, scens, parallel = FALSE, seed = 123) } # }"},{"path":"/reference/run_simulation_binary.html","id":null,"dir":"Reference","previous_headings":"","what":"Run binary endpoint trial simulation — run_simulation_binary","title":"Run binary endpoint trial simulation — run_simulation_binary","text":"Simulates two-stage binary endpoint trial Bayesian decision rules. Supports Simon-style designs cohort-based enrollment.","code":""},{"path":"/reference/run_simulation_binary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run binary endpoint trial simulation — run_simulation_binary","text":"","code":"run_simulation_binary(   num_simulations,   arm_names,   true_response_prob,   n1_per_arm,   n_total_per_arm,   p0,   p1 = NULL,   efficacy_threshold_binary_prob = 0.95,   futility_threshold_binary_prob = 0.95,   r1_per_arm = NULL,   r_per_arm = NULL,   use_simon_rules = FALSE,   alpha_prior = 1,   beta_prior = 1,   diagnostics = FALSE,   progress = interactive() )"},{"path":"/reference/run_simulation_binary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run binary endpoint trial simulation — run_simulation_binary","text":"num_simulations Number Monte Carlo replicates arm_names Character vector arm names (typically single arm) true_response_prob Named numeric vector true response probabilities n1_per_arm Named integer vector stage 1 sample sizes n_total_per_arm Named integer vector total sample sizes p0 Null hypothesis response rate p1 Alternative hypothesis response rate efficacy_threshold_binary_prob Posterior probability threshold efficacy futility_threshold_binary_prob Posterior probability threshold futility r1_per_arm Optional: Simon-style stage 1 boundaries (stop X1 <= r1) r_per_arm Optional: Simon-style total boundaries (success X > r) use_simon_rules Use exact Simon counting rules instead Bayesian alpha_prior Beta prior shape1 (default 1) beta_prior Beta prior shape2 (default 1) diagnostics Print diagnostic messages","code":""},{"path":"/reference/run_simulation_binary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run binary endpoint trial simulation — run_simulation_binary","text":"Data frame operating characteristics per arm","code":""},{"path":"/reference/run_simulation_pure.html","id":null,"dir":"Reference","previous_headings":"","what":"Run a full set of evolveTrial simulations for a design specification — run_simulation_pure","title":"Run a full set of evolveTrial simulations for a design specification — run_simulation_pure","text":"run_simulation_pure() workhorse simulator evolveTrial.  enrols patients according supplied accrual plan, applies interim gating/decision rules, optionally rebalances interval cut points, carries replicate forward final analysis.  Operating characteristics returned summarised per arm.","code":""},{"path":"/reference/run_simulation_pure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run a full set of evolveTrial simulations for a design specification — run_simulation_pure","text":"","code":"run_simulation_pure(   num_simulations,   arm_names,   reference_arm_name,   compare_arms_option,   weibull_shape_true_arms,   weibull_median_true_arms,   null_median_arms = NULL,   futility_median_arms = NULL,   interval_cutpoints_sim,   max_follow_up_sim,   censor_max_time_sim,   prior_alpha_params_model,   prior_beta_params_model,   num_posterior_draws,   num_posterior_draws_interim = NULL,   cohort_size_per_arm,   max_total_patients_per_arm,   min_patients_for_analysis = NULL,   efficacy_stopping_rule_hc = FALSE,   efficacy_threshold_current_prob_hc = NULL,   posterior_futility_threshold_hc = NULL,   efficacy_threshold_hc_prob = NULL,   futility_threshold_hc_prob = NULL,   futility_stopping_rule_hc = FALSE,   efficacy_stopping_rule_vs_ref = FALSE,   futility_stopping_rule_vs_ref = FALSE,   efficacy_threshold_vs_ref_prob = NULL,   futility_threshold_vs_ref_prob = NULL,   compare_arms_futility_margin = 0,   compare_arms_hr_margin = NULL,   use_ph_model_vs_ref = FALSE,   ph_loghr_prior_mean = 0,   ph_loghr_prior_sd = 1,   median_pfs_success_threshold_arms = NULL,   final_success_posterior_prob_threshold = 0.85,   median_pfs_futility_threshold_arms = NULL,   final_futility_posterior_prob_threshold = 0.85,   overall_accrual_rate,   randomization_probs,   min_follow_up_at_final = 0,   min_events_for_analysis = NULL,   min_median_followup = NULL,   min_events_hc = NULL,   min_median_followup_hc = NULL,   interim_calendar_beat = 2,   diagnostics = FALSE,   pred_success_pp_threshold_hc = 1,   pred_futility_pp_threshold_hc = 0,   num_posterior_draws_pred = 100,   predictive_fast = FALSE,   min_events_per_arm = NULL,   min_median_followup_per_arm = NULL,   min_person_time_frac_per_arm = 0,   person_time_milestones = NULL,   latest_calendar_look = Inf,   rebalance_after_events = NULL,   parallel_replicates = FALSE,   num_workers = NULL,   cluster_type = c(\"auto\", \"PSOCK\", \"FORK\"),   cluster = NULL,   progress = interactive() )"},{"path":"/reference/run_simulation_pure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run a full set of evolveTrial simulations for a design specification — run_simulation_pure","text":"num_simulations Number Monte Carlo replicates run. arm_names Character vector naming trial arms. reference_arm_name Character scalar naming control/reference arm. compare_arms_option Logical; TRUE evaluates vs-reference logic, FALSE evaluates arms independently historical control targets. weibull_shape_true_arms Named numeric vector Weibull shape parameters truth. weibull_median_true_arms Named numeric vector true median PFS (months) arm. null_median_arms Named numeric vector null (historical control) medians used single-arm evaluations. futility_median_arms Named numeric vector futility medians single-arm logic. interval_cutpoints_sim Numeric vector interval boundaries (months) piecewise exponential modelling. max_follow_up_sim Maximum administrative follow-time (months). censor_max_time_sim Upper bound random censoring draws (months). prior_alpha_params_model Numeric vector Gamma prior shape parameters piecewise exponential hazards. prior_beta_params_model Numeric vector Gamma prior rate parameters piecewise exponential hazards. num_posterior_draws Number posterior draws used final analyses. num_posterior_draws_interim Optional integer overriding number posterior draws used interim looks. cohort_size_per_arm Size enrolment batch per arm (typically 1). max_total_patients_per_arm Named integer vector per-arm sample size caps. min_patients_for_analysis Minimum number patients required evaluate arm single-arm path. specified, defaults 0, allowing interim analyses occur even patients. Set higher value prevent interim analyses certain number patients enrolled. efficacy_stopping_rule_hc Logical; enable interim efficacy checks historical-control path. efficacy_threshold_current_prob_hc DEPRECATED. Use efficacy_threshold_hc_prob instead. Interim success probability threshold single-arm logic. posterior_futility_threshold_hc DEPRECATED. Use futility_threshold_hc_prob instead. Interim futility probability threshold single-arm logic. efficacy_threshold_hc_prob Interim success probability threshold single-arm logic (preferred harmonized name). futility_threshold_hc_prob Interim futility probability threshold single-arm logic (preferred harmonized name). futility_stopping_rule_hc Logical; enable interim futility checks single-arm path. efficacy_stopping_rule_vs_ref Logical; enable interim efficacy checks vs-reference path. futility_stopping_rule_vs_ref Logical; enable interim futility checks vs-reference path. efficacy_threshold_vs_ref_prob Posterior superiority threshold vs-reference decisions. futility_threshold_vs_ref_prob Posterior inferiority threshold vs-reference decisions. compare_arms_futility_margin Absolute median difference used defining vs-reference futility. compare_arms_hr_margin Optional hazard-ratio margin used use_ph_model_vs_ref = TRUE. use_ph_model_vs_ref Logical; use proportional-hazards joint model vs-reference comparisons. ph_loghr_prior_mean Mean normal prior log hazard ratio (PH model). ph_loghr_prior_sd Standard deviation normal prior log hazard ratio. median_pfs_success_threshold_arms Named numeric vector median PFS thresholds declaring final success per arm. final_success_posterior_prob_threshold Posterior probability threshold final success declarations. median_pfs_futility_threshold_arms Named numeric vector median PFS futility thresholds final analyses. final_futility_posterior_prob_threshold Posterior probability threshold final futility declarations. overall_accrual_rate Expected accrual rate (patients per month). randomization_probs Named numeric vector randomisation probabilities. min_follow_up_at_final Additional follow-(months) required last enrolment final analysis. min_events_for_analysis DEPRECATED. Use min_events_hc instead. Minimum events required interim review (global gate). min_median_followup DEPRECATED. Use min_median_followup_hc instead. Minimum median follow-required interim review (global gate). min_events_hc Minimum events required single-arm interim review (preferred harmonized name). min_median_followup_hc Minimum median follow-required single-arm interim review (preferred harmonized name). interim_calendar_beat Calendar spacing (months) scheduled interim looks person-time milestones used. diagnostics Logical; TRUE prints interim diagnostic messages. pred_success_pp_threshold_hc Predictive probability threshold interim success single-arm predictive look (enabled). pred_futility_pp_threshold_hc Predictive probability threshold interim futility single-arm predictive look (enabled). num_posterior_draws_pred Number posterior draws used inside predictive probability calculations. predictive_fast Logical; switch analytic predictive approximations. min_events_per_arm Optional per-arm minimum event gate vs-reference. min_median_followup_per_arm Optional per-arm minimum median follow-gate vs-reference. min_person_time_frac_per_arm Optional per-arm proportion planned person-time required evaluating vs-reference decisions. person_time_milestones Optional numeric vector (fractions total planned person-time) triggering interim looks. latest_calendar_look Backstop calendar time person-time schedules. rebalance_after_events Optional integer; non-NULL piecewise cut points re-estimated number events accrued. parallel_replicates Logical; TRUE, distribute Monte Carlo replicates across parallel cluster. num_workers Optional integer specifying number workers parallel_replicates = TRUE. Defaults parallel::detectCores() - 1. cluster_type Type parallel cluster spawn distributing replicates. One \"auto\" (default, uses FORK Unix, PSOCK Windows), \"PSOCK\", \"FORK\". FORK clusters faster Linux/macOS share memory require package loading workers. cluster Optional pre-existing parallel cluster reuse. provided, cluster used parallel execution stopped exit. enables cluster pooling repeated calls (e.g., Bayesian optimization). Create evolveTrial::create_simulation_cluster() parallel::makeCluster(). progress Logical; show simulation progress bar running sequentially. Automatically disabled parallel replicate execution.","code":""},{"path":"/reference/run_simulation_pure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run a full set of evolveTrial simulations for a design specification — run_simulation_pure","text":"data frame one row per arm columns summarising operating characteristics type error / power, PETs, final decision probabilities, expected sample size.","code":""},{"path":"/reference/run_simulation_pure.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run a full set of evolveTrial simulations for a design specification — run_simulation_pure","text":"parallel_replicates = TRUE, results vary based num_workers due different random number stream partitioning. exact reproducibility across runs, use parallel_replicates = FALSE. package development devtools::load_all(), parallel workers load installed package version, development code. testing development changes, either use parallel_replicates = FALSE reinstall package devtools::install().","code":""},{"path":"/reference/sample_vs_ref_medians_independent.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample medians for vs-ref independent model (DISPATCHER) — sample_vs_ref_medians_independent","title":"Sample medians for vs-ref independent model (DISPATCHER) — sample_vs_ref_medians_independent","text":"Sample medians vs-ref independent model (DISPATCHER)","code":""},{"path":"/reference/sample_vs_ref_medians_independent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample medians for vs-ref independent model (DISPATCHER) — sample_vs_ref_medians_independent","text":"","code":"sample_vs_ref_medians_independent(   slCtrl,   slTrt,   args,   num_samples,   ctrl_cache = NULL )"},{"path":"/reference/sample_vs_ref_medians_independent_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample medians for vs-ref independent model (C++ implementation) — sample_vs_ref_medians_independent_cpp","title":"Sample medians for vs-ref independent model (C++ implementation) — sample_vs_ref_medians_independent_cpp","text":"End--end posterior sampler independent hazards model. Used single-arm trials multi-arm trials independent hazards.","code":""},{"path":"/reference/sample_vs_ref_medians_independent_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample medians for vs-ref independent model (C++ implementation) — sample_vs_ref_medians_independent_cpp","text":"","code":"sample_vs_ref_medians_independent_cpp(   E_C,   PT_C,   E_T,   PT_T,   alpha_prior,   beta_prior,   interval_lengths,   num_samples )"},{"path":"/reference/sample_vs_ref_medians_independent_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample medians for vs-ref independent model (C++ implementation) — sample_vs_ref_medians_independent_cpp","text":"E_C Integer vector control events per interval PT_C Numeric vector control person-time per interval E_T Integer vector treatment events per interval PT_T Numeric vector treatment person-time per interval alpha_prior Numeric vector Gamma prior shape parameters beta_prior Numeric vector Gamma prior rate parameters interval_lengths Numeric vector interval durations num_samples Number posterior samples","code":""},{"path":"/reference/sample_vs_ref_medians_independent_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample medians for vs-ref independent model (C++ implementation) — sample_vs_ref_medians_independent_cpp","text":"List \"medCtrl\" \"medTrt\" vectors (logHR independent model)","code":""},{"path":"/reference/sample_vs_ref_medians_independent_r.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample medians for vs-ref independent model (ORIGINAL R VERSION) — sample_vs_ref_medians_independent_r","title":"Sample medians for vs-ref independent model (ORIGINAL R VERSION) — sample_vs_ref_medians_independent_r","text":"Sample medians vs-ref independent model (ORIGINAL R VERSION)","code":""},{"path":"/reference/sample_vs_ref_medians_independent_r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample medians for vs-ref independent model (ORIGINAL R VERSION) — sample_vs_ref_medians_independent_r","text":"","code":"sample_vs_ref_medians_independent_r(slCtrl, slTrt, args, num_samples)"},{"path":"/reference/sample_vs_ref_medians_ph.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample medians for vs-ref PH model (DISPATCHER) — sample_vs_ref_medians_ph","title":"Sample medians for vs-ref PH model (DISPATCHER) — sample_vs_ref_medians_ph","text":"Sample medians vs-ref PH model (DISPATCHER)","code":""},{"path":"/reference/sample_vs_ref_medians_ph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample medians for vs-ref PH model (DISPATCHER) — sample_vs_ref_medians_ph","text":"","code":"sample_vs_ref_medians_ph(slCtrl, slTrt, args, num_samples)"},{"path":"/reference/sample_vs_ref_medians_ph_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample medians for vs-ref PH model (C++ implementation) — sample_vs_ref_medians_ph_cpp","title":"Sample medians for vs-ref PH model (C++ implementation) — sample_vs_ref_medians_ph_cpp","text":"End--end posterior sampler proportional hazards model. Samples log-HR posterior, baseline hazards, computes medians.","code":""},{"path":"/reference/sample_vs_ref_medians_ph_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample medians for vs-ref PH model (C++ implementation) — sample_vs_ref_medians_ph_cpp","text":"","code":"sample_vs_ref_medians_ph_cpp(   E_C,   PT_C,   E_T,   PT_T,   alpha_prior,   beta_prior,   interval_lengths,   mu,   sigma,   num_samples )"},{"path":"/reference/sample_vs_ref_medians_ph_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample medians for vs-ref PH model (C++ implementation) — sample_vs_ref_medians_ph_cpp","text":"E_C Integer vector control events per interval PT_C Numeric vector control person-time per interval E_T Integer vector treatment events per interval PT_T Numeric vector treatment person-time per interval alpha_prior Numeric vector Gamma prior shape parameters beta_prior Numeric vector Gamma prior rate parameters interval_lengths Numeric vector interval durations mu Log-HR prior mean sigma Log-HR prior SD num_samples Number posterior samples","code":""},{"path":"/reference/sample_vs_ref_medians_ph_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample medians for vs-ref PH model (C++ implementation) — sample_vs_ref_medians_ph_cpp","text":"List \"medCtrl\", \"medTrt\", \"logHR\" vectors","code":""},{"path":"/reference/sample_vs_ref_medians_ph_r.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample medians for vs-ref PH model (ORIGINAL R VERSION) — sample_vs_ref_medians_ph_r","title":"Sample medians for vs-ref PH model (ORIGINAL R VERSION) — sample_vs_ref_medians_ph_r","text":"Sample medians vs-ref PH model (ORIGINAL R VERSION)","code":""},{"path":"/reference/sample_vs_ref_medians_ph_r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample medians for vs-ref PH model (ORIGINAL R VERSION) — sample_vs_ref_medians_ph_r","text":"","code":"sample_vs_ref_medians_ph_r(slCtrl, slTrt, args, num_samples)"},{"path":"/reference/scenarios_from_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Build scenario overrides from a grid of design choices — scenarios_from_grid","title":"Build scenario overrides from a grid of design choices — scenarios_from_grid","text":"Expands named list options list scenario override lists can merged base_args prior simulation.","code":""},{"path":"/reference/scenarios_from_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build scenario overrides from a grid of design choices — scenarios_from_grid","text":"","code":"scenarios_from_grid(choices)"},{"path":"/reference/scenarios_from_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build scenario overrides from a grid of design choices — scenarios_from_grid","text":"choices Named list element either vector scalar values list whose elements per-arm vectors.","code":""},{"path":"/reference/scenarios_from_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build scenario overrides from a grid of design choices — scenarios_from_grid","text":"list scenario override lists.  underlying Cartesian grid attached attribute named \"grid\".","code":""},{"path":"/reference/scenarios_from_grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build scenario overrides from a grid of design choices — scenarios_from_grid","text":"","code":"scenarios_from_grid(list(   max_total_patients_per_arm = list(     c(Doublet = 60, Triplet = 60),     c(Doublet = 60, Triplet = 70)   ),   compare_arms_futility_margin = c(0.3, 0.4) )) #> [[1]] #> [[1]]$max_total_patients_per_arm #> Doublet Triplet  #>      60      60  #>  #> [[1]]$compare_arms_futility_margin #> [1] 0.3 #>  #>  #> [[2]] #> [[2]]$max_total_patients_per_arm #> Doublet Triplet  #>      60      70  #>  #> [[2]]$compare_arms_futility_margin #> [1] 0.3 #>  #>  #> [[3]] #> [[3]]$max_total_patients_per_arm #> Doublet Triplet  #>      60      60  #>  #> [[3]]$compare_arms_futility_margin #> [1] 0.4 #>  #>  #> [[4]] #> [[4]]$max_total_patients_per_arm #> Doublet Triplet  #>      60      70  #>  #> [[4]]$compare_arms_futility_margin #> [1] 0.4 #>  #>  #> attr(,\"grid\") #>   max_total_patients_per_arm compare_arms_futility_margin #> 1                          1                          0.3 #> 2                          2                          0.3 #> 3                          1                          0.4 #> 4                          2                          0.4"},{"path":"/reference/set_futility_medians.html","id":null,"dir":"Reference","previous_headings":"","what":"Adjust futility medians for experimental arms — set_futility_medians","title":"Adjust futility medians for experimental arms — set_futility_medians","text":"Adjust futility medians experimental arms","code":""},{"path":"/reference/set_futility_medians.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adjust futility medians for experimental arms — set_futility_medians","text":"","code":"set_futility_medians(   args,   null_med,   alt_med,   base = c(\"null+delta\", \"alt\"),   delta = 0 )"},{"path":"/reference/set_futility_medians.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adjust futility medians for experimental arms — set_futility_medians","text":"args Argument list whose futility_median_arms entry updated. null_med Numeric scalar representing null median. alt_med Numeric scalar representing alternative median. base Character scalar selecting \"null+delta\" \"alt\". delta Numeric offset added base = \"null+delta\".","code":""},{"path":"/reference/set_futility_medians.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adjust futility medians for experimental arms — set_futility_medians","text":"Modified argument list updated futility_median_arms.","code":""},{"path":"/reference/simon_final_efficacy.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Simon-style final efficacy rule — simon_final_efficacy","title":"Check Simon-style final efficacy rule — simon_final_efficacy","text":"classical Simon design, declare efficacy total responses > r","code":""},{"path":"/reference/simon_final_efficacy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Simon-style final efficacy rule — simon_final_efficacy","text":"","code":"simon_final_efficacy(n_responses, r)"},{"path":"/reference/simon_final_efficacy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check Simon-style final efficacy rule — simon_final_efficacy","text":"n_responses Total number responders r Total response threshold (success responses > r)","code":""},{"path":"/reference/simon_final_efficacy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Simon-style final efficacy rule — simon_final_efficacy","text":"TRUE efficacious","code":""},{"path":"/reference/simon_oc_exact.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Simon design operating characteristics analytically — simon_oc_exact","title":"Calculate Simon design operating characteristics analytically — simon_oc_exact","text":"Computes exact operating characteristics Simon two-stage design.","code":""},{"path":"/reference/simon_oc_exact.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Simon design operating characteristics analytically — simon_oc_exact","text":"","code":"simon_oc_exact(n1, r1, n, r, p)"},{"path":"/reference/simon_oc_exact.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Simon design operating characteristics analytically — simon_oc_exact","text":"n1 Stage 1 sample size r1 Stage 1 futility boundary (stop X1 <= r1) n Total sample size (n1 + n2) r Total response threshold efficacy (success X > r) p True response probability","code":""},{"path":"/reference/simon_oc_exact.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Simon design operating characteristics analytically — simon_oc_exact","text":"List : reject_prob: Probability rejecting null (power type error) pet: Probability early termination stage 1 en: Expected sample size","code":""},{"path":"/reference/simon_stage1_futility.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Simon-style stage 1 futility rule — simon_stage1_futility","title":"Check Simon-style stage 1 futility rule — simon_stage1_futility","text":"classical Simon design, stop stage 1 responses <= r1","code":""},{"path":"/reference/simon_stage1_futility.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Simon-style stage 1 futility rule — simon_stage1_futility","text":"","code":"simon_stage1_futility(n_responses, r1)"},{"path":"/reference/simon_stage1_futility.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check Simon-style stage 1 futility rule — simon_stage1_futility","text":"n_responses Number responders stage 1 r1 Stage 1 futility boundary (stop responses <= r1)","code":""},{"path":"/reference/simon_stage1_futility.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Simon-style stage 1 futility rule — simon_stage1_futility","text":"TRUE stop futility","code":""},{"path":"/reference/simulate_binary_response_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate binary response data for a cohort — simulate_binary_response_data","title":"Simulate binary response data for a cohort — simulate_binary_response_data","text":"Generates binary response outcomes n patients true response probability p.","code":""},{"path":"/reference/simulate_binary_response_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate binary response data for a cohort — simulate_binary_response_data","text":"","code":"simulate_binary_response_data(n, p, start_id = 1L)"},{"path":"/reference/simulate_binary_response_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate binary response data for a cohort — simulate_binary_response_data","text":"n Number patients p True response probability (0 1) start_id Starting patient ID (default 1)","code":""},{"path":"/reference/simulate_binary_response_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate binary response data for a cohort — simulate_binary_response_data","text":"Data frame columns: id, response (0/1)","code":""},{"path":"/reference/test_armadillo_random.html","id":null,"dir":"Reference","previous_headings":"","what":"Test Armadillo matrix operations — test_armadillo_random","title":"Test Armadillo matrix operations — test_armadillo_random","text":"Test Armadillo matrix operations","code":""},{"path":"/reference/test_armadillo_random.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test Armadillo matrix operations — test_armadillo_random","text":"","code":"test_armadillo_random(n)"},{"path":"/reference/test_armadillo_random.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test Armadillo matrix operations — test_armadillo_random","text":"n Matrix dimension","code":""},{"path":"/reference/test_armadillo_random.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test Armadillo matrix operations — test_armadillo_random","text":"Mean random normal matrix","code":""},{"path":"/reference/test_rcpp_sum.html","id":null,"dir":"Reference","previous_headings":"","what":"Test Rcpp setup — test_rcpp_sum","title":"Test Rcpp setup — test_rcpp_sum","text":"Simple test function verify Rcpp RcppArmadillo working.","code":""},{"path":"/reference/test_rcpp_sum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test Rcpp setup — test_rcpp_sum","text":"","code":"test_rcpp_sum(x)"},{"path":"/reference/test_rcpp_sum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test Rcpp setup — test_rcpp_sum","text":"x numeric vector","code":""},{"path":"/reference/test_rcpp_sum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test Rcpp setup — test_rcpp_sum","text":"Sum vector","code":""},{"path":[]},{"path":"/news/index.html","id":"breaking-changes-0-0-0-9000","dir":"Changelog","previous_headings":"","what":"Breaking Changes","title":"evolveTrial 0.0.0.9000","text":"Single-arm gate scaling: Single-arm (compare_arms_option = FALSE) now applies proportional scaling min_events_per_arm min_person_time_frac_per_arm based randomization_probs, matching vs-reference behavior. Arms lower randomization probabilities automatically get proportionally lower gates scalar gate values provided. Parameter naming harmonization: Updated parameter names consistency across comparison paths: efficacy_threshold_current_prob_hc → efficacy_threshold_hc_prob posterior_futility_threshold_hc → futility_threshold_hc_prob min_events_for_analysis → min_events_hc min_median_followup → min_median_followup_hc","code":""},{"path":"/news/index.html","id":"deprecated-parameters-0-0-0-9000","dir":"Changelog","previous_headings":"","what":"Deprecated Parameters","title":"evolveTrial 0.0.0.9000","text":"Old parameter names still supported deprecation warnings. Users migrate new names:","code":""},{"path":"/news/index.html","id":"new-features-0-0-0-9000","dir":"Changelog","previous_headings":"","what":"New Features","title":"evolveTrial 0.0.0.9000","text":"Added resolve_gate_vec() internal helper (R/gate_diagnostics.R) unified gate parameter resolution optional proportional scaling across comparison paths. Added comprehensive test suites single-arm scenarios: test-single-arm-gates.R: Basic edge cases proportional scaling, rebalancing, multiple gates test-single-arm-regression.R: Null/alternative scenarios, early stopping, final analysis validation test-path-parity.R: Parity tests ensuring single-arm vs-reference paths maintain consistent behavior","code":""},{"path":"/news/index.html","id":"code-quality-0-0-0-9000","dir":"Changelog","previous_headings":"","what":"Code Quality","title":"evolveTrial 0.0.0.9000","text":"Removed unused functions: run_single_arm_interim(), slice_arm_at_time(), posterior_scalar_draws() R/state_management.R (longer needed refactoring). Consolidated gate resolution logic: vs-reference single-arm paths now use resolve_gate_vec() helper, eliminating code duplication.","code":""},{"path":"/news/index.html","id":"package-maintenance-0-0-0-9000","dir":"Changelog","previous_headings":"","what":"Package Maintenance","title":"evolveTrial 0.0.0.9000","text":"Removed non-ASCII characters (emojis, Greek letters, smart quotes) source code Replaced library() calls requireNamespace() + :: proper package dependencies Reorganized DESCRIPTION: moved optional packages (gt, dplyr, openxlsx, etc.) Suggests Removed unused imports (ggpubr, survival, survminer) Added VignetteBuilder field proper vignette support Added complete @param documentation internal helper functions Fixed documentation mismatches explore_early_stopping_from_cal() Added @keywords internal tags non-exported functions Added stats::rnorm namespace imports Added missing global variable declarations Updated .Rbuildignore exclude development files Improved test coverage actual utility function tests","code":""},{"path":"/news/index.html","id":"bug-fixes-0-0-0-9000","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"evolveTrial 0.0.0.9000","text":"None development version","code":""},{"path":"/news/index.html","id":"new-features-0-0-0-9000-1","dir":"Changelog","previous_headings":"","what":"New Features","title":"evolveTrial 0.0.0.9000","text":"None development version (package active development)","code":""}]
