[{"path":[]},{"path":"/AGENTS.html","id":"project-structure--module-organization","dir":"","previous_headings":"","what":"Project Structure & Module Organization","title":"Repository Guidelines","text":"Core simulation decision logic lives R/ (state_management.R, interim_logic.R, simulation_driver.R). Statistical helpers posterior samplers predictive calculations sit alongside . Tests tests/testthat, documentation topics man/ longer-form walkthroughs vignettes/. Artifacts pkgdown live _pkgdown.yml, renv/ pins package dependencies reproducible runs. Keep auxiliary scripts (e.g., scenario grids) project root inst/ pollute package namespace.","code":""},{"path":"/AGENTS.html","id":"build-test-and-development-commands","dir":"","previous_headings":"","what":"Build, Test, and Development Commands","title":"Repository Guidelines","text":"Use devtools::load_all() iterative work; refreshes package namespace without reinstalling. Run devtools::test() targeted validation devtools::check() publishing ensure R CMD check passes cleanly. local script runs, Rscript path//file.R keeps environments isolated. major updates, devtools::install() followed library(evolveTrial) mirrors user experience. pkgdown::build_site() regenerates browsable documentation substantive API changes land.","code":""},{"path":"/AGENTS.html","id":"coding-style--naming-conventions","dir":"","previous_headings":"","what":"Coding Style & Naming Conventions","title":"Repository Guidelines","text":"Follow tidyverse-style R code: two-space indentation, { line, snake_case identifiers (min_person_time_frac_per_arm). Reuse package utilities %||% coalesce_num() instead re-implementing fallbacks. Keep diagnostic message() calls concise prefixed (e.g., [vsREF gate]). adding arguments, thread run_simulation_pure() formals downstream helpers can pick via modifyList().","code":""},{"path":"/AGENTS.html","id":"testing-guidelines","dir":"","previous_headings":"","what":"Testing Guidelines","title":"Repository Guidelines","text":"New decision logic gating tweaks must include regression tests tests/testthat/. Prioritize scenarios stress multi-arm comparisons, proportional gate scaling, predictive probability fallbacks. Use deterministic seeds (e.g., set.seed(4242)) low simulation counts unit tests; save large grids ad-hoc scripts. Document required outputs (PET, alpha, expected N) expectations future refactors flag behavior shifts early.","code":""},{"path":"/AGENTS.html","id":"commit--pull-request-guidelines","dir":"","previous_headings":"","what":"Commit & Pull Request Guidelines","title":"Repository Guidelines","text":"Write imperative, present-tense commit titles ~72 characters (see git log: “Add one-time interval rebalancing support”). Group related edits—code, docs, tests—single commit feasible. PRs summarize design intent, note simulation diagnostics (attach key rows res[...]), call configuration changes affecting calibration. Link upstream issues design discussions future agents understand rationale. requesting review, ensure devtools::check() clean results.txt intermediate files ignored removed.","code":""},{"path":"/CLAUDE.html","id":null,"dir":"","previous_headings":"","what":"CLAUDE.md","title":"CLAUDE.md","text":"file provides guidance Claude Code (claude.ai/code) working code repository.","code":""},{"path":"/CLAUDE.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"CLAUDE.md","text":"evolveTrial R package Bayesian adaptive platform/umbrella clinical trial simulation design analysis. specializes progression-free survival (PFS) endpoints using piecewise exponential models single-arm (vs historical control) multi-arm (vs-reference) decision logic.","code":""},{"path":[]},{"path":"/CLAUDE.html","id":"core-simulation-architecture","dir":"","previous_headings":"Package Structure","what":"Core Simulation Architecture","title":"CLAUDE.md","text":"simulation engine built around three main components: State Management (R/state_management.R): make_state() function creates trial state containers tracking arm status (recruiting/stopped), patient registries, enrollment counts. slice_arm_data_at_time() function provides time-based snapshots patient data interim analyses, computing interval metrics via calculate_interval_metrics_fast(). Interim Logic (R/interim_logic.R): interim_check() function decision engine evaluates efficacy futility scheduled looks. branches compare_arms_option: vs-reference path: Compares experimental arms reference/control arm using calculate_current_probs_vs_ref(), evaluating per-arm gates (min_events_per_arm, min_median_followup_per_arm, min_person_time_frac_per_arm) single-arm path: Evaluates arms independently historical control targets using calculate_current_probs_hc(), optional predictive probability fallbacks R/predictive_probabilities.R Simulation Driver (R/simulation_driver.R): run_simulation_pure() function workhorse orchestrates Monte Carlo replicates, enrolling patients via piecewise exponential data generation (R/data_generation.R), applying interim checks calendar beats person-time milestones, accumulating operating characteristics (type error, power, PET, expected N).","code":""},{"path":"/CLAUDE.html","id":"statistical-helpers","dir":"","previous_headings":"Package Structure","what":"Statistical Helpers","title":"CLAUDE.md","text":"Posterior Sampling (R/posterior_helpers.R): draw_posterior_hazard_samples() draws Gamma posteriors interval hazards; calculate_median_survival_piecewise() converts hazard vectors median survival times (handles open-ended tail extrapolation) Predictive Probabilities (R/predictive_probabilities.R): calculate_predicted_success_prob_vs_hc() performs forward simulation current posterior final analysis PH Models: use_ph_model_vs_ref = TRUE, vs-reference comparisons use joint proportional-hazards model log hazard ratio priors","code":""},{"path":"/CLAUDE.html","id":"design-analysis-workflow","dir":"","previous_headings":"Package Structure","what":"Design Analysis Workflow","title":"CLAUDE.md","text":"Parameter Grid Setup: Define design grids (efficacy/futility thresholds, gates, sample sizes) Simulation: run_scenarios() wraps run_simulation_pure() batch execution across scenarios (see R/design_analysis.R) Calibration: grid_calibrate() searches efficacy/futility threshold combinations meet target type error constraints; calibrate_alpha() performs single-dimension searches Reporting: pretty_scenario_matrix() pivots results scenario × arm tables; export_scenario_table_to_excel() export_scenario_table_to_png() generate formatted outputs","code":""},{"path":"/CLAUDE.html","id":"gate-diagnostics","dir":"","previous_headings":"Package Structure","what":"Gate Diagnostics","title":"CLAUDE.md","text":"early stopping fails occur, often means information gates postpone first informative look. Use estimate_vsref_gate_timing() (R/gate_diagnostics.R) get lower-bound heuristics vs-reference gates (min_events_per_arm, min_median_followup_per_arm, min_person_time_frac_per_arm) can satisfied deterministic accrual. See README.Rmd examples.","code":""},{"path":[]},{"path":"/CLAUDE.html","id":"package-development","dir":"","previous_headings":"Development Commands","what":"Package Development","title":"CLAUDE.md","text":"","code":"# Iterative development (refreshes namespace without reinstall) devtools::load_all()  # Run tests devtools::test()  # Full R CMD check before publishing devtools::check()  # Install locally to mirror user experience devtools::install() library(evolveTrial)  # Regenerate documentation site after API changes pkgdown::build_site()  # Render README.Rmd to README.md devtools::build_readme()"},{"path":"/CLAUDE.html","id":"running-scripts","dir":"","previous_headings":"Development Commands","what":"Running Scripts","title":"CLAUDE.md","text":"","code":"# Isolated environment for scenario grids or one-off analyses Rscript path/to/script.R"},{"path":"/CLAUDE.html","id":"testing","dir":"","previous_headings":"Development Commands","what":"Testing","title":"CLAUDE.md","text":"","code":"# Run a single test file testthat::test_file(\"tests/testthat/test-estimate-vsref-gates.R\")  # Run tests matching a pattern testthat::test_local(filter = \"utils\")"},{"path":"/CLAUDE.html","id":"coding-conventions","dir":"","previous_headings":"","what":"Coding Conventions","title":"CLAUDE.md","text":"Style: Follow tidyverse conventions (two-space indentation, { line, snake_case identifiers like min_person_time_frac_per_arm) Utilities: Reuse package helpers (%||% fallback, coalesce_num() numeric coalescing, resolve_gate_vec() gate parameter resolution) instead reimplementing Diagnostics: Keep message() calls concise prefixed (e.g., [vsREF gate]) Argument Threading: adding parameters, add run_simulation_pure() formals downstream helpers can access via modifyList() Documentation: Use roxygen2 markdown format; document exported functions user-facing helpers Parameter Naming: Use harmonized naming scheme across comparison paths (e.g., efficacy_threshold_hc_prob, futility_threshold_hc_prob)","code":""},{"path":"/CLAUDE.html","id":"simulation-configuration","dir":"","previous_headings":"","what":"Simulation Configuration","title":"CLAUDE.md","text":"Key design parameters threaded run_simulation_pure() interim_check(): Arms & Comparison: arm_names, reference_arm_name, compare_arms_option (TRUE = vs-reference, FALSE = single-arm) Truth & Priors: weibull_shape_true_arms, weibull_median_true_arms, prior_alpha_params_model, prior_beta_params_model vs-reference: efficacy_threshold_vs_ref_prob, futility_threshold_vs_ref_prob, compare_arms_futility_margin single-arm: efficacy_threshold_hc_prob, futility_threshold_hc_prob, null_median_arms, futility_median_arms Deprecated (still supported warnings): efficacy_threshold_current_prob_hc, posterior_futility_threshold_hc Per-arm gates: min_events_per_arm, min_median_followup_per_arm, min_person_time_frac_per_arm (used vs-reference single-arm) Legacy global gates: min_events_hc, min_median_followup_hc, min_patients_for_analysis (single-arm ) Deprecated (still supported warnings): min_events_for_analysis, min_median_followup Proportional Scaling: min_events_per_arm min_person_time_frac_per_arm scalar, automatically scaled randomization_probs account unbalanced randomization Scheduling: interim_calendar_beat (fixed spacing) person_time_milestones (data-driven) Sample Size: max_total_patients_per_arm, cohort_size_per_arm, overall_accrual_rate, randomization_probs","code":""},{"path":"/CLAUDE.html","id":"gate-scaling-behavior","dir":"","previous_headings":"","what":"Gate Scaling Behavior","title":"CLAUDE.md","text":"recent updates, vs-reference single-arm paths apply proportional gate scaling scalar gate values provided: gets scaled: min_events_per_arm min_person_time_frac_per_arm (provided scalars) doesn’t get scaled: min_median_followup_per_arm (followup time independent randomization ratio) scaling works: specify min_events_per_arm = 10 randomization_probs = c(Control = 0.3, Treatment = 0.7), helper resolve_gate_vec() (R/gate_diagnostics.R) scale gates proportionally: arms lower randomization probabilities get proportionally lower gates use named vectors: override proportional scaling, provide named vector (e.g., min_events_per_arm = c(Control = 8, Treatment = 12)) ensures fairness comparing arms unbalanced randomization, unifies behavior across comparison paths.","code":""},{"path":"/CLAUDE.html","id":"testing-approach","dir":"","previous_headings":"","what":"Testing Approach","title":"CLAUDE.md","text":"New decision logic gating features require regression tests tests/testthat/. Prioritize: - Multi-arm comparisons reference arm switches - Proportional gate scaling across unbalanced arms (see test-single-arm-gates.R test-path-parity.R) - Predictive probability fallback triggers - Use deterministic seeds (set.seed(4242)) low simulation counts (e.g., num_simulations = 50) unit tests - Document required outputs (PET, alpha, expected N) expect_*() calls catch behavior shifts - Parity tests ensure single-arm vs-reference paths maintain consistent behavior","code":""},{"path":"/CLAUDE.html","id":"project-management","dir":"","previous_headings":"","what":"Project Management","title":"CLAUDE.md","text":"Dependencies: Managed via renv/ reproducibility; renv::restore() sync Documentation: man/ holds function docs; vignettes/ contains long-form guides; _pkgdown.yml configures browsable site Artifacts: Keep ad-hoc scenario grids analysis scripts project root inst/; exclude package namespace Commit Style: Imperative, present-tense titles 72 characters (e.g., “Add one-time interval rebalancing support”); group related code/docs/tests single commits; link upstream issues context","code":""},{"path":[]},{"path":"/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement naim.rashid84@gmail.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to evolveTrial","title":"Contributing to evolveTrial","text":"outlines propose change evolveTrial. detailed discussion contributing tidyverse packages, please see development contributing guide code review principles.","code":""},{"path":"/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to evolveTrial","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ’ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"/CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to evolveTrial","text":"want make bigger change, ’s good idea first file issue make sure someone team agrees ’s needed. ’ve found bug, please file issue illustrates bug minimal reprex (also help write unit test, needed). See guide create great issue advice.","code":""},{"path":"/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to evolveTrial","text":"Fork package clone onto computer. haven’t done , recommend using usethis::create_from_github(\"naimurashid/evolveTrial\", fork = TRUE). Install development dependencies devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e. just first header). Follow style described https://style.tidyverse.org/news.html.","code":""},{"path":"/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to evolveTrial","text":"New code follow tidyverse style guide. can use Air apply style, please don’t restyle code nothing PR. use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":"/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to evolveTrial","text":"Please note evolveTrial project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":null,"dir":"","previous_headings":"","what":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"Version: 1.1 Date: 2025-12-20 Status: IMPLEMENTED - Core Components Complete","code":""},{"path":[]},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_11-purpose","dir":"","previous_headings":"1. Design Overview","what":"1.1 Purpose","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"specification defines hybrid trial design evolveTrial : 1. Begins single-arm (SA) monitoring experimental arm pre-specified historical controls 2. Upon meeting SA efficacy criteria, evaluates conversion -arm (BA) comparison 3. Uses predictive probability determine additional enrollment BA comparison worthwhile 4. converted, continues seamless BA monitoring using accumulated data","code":""},{"path":[]},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_13-literature-foundation","dir":"","previous_headings":"1. Design Overview","what":"1.3 Literature Foundation","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"BASIC Design (Thall et al. 2023) - Bayesian adaptive synthetic-control MAMS Literature - Multi-arm multi-stage seamless designs SSR Literature - Predictive probability sample size re-estimation (Chuang-Stein 2007) FDA Guidance (2019) - Adaptive designs prospective specification","code":""},{"path":[]},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_21-survival-model","dir":"","previous_headings":"2. Mathematical Framework","what":"2.1 Survival Model","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"Piecewise Exponential (PWE) K intervals: - Hazard rates: λ_k arm k, interval j - Gamma conjugate priors: λ_{k,j} ~ Gamma(α_0, β_0) Posterior Update:","code":"α_post = α_prior + n_events β_post = β_prior + person_time"},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_22-historical-control","dir":"","previous_headings":"2. Mathematical Framework","what":"2.2 Historical Control","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"Historical control hazard fixed constant (modeled random):","code":"λ_hist = log(2) / median_hist"},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_23-within-arm-comparison-vs-historical","dir":"","previous_headings":"2. Mathematical Framework","what":"2.3 Within-Arm Comparison (vs Historical)","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"Probability arm k beats historical threshold c_k: exponential (K=1): Closed-form Gamma CDF PWE (K>1): Posterior sampling using existing evolveTrial infrastructure","code":"p_k^single = P(λ_k < c_k × λ_hist | data) p_single <- pgamma(c_k * lambda_hist, shape = a_post, rate = b_post)"},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_24-between-arm-comparison","dir":"","previous_headings":"2. Mathematical Framework","what":"2.4 Between-Arm Comparison","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"Probability arm superior arm B: exponential: Closed-form F-distribution PWE: Posterior sampling using sample_vs_ref_medians_ph()","code":"p_AB^between = P(λ_A / λ_B < 1 | data) p_between <- pf(   q = (b_A / b_B) * (a_B / a_A),   df1 = 2 * a_A,   df2 = 2 * a_B )"},{"path":[]},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_31-states","dir":"","previous_headings":"3. State Machine Architecture","what":"3.1 States","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"","code":"STATE_SINGLE              # Primary SA monitoring STATE_CONSIDER_CONVERSION # Evaluating conversion via PP STATE_BETWEEN             # Full BA comparison phase STATE_STOP                # Terminal state"},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_32-transitions","dir":"","previous_headings":"3. State Machine Architecture","what":"3.2 Transitions","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"","code":"┌─────────────────┐                     │  STATE_SINGLE   │                     └────────┬────────┘                              │           ┌──────────────────┼──────────────────┐           │                  │                  │           ▼                  ▼                  ▼   ┌────────────────┐ ┌────────────────┐ ┌─────────────────────┐   │ All arms       │ │ Max N reached  │ │ SA trigger met      │   │ futile         │ │ (no trigger)   │ │                     │   └───────┬────────┘ └───────┬────────┘ └──────────┬──────────┘           │                  │                     │           │                  │                     ▼           │                  │          ┌─────────────────────────┐           │                  │          │ STATE_CONSIDER_CONVERSION│           │                  │          └──────────┬──────────────┘           │                  │                     │           │                  │         ┌───────────┴───────────┐           │                  │         │                       │           │                  │         ▼                       ▼           │                  │  ┌─────────────┐         ┌──────────┐           │                  │  │ PP >= pp_go │         │PP < nogo │           │                  │  └──────┬──────┘         └────┬─────┘           │                  │         │                     │           │                  │         ▼                     │           │                  │  ┌─────────────────┐          │           │                  │  │  STATE_BETWEEN  │          │           │                  │  └────────┬────────┘          │           │                  │           │                   │           ▼                  ▼           ▼                   ▼        ┌────────────────────────────────────────────────────────┐        │                        STATE_STOP                      │        └────────────────────────────────────────────────────────┘"},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_33-state-logic","dir":"","previous_headings":"3. State Machine Architecture","what":"3.3 State Logic","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"STATE_SINGLE: - Enroll patients, compute SA posteriors interim - Check SA efficacy: p_k^single > eff_sa - Check SA futility: p_k^single < fut_sa - Apply futility action per arm configuration - Check transition trigger STATE_CONSIDER_CONVERSION: - Compute PP curve candidate N_add values - PP(N_add) >= pp_go viable N → proceed - max(PP) < pp_nogo → stop (worth continuing) - Else: ambiguous region (default -go) STATE_BETWEEN: - Continue enrollment selected N_max - Check BA efficacy: p_AB^> eff_ba - Check BA futility: p_AB^< fut_ba STATE_STOP: - Report single-arm /-arm conclusions","code":""},{"path":[]},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_41-single-arm-rules","dir":"","previous_headings":"4. Decision Rules","what":"4.1 Single-Arm Rules","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"Default thresholds: - eff_sa = 0.90 - fut_sa = 0.10 - c_k = 0.80 (20% improvement target)","code":""},{"path":[]},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_43-conversion-rules","dir":"","previous_headings":"4. Decision Rules","what":"4.3 Conversion Rules","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"Default thresholds: - pp_go = 0.70 - pp_nogo = 0.20","code":""},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_44-between-arm-rules","dir":"","previous_headings":"4. Decision Rules","what":"4.4 Between-Arm Rules","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"Default thresholds: - eff_ba = 0.975 - fut_ba = 0.05","code":""},{"path":[]},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_51-predictive-probability-method-recommended","dir":"","previous_headings":"5. Sample Size Re-Estimation","what":"5.1 Predictive Probability Method (Recommended)","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"Algorithm: Properties: - Accounts posterior uncertainty - Bayesian-consistent - conservative conditional power","code":"For each candidate N_add in {10, 20, ..., max_additional_n}:   success_count = 0   For i = 1 to n_outer (default 1000):     1. Draw λ_true from current posterior     2. Simulate future patients under λ_true     3. Update posterior with future data (seamless)     4. Compute P(BA success | final data)     5. If P(BA success) >= eff_ba: success_count++   PP(N_add) = success_count / n_outer  Find smallest N_add where PP(N_add) >= pp_go"},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_52-posterior-method-fast-approximation","dir":"","previous_headings":"5. Sample Size Re-Estimation","what":"5.2 Posterior Method (Fast Approximation)","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"Algorithm: Properties: - Analytical (milliseconds) - Can overconfident sparse data - Use rapid prototyping ","code":"1. Extract point estimate θ̂ from current posterior mode 2. For each candidate N_add:    Calculate conditional power: CP(N_add | θ̂) 3. Find smallest N_add where CP >= target_power"},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_53-recommendation","dir":"","previous_headings":"5. Sample Size Re-Estimation","what":"5.3 Recommendation","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"Use predictive probability production calibration final design selection. Use posterior method quick feasibility checks development.","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_81-null-scenarios-type-i-error-control","dir":"","previous_headings":"8. Calibration Scenarios","what":"8.1 Null Scenarios (Type I Error Control)","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"null_global: arms equal historical null_between: beat historical, BA difference","code":"true_hr_vs_hist = c(A = 1.0, B = 1.0) true_hr_between = 1.0 true_hr_vs_hist = c(A = 0.8, B = 0.8) true_hr_between = 1.0"},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_82-alternative-scenarios-power","dir":"","previous_headings":"8. Calibration Scenarios","what":"8.2 Alternative Scenarios (Power)","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"alt_both_different: better B, beat historical alt_strong_difference: Strong BA difference","code":"true_hr_vs_hist = c(A = 0.67, B = 0.89) true_hr_between = 0.75 true_hr_vs_hist = c(A = 0.6, B = 1.0) true_hr_between = 0.6"},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_83-edge-cases","dir":"","previous_headings":"8. Calibration Scenarios","what":"8.3 Edge Cases","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"one_arm_futile: One arm futile","code":"true_hr_vs_hist = c(A = 0.67, B = 1.2) true_hr_between = 0.55"},{"path":[]},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_91-objective-function","dir":"","previous_headings":"9. BATON Integration","what":"9.1 Objective Function","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"Rationale: Penalize unnecessary conversions SA succeeds BA shouldn’t.","code":"objective = EN_total + conversion_penalty_weight × P_conversion_under_null_between"},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_92-constraints","dir":"","previous_headings":"9. BATON Integration","what":"9.2 Constraints","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"","code":"constraints <- list(   power = c(\"ge\", 0.80),   type1 = c(\"le\", 0.10),   type1_between = c(\"le\", 0.05),   P_conversion = c(\"ge\", 0.10),   P_eff_sa = c(\"le\", 0.40) )"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_111-unit-tests","dir":"","previous_headings":"11. Validation Strategy","what":"11.1 Unit Tests","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"Closed-form F-distribution matches MC exponential case State transitions occur correctly PP increases sample size PP approaches 1 true effect large PP approaches 0 true effect null","code":""},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_112-regression-tests","dir":"","previous_headings":"11. Validation Strategy","what":"11.2 Regression Tests","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"Hybrid pp_go=1.0 matches pure SA design Hybrid instant conversion matches pure BA design Type error controlled across scenarios","code":""},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_113-integration-tests","dir":"","previous_headings":"11. Validation Strategy","what":"11.3 Integration Tests","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"Full BO calibration completes without errors CSV loading wrapper creation work correctly Parallel execution produces consistent results","code":""},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_12-recommended-defaults-for-adapt","dir":"","previous_headings":"","what":"12. Recommended Defaults for ADAPT","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"ARPA-H ADAPT breast cancer platform trial: SSR method: Predictive probability Conversion trigger: any_single_success Thresholds: pp_go=0.70, pp_nogo=0.20 Futility action: drop_arm P_conversion constraint: >= 0.10 HR threshold: 0.80 (20% improvement)","code":""},{"path":[]},{"path":[]},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_132-key-functions-implemented","dir":"","previous_headings":"13. Implementation Status","what":"13.2 Key Functions Implemented","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"evolveTrial Package: - create_hybrid_theta() - Parameter structure validation - create_hybrid_state() - State initialization registries - update_hybrid_state() - Main state machine driver - handle_state_single() - SA phase logic - handle_state_consider_conversion() - PP evaluation - handle_state_between() - BA phase logic - compute_pp_curve_predictive() - Full Monte Carlo PP - compute_pp_curve_posterior() - Fast analytical PP - evaluate_sa_efficacy() - SA efficacy decision - evaluate_sa_futility() - SA futility decision - evaluate_conversion_trigger() - Trigger evaluation - evaluate_ba_efficacy() - BA efficacy decision - apply_futility_action() - Futility handling - validate_exponential_ba() - Closed-form validation - compile_hybrid_results() - Result compilation BATON Integration: - create_hybrid_wrapper_simple() - CSV-based wrapper factory - get_hybrid_bounds() - Parameter bounds stage - get_hybrid_constraints() - OC constraints - get_hybrid_calibration_scenarios() - 5 calibration scenarios - aggregate_hybrid_results() - Multi-scenario aggregation - compute_hybrid_objective() - Objective conversion penalty","code":""},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_133-usage","dir":"","previous_headings":"13. Implementation Status","what":"13.3 Usage","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"Run unit tests: Run integration test: Run production calibration: Dry run (validate scenarios):","code":"cd evolveTrial Rscript -e \"testthat::test_file('tests/testthat/test-hybrid-simulator.R')\" cd adaptive-trial-bo-paper Rscript scripts/test_hybrid_integration.R cd adaptive-trial-bo-paper Rscript scripts/run_warmstart_scenarios.R \\   scenarios/cohortB_hybrid_production.csv \\   --filter-ids cohortB_hybrid_optimal Rscript scripts/run_warmstart_scenarios.R \\   scenarios/cohortB_hybrid_production.csv \\   --dry-run"},{"path":"/HYBRID_DESIGN_SPECIFICATION.html","id":"id_134-production-csv-scenarios","dir":"","previous_headings":"13. Implementation Status","what":"13.4 Production CSV Scenarios","title":"Hybrid Single-Arm to Multi-Arm Bayesian Adaptive Trial Design Specification","text":"Document maintained : evolveTrial development team Last updated: 2025-12-20","code":""},{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 Naim Rashid Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":null,"dir":"","previous_headings":"","what":"evolveTrial Percentile Enhancement Specification","title":"evolveTrial Percentile Enhancement Specification","text":"STATUS: ✅ IMPLEMENTED (2025-12-07)","code":""},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"evolveTrial Percentile Enhancement Specification","text":"document specifies add exact sample size percentile calculation run_simulation_pure() minimal computational overhead. implementation completed following specification. Key functions modified: - run_simulation_pure() - Added return_percentiles percentile_probs parameters - run_scenarios() - Added pass-support percentile parameters","code":""},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"problem-statement","dir":"","previous_headings":"","what":"Problem Statement","title":"evolveTrial Percentile Enhancement Specification","text":"Currently, evolveTrial returns aggregate statistics (mean EN, power, type error). statistical SAP sections, need distribution sample sizes across simulations, specifically: - Min, 25th percentile, Median, 75th percentile, 90th percentile, Max","code":""},{"path":[]},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"option-a-accumulate-raw-values-recommended","dir":"","previous_headings":"Design Decision: Accumulate Raw Values vs Online Quantile Estimation","what":"Option A: Accumulate Raw Values (Recommended)","title":"evolveTrial Percentile Enhancement Specification","text":"Store per-replicate sample sizes vector, compute percentiles end. Memory cost: ~8 bytes × n_reps × n_arms = ~80KB 10,000 reps × 1 arm Pros: - Exact percentiles - Simple implementation - Memory cost trivial typical use cases (10K-50K reps) - Supports arbitrary percentile queries post-hoc Cons: - Memory scales n_reps (negligible)","code":""},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"option-b-online-quantile-estimation-p²-algorithm","dir":"","previous_headings":"Design Decision: Accumulate Raw Values vs Online Quantile Estimation","what":"Option B: Online Quantile Estimation (P² Algorithm)","title":"evolveTrial Percentile Enhancement Specification","text":"Estimate quantiles incrementally without storing values. Memory cost: O(1) per tracked percentile Pros: - Constant memory regardless n_reps Cons: - Approximate, exact - complex implementation - Fixed percentiles must chosen upfront - P² can accuracy issues heavy-tailed distributions","code":""},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"recommendation","dir":"","previous_headings":"Design Decision: Accumulate Raw Values vs Online Quantile Estimation","what":"Recommendation","title":"evolveTrial Percentile Enhancement Specification","text":"Use Option (accumulate raw values). memory overhead negligible (<1MB even 100K reps), get exact results simple implementation.","code":""},{"path":[]},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"id_1-add-new-parameter-to-run_simulation_pure","dir":"","previous_headings":"Implementation Plan","what":"1. Add New Parameter to run_simulation_pure()","title":"evolveTrial Percentile Enhancement Specification","text":"","code":"run_simulation_pure <- function(     num_simulations,     # ... existing params ...     return_percentiles = FALSE,  # NEW: Return sample size percentiles     percentile_probs = c(0, 0.25, 0.5, 0.75, 0.9, 1.0),  # NEW: Which percentiles to compute     # ... )"},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"id_2-initialize-storage-only-when-return_percentiles--true","dir":"","previous_headings":"Implementation Plan","what":"2. Initialize Storage (only when return_percentiles = TRUE)","title":"evolveTrial Percentile Enhancement Specification","text":"existing initialization (around line 430):","code":"# Percentile tracking (when enabled) if (isTRUE(return_percentiles)) {   # Pre-allocate vectors for all replicates   all_final_n <- vector(\"list\", length(arm_names))   names(all_final_n) <- arm_names   for (arm in arm_names) {     all_final_n[[arm]] <- numeric(num_simulations)   } }"},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"id_3-modify-simulate_chunk-to-return-raw-values","dir":"","previous_headings":"Implementation Plan","what":"3. Modify simulate_chunk() to Return Raw Values","title":"evolveTrial Percentile Enhancement Specification","text":"simulate_chunk(), add collection per-replicate values enabled:","code":"simulate_chunk <- function(sim_indices, seed = NULL, tick = function() {}) {   # ... existing code ...    # NEW: Track per-replicate sample sizes for percentiles   chunk_final_n_raw <- if (collect_raw) {     lapply(arm_names, function(arm) numeric(length(sim_indices)))   } else NULL   if (!is.null(chunk_final_n_raw)) names(chunk_final_n_raw) <- arm_names    for (i in seq_along(sim_indices)) {     # ... existing simulation code ...      # After computing final_n_vec (around line 626):     chunk_sum_final_n <- chunk_sum_final_n + final_n_vec      # NEW: Store raw values for percentile calculation     if (!is.null(chunk_final_n_raw)) {       for (arm in arm_names) {         chunk_final_n_raw[[arm]][i] <- final_n_vec[arm]       }     }      # ... rest of loop ...   }    # Return structure (around line 637):   list(     sum_final_n = chunk_sum_final_n,     # ... existing fields ...     final_n_raw = chunk_final_n_raw  # NEW (NULL if not collecting)   ) }"},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"id_4-modify-aggregate_results-to-combine-raw-vectors","dir":"","previous_headings":"Implementation Plan","what":"4. Modify aggregate_results() to Combine Raw Vectors","title":"evolveTrial Percentile Enhancement Specification","text":"","code":"aggregate_results <- function(partials) {   # ... existing aggregation ...    # NEW: Combine raw vectors across chunks   if (!is.null(partials[[1]]$final_n_raw)) {     for (arm in arm_names) {       all_final_n[[arm]] <<- unlist(lapply(partials, function(p) p$final_n_raw[[arm]]))     }   } }"},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"id_5-compute-and-return-percentiles","dir":"","previous_headings":"Implementation Plan","what":"5. Compute and Return Percentiles","title":"evolveTrial Percentile Enhancement Specification","text":"aggregate_results() call (around line 775), add percentile computation:","code":"# Compute percentiles if requested percentiles_result <- NULL if (isTRUE(return_percentiles) && !is.null(all_final_n)) {   percentiles_result <- lapply(arm_names, function(arm) {     quantile(all_final_n[[arm]], probs = percentile_probs, na.rm = TRUE)   })   names(percentiles_result) <- arm_names }  # Modify return (around line 798) if (isTRUE(return_percentiles)) {   return(list(     summary = results_data,     percentiles = list(       N = percentiles_result,       probs = percentile_probs     )   )) } else {   return(results_data) }"},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"id_6-update-run_scenarios-to-support-percentiles","dir":"","previous_headings":"Implementation Plan","what":"6. Update run_scenarios() to Support Percentiles","title":"evolveTrial Percentile Enhancement Specification","text":"run_scenarios(), pass percentile parameters:","code":"run_scenarios <- function(base_args, scens, parallel = FALSE, seed = NULL,                           return_percentiles = FALSE,                           percentile_probs = c(0, 0.25, 0.5, 0.75, 0.9, 1.0)) {   # ... existing code ...    for (i in seq_along(scens)) {     args_i <- modifyList(base_args, scens[[i]])     args_i$return_percentiles <- return_percentiles     args_i$percentile_probs <- percentile_probs      res <- do.call(run_simulation_pure, args_i)      if (return_percentiles) {       all_results[[i]] <- res$summary       all_percentiles[[i]] <- res$percentiles     } else {       all_results[[i]] <- res     }   }    # Return   if (return_percentiles) {     list(       summary = do.call(rbind, all_results),       percentiles = all_percentiles     )   } else {     do.call(rbind, all_results)   } }"},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"usage-example","dir":"","previous_headings":"","what":"Usage Example","title":"evolveTrial Percentile Enhancement Specification","text":"","code":"# Run with percentile collection result <- run_simulation_pure(   num_simulations = 10000,   # ... other params ...   return_percentiles = TRUE,   percentile_probs = c(0, 0.25, 0.5, 0.75, 0.9, 1.0) )  # Access results summary_df <- result$summary  # Same as before percentiles <- result$percentiles$N  # List by arm  # For single-arm: # percentiles$Experimental gives: c(min, 25th, median, 75th, 90th, max)"},{"path":[]},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"memory","dir":"","previous_headings":"Performance Impact","what":"Memory","title":"evolveTrial Percentile Enhancement Specification","text":"10,000 reps × 1 arm: ~80 KB 10,000 reps × 3 arms: ~240 KB 100,000 reps × 3 arms: ~2.4 MB negligible compared simulation state memory.","code":""},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"cpu","dir":"","previous_headings":"Performance Impact","what":"CPU","title":"evolveTrial Percentile Enhancement Specification","text":"Storage: One assignment per replicate per arm (~negligible) Percentile computation: O(n log n) sorting, done end 10,000 reps: <10ms additional time","code":""},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"backward-compatibility","dir":"","previous_headings":"Performance Impact","what":"Backward Compatibility","title":"evolveTrial Percentile Enhancement Specification","text":"return_percentiles = FALSE (default), behavior identical current version Return type changes return_percentiles = TRUE","code":""},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"testing","dir":"","previous_headings":"","what":"Testing","title":"evolveTrial Percentile Enhancement Specification","text":"Add tests verify: 1. Percentiles correct (compare known distributions) 2. Means computed raw values match Exp_N 3. Parallel sequential modes give consistent results 4. Default behavior unchanged","code":""},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"files-to-modify","dir":"","previous_headings":"","what":"Files to Modify","title":"evolveTrial Percentile Enhancement Specification","text":"R/simulation_driver.R - Main changes run_simulation_pure() R/design_analysis.R - Update run_scenarios() wrapper man/run_simulation_pure.Rd - Document new parameters tests/testthat/test_percentiles.R - New test file","code":""},{"path":"/PERCENTILE_ENHANCEMENT_SPEC.html","id":"estimated-effort","dir":"","previous_headings":"","what":"Estimated Effort","title":"evolveTrial Percentile Enhancement Specification","text":"Implementation: 2-3 hours Testing: 1-2 hours Documentation: 30 minutes Total: ~4-5 hours","code":""},{"path":"/PROFILING_RESULTS.html","id":null,"dir":"","previous_headings":"","what":"evolveTrial Profiling Results","title":"evolveTrial Profiling Results","text":"Date: 2025-12-03 Profiler: R Rprof (sequential execution visibility)","code":""},{"path":"/PROFILING_RESULTS.html","id":"executive-summary","dir":"","previous_headings":"","what":"Executive Summary","title":"evolveTrial Profiling Results","text":"Profiling reveals main bottleneck evolveTrial PSOCK cluster spawn/teardown overhead, simulation logic . call run_simulation_pure() parallel_replicates = TRUE creates destroys parallel cluster, adds significant overhead called repeatedly (e.g., Bayesian optimization loops).","code":""},{"path":[]},{"path":[]},{"path":"/PROFILING_RESULTS.html","id":"id_1-psock-cluster-spawnteardown-critical","dir":"","previous_headings":"Identified Bottlenecks","what":"1. PSOCK Cluster Spawn/Teardown (CRITICAL)","title":"evolveTrial Profiling Results","text":"Location: R/simulation_driver.R lines 689-705 Impact: - BO evaluation creates/destroys cluster - Worker processes must load evolveTrial package time - PSOCK requires full R process spawn + socket communication","code":"cl <- parallel::makeCluster(workers, type = cluster_type) on.exit(parallel::stopCluster(cl), add = TRUE) parallel::clusterCall(cl, function(pkg) {   suppressPackageStartupMessages(require(pkg, character.only = TRUE)) }, pkg_name)"},{"path":"/PROFILING_RESULTS.html","id":"id_2-jit-compilation-overhead","dir":"","previous_headings":"Identified Bottlenecks","what":"2. JIT Compilation Overhead","title":"evolveTrial Profiling Results","text":"Location: Throughout R code Profile evidence: - h, tryInline, cmpCall, cmp, genCode, cmpfun top functions - findCenvVar, cb$makelabel, putconst show compiler activity Impact: - Functions recompiled worker process - caching compiled bytecode across calls","code":""},{"path":"/PROFILING_RESULTS.html","id":"id_3-invisible-worker-time","dir":"","previous_headings":"Identified Bottlenecks","what":"3. Invisible Worker Time","title":"evolveTrial Profiling Results","text":"Issue: Rprof runs parent process; PSOCK workers separate R processes Result: - 40.59 sec total, 0.08 sec visible profiler - directly profile happens inside simulate_chunk()","code":""},{"path":[]},{"path":[]},{"path":"/PROFILING_RESULTS.html","id":"id_1-implement-cluster-pooling","dir":"","previous_headings":"Optimization Recommendations > High Priority (Large Impact)","what":"1. Implement Cluster Pooling","title":"evolveTrial Profiling Results","text":"Add option reuse persistent cluster across multiple BO evaluations: Expected improvement: 10-50x faster repeated calls","code":"# New API option run_simulation_pure(..., cluster = NULL)  # If NULL, use internal pooling  # Usage pattern cl <- evolveTrial::get_cluster(workers = 8)  # Create once for (i in 1:100) {   run_simulation_pure(..., cluster = cl)  # Reuse } evolveTrial::release_cluster(cl)  # Cleanup"},{"path":"/PROFILING_RESULTS.html","id":"id_2-use-fork-instead-of-psock-on-linux","dir":"","previous_headings":"Optimization Recommendations > High Priority (Large Impact)","what":"2. Use FORK Instead of PSOCK on Linux","title":"evolveTrial Profiling Results","text":"FORK clusters share memory don’t require serialization: Benefits: - package loading workers (inherited) - data serialization (copy--write) - Much faster startup Expected improvement: 2-5x Linux/macOS","code":"cluster_type <- if (.Platform$OS.type == \"unix\") \"FORK\" else \"PSOCK\""},{"path":"/PROFILING_RESULTS.html","id":"id_3-threshold-for-sequential-execution","dir":"","previous_headings":"Optimization Recommendations > High Priority (Large Impact)","what":"3. Threshold for Sequential Execution","title":"evolveTrial Profiling Results","text":"small rep counts, sequential faster parallel overhead:","code":"# Rule of thumb: parallel_replicates makes sense only if: # num_simulations * time_per_rep > cluster_overhead (typically 5-10 sec) if (num_simulations < 50) {   parallel_replicates <- FALSE }"},{"path":[]},{"path":"/PROFILING_RESULTS.html","id":"id_4-pre-compile-critical-functions","dir":"","previous_headings":"Optimization Recommendations > Medium Priority","what":"4. Pre-compile Critical Functions","title":"evolveTrial Profiling Results","text":"Add package .onLoad():","code":".onLoad <- function(libname, pkgname) {   # Pre-compile hot path functions   assign(\"simulate_chunk\", compiler::cmpfun(simulate_chunk), envir = parent.env(environment()))   assign(\"interim_check\", compiler::cmpfun(interim_check), envir = parent.env(environment()))   # etc. }"},{"path":"/PROFILING_RESULTS.html","id":"id_5-export-cluster-for-external-use","dir":"","previous_headings":"Optimization Recommendations > Medium Priority","what":"5. Export Cluster for External Use","title":"evolveTrial Profiling Results","text":"Allow BO packages manage cluster lifecycle:","code":"#' Create a reusable evolveTrial cluster #' @export create_simulation_cluster <- function(workers = NULL, cluster_type = \"auto\") {   workers <- workers %||% max(1L, parallel::detectCores() - 1L)   if (cluster_type == \"auto\") {     cluster_type <- if (.Platform$OS.type == \"unix\") \"FORK\" else \"PSOCK\"   }   cl <- parallel::makeCluster(workers, type = cluster_type)   parallel::clusterEvalQ(cl, library(evolveTrial))   class(cl) <- c(\"evolveTrial_cluster\", class(cl))   cl }"},{"path":[]},{"path":"/PROFILING_RESULTS.html","id":"id_6-internal-simulation-optimization","dir":"","previous_headings":"Optimization Recommendations > Low Priority","what":"6. Internal Simulation Optimization","title":"evolveTrial Profiling Results","text":"simulate_chunk() function appears efficient (~1.2 ms/rep run sequentially). C++ implementations posterior sampling already place. Potential micro-optimizations: - Vectorize patient enrollment loop - Pre-allocate result matrices - Use integer arithmetic possible","code":""},{"path":"/PROFILING_RESULTS.html","id":"implemented-optimizations-2025-12-03","dir":"","previous_headings":"","what":"Implemented Optimizations (2025-12-03)","title":"evolveTrial Profiling Results","text":"three high-priority optimizations implemented R/simulation_driver.R:","code":""},{"path":"/PROFILING_RESULTS.html","id":"id_1-cluster-pooling-","dir":"","previous_headings":"Implemented Optimizations (2025-12-03)","what":"1. Cluster Pooling ✅","title":"evolveTrial Profiling Results","text":"New parameter cluster added run_simulation_pure() accept external cluster: New exported functions: - create_simulation_cluster(workers, cluster_type) - Create reusable cluster - release_cluster(cluster) - Clean cluster resources","code":"# Create cluster once for all BO evaluations cl <- evolveTrial::create_simulation_cluster(workers = 8)  # Use in repeated BO evaluations (100+ calls) for (i in 1:100) {   result <- run_simulation_pure(     num_simulations = 500,     ...,     parallel_replicates = TRUE,     cluster = cl  # Reuses cluster, no spawn/teardown overhead   ) }  # Clean up when done evolveTrial::release_cluster(cl)"},{"path":"/PROFILING_RESULTS.html","id":"id_2-fork-auto-detection-","dir":"","previous_headings":"Implemented Optimizations (2025-12-03)","what":"2. FORK Auto-Detection ✅","title":"evolveTrial Profiling Results","text":"Default cluster_type changed \"PSOCK\" \"auto\": Benefits Linux/macOS: - FORK inherits parent environment (package loading workers) - Copy--write memory (serialization overhead) - ~2-5x faster cluster startup","code":"# Auto-detection logic (in simulation_driver.R) if (cluster_type == \"auto\") {   cluster_type <- if (.Platform$OS.type == \"unix\") \"FORK\" else \"PSOCK\" }"},{"path":"/PROFILING_RESULTS.html","id":"id_3-sequential-threshold-","dir":"","previous_headings":"Implemented Optimizations (2025-12-03)","what":"3. Sequential Threshold ✅","title":"evolveTrial Profiling Results","text":"Increased threshold workers * 2 100 (configurable): Rationale: - Cluster spawn/teardown: ~5-10 sec - Sequential simulation: ~1-2 ms/rep - Breakeven ~100 reps typical config Configuration:","code":"# Threshold is configurable via option seq_threshold <- getOption(\"evolveTrial.sequential_threshold\", 100L)  if (num_simulations < seq_threshold) {   # Run sequentially - faster than parallel overhead   chunk_results <- list(simulate_chunk(...)) } # Lower threshold for fast machines options(evolveTrial.sequential_threshold = 50)  # Higher threshold if cluster overhead is high options(evolveTrial.sequential_threshold = 200)"},{"path":[]},{"path":"/PROFILING_RESULTS.html","id":"api-changes-summary","dir":"","previous_headings":"Implemented Optimizations (2025-12-03)","what":"API Changes Summary","title":"evolveTrial Profiling Results","text":"New parameters run_simulation_pure(): - cluster_type = c(\"auto\", \"PSOCK\", \"FORK\") - Default changed “auto” - cluster = NULL - Pass external cluster pooling New exported functions: - create_simulation_cluster() - Create persistent cluster - release_cluster() - Clean cluster New option: - evolveTrial.sequential_threshold - Override default threshold (100)","code":""},{"path":"/PROFILING_RESULTS.html","id":"files-created","dir":"","previous_headings":"","what":"Files Created","title":"evolveTrial Profiling Results","text":"tests/profile_sequential.R - Sequential profiling script PROFILING_RESULTS.md - document","code":""},{"path":"/PROFILING_RESULTS.html","id":"verification","dir":"","previous_headings":"","what":"Verification","title":"evolveTrial Profiling Results","text":"reproduce profiling: compare parallel (paper directory):","code":"cd /home/naimrashid/Downloads/evolveTrial Rscript tests/profile_sequential.R cd /home/naimrashid/Downloads/adaptive-trial-bo-paper Rscript scripts/profile_comprehensive.R"},{"path":"/REPORT_OF_BUGS.html","id":"identified-bugs","dir":"","previous_headings":"","what":"Identified Bugs","title":"NA","text":"Based examination commit 011a5d38616f3e24e75e5c8dd1f9c8863b8f5141 (“perf: C++ matrix median control arm posterior caching”), following potential bugs identified:","code":""},{"path":"/REPORT_OF_BUGS.html","id":"bug-1-inconsistency-in-interval_lengths-handling-for-ctrl_cache","dir":"","previous_headings":"Identified Bugs","what":"Bug 1: Inconsistency in interval_lengths handling for ctrl_cache","title":"NA","text":"Files Affected: * R/posterior_helpers.R * R/interim_logic.R Description: precompute_ctrl_posteriors function R/posterior_helpers.R calculates interval_lengths includes returned ctrl_cache list. cache passed sample_vs_ref_medians_independent (via sample_vs_ref_medians). However, within sample_vs_ref_medians_independent, interval_lengths recalculated beginning function using diff(args$interval_cutpoints_sim), even ctrl_cache provided. ctrl_cache$interval_lengths value, available, never used. re-calculated interval_lengths subsequently used median survival calculations (med_ctrl med_trt). Impact: args$interval_cutpoints_sim might constant within single simulation run, creates logical inconsistency. 1. Redundancy: Caching interval_lengths precompute_ctrl_posteriors becomes redundant. 2. Potential Error: , future scenario, args$interval_cutpoints_sim mutated interpreted differently time caching use, discrepancy lead incorrect median survival calculations erroneous trial results. subtle bug manifest specific, hard--debug conditions. Severity: Medium (Potential subtle, hard--trace errors; best, inefficient redundant caching). Proposed Fix (Conceptual): Modify sample_vs_ref_medians_independent conditionally use ctrl_cache$interval_lengths ctrl_cache provided, instead always recalculating .","code":"# In R/posterior_helpers.R, inside sample_vs_ref_medians_independent:  sample_vs_ref_medians_independent <- function(slCtrl, slTrt, args, num_samples,                                                ctrl_cache = NULL) {   # Determine interval_lengths: use cached if available, otherwise calculate   if (!is.null(ctrl_cache)) {     interval_lengths <- ctrl_cache$interval_lengths # Use cached value   } else {     interval_lengths <- diff(args$interval_cutpoints_sim) # Calculate if not cached   }    # ... rest of the function remains the same, using the determined interval_lengths }"},{"path":"/REPORT_OF_BUGS.html","id":"bug-2-potential-edge-case-differences-between-r-and-c-median-survival-calculations","dir":"","previous_headings":"Identified Bugs","what":"Bug 2: Potential edge case differences between R and C++ median survival calculations","title":"NA","text":"Files Affected: * R/posterior_helpers.R * R/interim_logic.R * R/predictive_probabilities.R * R/simulation_driver.R * R/posterior_cpp_dispatchers.R * (Potentially src/posterior_sampling.cpp similar C++ file, contains calculate_median_survival_matrix_cpp) Description: performance optimization commit (011a5d38616f3e24e75e5c8dd1f9c8863b8f5141) replaced multiple instances R’s apply(..., calculate_median_survival_piecewise, ...) direct calls C++ function calculate_median_survival_matrix_cpp. intended significant performance gains, transitioning core numerical calculations R C++ often introduces subtle discrepancies. Impact: C++ implementations, even designed replicate R logic, can sometimes exhibit different behaviors edge cases : * Handling NA/NaN/Inf values: R specific ways propagating handling ; C++ might require explicit checks. * Floating-point precision: Differences compiler optimizations default floating-point types might lead minor numerical discrepancies, especially small large numbers, many iterations. * Implicit Type Coercion: R’s type coercion rules complex; C++ stricter. * Input Validation: C++ function might different assumptions input dimensions, types, valid ranges R function replaces. differences lead subtle numerical deviations median survival times, affecting accuracy simulation results specific, potentially rare, input conditions. Without direct access comparison source code calculate_median_survival_piecewise (R) calculate_median_survival_matrix_cpp (C++), comprehensive comparative unit tests, difficult guarantee exact equivalence across possible scenarios. Severity: High (bug impacts core statistical calculations, potentially undermining validity simulation results. subtle nature makes hard detect without dedicated testing code review.) Verification/Mitigation: verify mitigate potential bug, following steps necessary: 1. Code Review: Thoroughly compare R source code calculate_median_survival_piecewise C++ source code calculate_median_survival_matrix_cpp (likely src/posterior_sampling.cpp related C++ file). 2. Comparative Unit Testing: Develop comprehensive suite unit tests generate various inputs (including edge cases like zero hazards, long intervals, short intervals, NA values hazard rates, etc.) run R C++ implementations, comparing outputs exact equivalence acceptable numerical tolerance. 3. Integration Testing: Ensure C++ function integrates seamlessly R ecosystem without unexpected side effects.","code":""},{"path":"/REPORT_OF_BUGS.html","id":"analysis-of-commit-bbc9032280efb1152e4372a4efc552a94ffb344b-update","dir":"","previous_headings":"Identified Bugs","what":"Analysis of Commit: bbc9032280efb1152e4372a4efc552a94ffb344b (“update”)","title":"NA","text":"Status: bugs found. (Commit fix).","code":""},{"path":"/REPORT_OF_BUGS.html","id":"analysis-of-commit-52d3b8585d99dac61063e3e0ccee3c88c2cb491b-update","dir":"","previous_headings":"Identified Bugs","what":"Analysis of Commit: 52d3b8585d99dac61063e3e0ccee3c88c2cb491b (“update”)","title":"NA","text":"Status: bugs found. (Implemented “Expected Events” tracking correctly).","code":""},{"path":"/REPORT_OF_BUGS.html","id":"analysis-of-commit-ee292d60c82df4259b3920dd90c874466645d72c-update","dir":"","previous_headings":"Identified Bugs","what":"Analysis of Commit: ee292d60c82df4259b3920dd90c874466645d72c (“update”)","title":"NA","text":"Status: bugs found. (Configuration change: .Rprofile.disabled).","code":""},{"path":"/REPORT_OF_BUGS.html","id":"analysis-of-commit-ab59ae17306185f1e84345de598878bf356169b3-update","dir":"","previous_headings":"Identified Bugs","what":"Analysis of Commit: ab59ae17306185f1e84345de598878bf356169b3 (“update”)","title":"NA","text":"Status: bugs found. (Added binary GPG key).","code":""},{"path":"/REPORT_OF_BUGS.html","id":"analysis-of-commit-aa22a4f8ae5bc4a709117b3ffb3e5d4e40176dcd-feat-perform-comprehensive-code-review","dir":"","previous_headings":"Identified Bugs","what":"Analysis of Commit: aa22a4f8ae5bc4a709117b3ffb3e5d4e40176dcd (“feat: Perform comprehensive code review…”)","title":"NA","text":"Overview: major refactoring commit harmonized parameter names, split interim_check function, cleaned state_management.R. Findings: * Code Safety: commit introduces stricter requirements args$max_total_patients_per_arm (must named vector) gates_pass_for_both_arms. robust improvement. * Logic Correctness: interim_check_vs_ref function correctly constructs two-arm context (args_gate$arm_names) calling gate checking helper. prevents ambiguity multi-arm trials. * Parameter Handling: Deprecated parameters correctly mapped new harmonized equivalents warnings, ensuring backward compatibility encouraging migration. * Conclusion: bugs found. refactoring appears careful structurally sound.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Naim Rashid. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Rashid N (2025). evolveTrial: Adaptive Clinical Trial Utilities. R package version 0.0.0.9000.","code":"@Manual{,   title = {evolveTrial: Adaptive Clinical Trial Utilities},   author = {Naim Rashid},   year = {2025},   note = {R package version 0.0.0.9000}, }"},{"path":[]},{"path":"/hybrid_suggestions.html","id":"table-of-contents","dir":"","previous_headings":"","what":"Table of Contents","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"Design Overview Mathematical Framework Decision Rules State Machine Architecture Predictive Probability Engine Software Architecture BATON Calibration Implementation Phases Testing Strategy","code":""},{"path":[]},{"path":"/hybrid_suggestions.html","id":"id_11-motivation","dir":"","previous_headings":"1. Design Overview","what":"1.1 Motivation","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"resource-constrained settings, investigators often prefer within-arm comparisons historical controls require fewer samples complete quickly -arm comparisons. However, -arm comparisons provide stronger evidence. hybrid design allows: Initial phase: Monitor arm historical benchmark (single-arm view) simultaneously tracking -arm contrasts Transition decision: single-arm efficacy established, use accumulated data determine whether extending powered -arm comparison worthwhile Extension phase: warranted, continue enrollment complete -arm comparison","code":""},{"path":[]},{"path":"/hybrid_suggestions.html","id":"id_13-trial-flow","dir":"","previous_headings":"1. Design Overview","what":"1.3 Trial Flow","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"","code":"┌─────────────────────────────────────────────────────────────────────────────┐ │                              TRIAL FLOW                                      │ ├─────────────────────────────────────────────────────────────────────────────┤ │                                                                              │ │  ┌─────────────┐                                                             │ │  │ Trial Start │                                                             │ │  └──────┬──────┘                                                             │ │         │                                                                    │ │         ▼                                                                    │ │  ┌─────────────────────────────────────────────────────────────────────┐    │ │  │                     STATE: SINGLE-ARM PHASE                          │    │ │  │                                                                       │    │ │  │  • Randomize patients to arms A, B, ... (equal or RAR)               │    │ │  │  • At each interim, compute:                                          │    │ │  │      - P(HR_k^hist < c_k | data) for each arm k                      │    │ │  │      - P(HR_AB < 1 | data) [passive monitoring]                      │    │ │  │  • Apply single-arm efficacy/futility rules                          │    │ │  │                                                                       │    │ │  └─────────────────────────┬───────────────────────────────────────────┘    │ │                            │                                                 │ │         ┌──────────────────┼──────────────────┐                             │ │         │                  │                  │                             │ │         ▼                  ▼                  ▼                             │ │  ┌─────────────┐   ┌─────────────┐   ┌─────────────────────────────────┐   │ │  │All arms fail│   │ Max N with  │   │  Single-arm efficacy trigger    │   │ │  │  futility   │   │  no trigger │   │  (e.g., any arm succeeds)       │   │ │  └──────┬──────┘   └──────┬──────┘   └───────────────┬─────────────────┘   │ │         │                 │                          │                      │ │         ▼                 ▼                          ▼                      │ │  ┌─────────────────────────────┐   ┌─────────────────────────────────────┐ │ │  │    STATE: STOP (futility)   │   │   STATE: CONSIDER CONVERSION        │ │ │  │    No efficacy claims       │   │                                      │ │ │  └─────────────────────────────┘   │   • Compute π_pred(N_add) for       │ │ │                                     │     candidate additional sample     │ │ │                                     │     sizes                           │ │ │                                     │   • Determine go/no-go              │ │ │                                     └───────────────┬─────────────────────┘ │ │                                                     │                       │ │                              ┌──────────────────────┴────────────────┐      │ │                              │                                       │      │ │                              ▼                                       ▼      │ │               ┌───────────────────────────┐      ┌────────────────────────┐│ │               │  π_pred < pp_nogo         │      │  π_pred ≥ pp_go        ││ │               │  (not worth continuing)   │      │  (worth continuing)    ││ │               └─────────────┬─────────────┘      └───────────┬────────────┘│ │                             │                                │             │ │                             ▼                                ▼             │ │               ┌───────────────────────────┐    ┌─────────────────────────┐ │ │               │  STATE: STOP              │    │  STATE: BETWEEN-ARM     │ │ │               │  Report single-arm        │    │  PHASE                  │ │ │               │  conclusions only         │    │                         │ │ │               └───────────────────────────┘    │  • Continue enrollment  │ │ │                                                │    to selected N_max    │ │ │                                                │  • Monitor between-arm  │ │ │                                                │    efficacy/futility    │ │ │                                                └────────────┬────────────┘ │ │                                                             │              │ │                                                             ▼              │ │                                                ┌─────────────────────────┐ │ │                                                │  STATE: STOP            │ │ │                                                │  Report single-arm AND  │ │ │                                                │  between-arm conclusions│ │ │                                                └─────────────────────────┘ │ └─────────────────────────────────────────────────────────────────────────────┘"},{"path":[]},{"path":[]},{"path":"/hybrid_suggestions.html","id":"id_22-survival-model-exponential-with-gamma-prior","dir":"","previous_headings":"2. Mathematical Framework","what":"2.2 Survival Model: Exponential with Gamma Prior","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"Assumption: Survival times follow exponential distribution arm-specific hazard rates. Tik∣λk∼Exponential(λk)T_{ik} \\mid \\lambda_k \\sim \\text{Exponential}(\\lambda_k) TikT_{ik} survival time patient ii arm kk. Prior: Gamma prior hazard rate (conjugate): λk∼Gamma(a0,b0)\\lambda_k \\sim \\text{Gamma}(a_0, b_0) a0,b0a_0, b_0 typically small (e.g., a0=b0=0.001a_0 = b_0 = 0.001) vague prior. Likelihood: nkn_k events total exposure TkT_k: L(λk∣data)∝λknkexp(−λkTk)L(\\lambda_k \\mid \\text{data}) \\propto \\lambda_k^{n_k} \\exp(-\\lambda_k T_k) Posterior: conjugacy: λk∣data∼Gamma(ak,bk)\\lambda_k \\mid \\text{data} \\sim \\text{Gamma}(a_k, b_k) : - ak=a0+nka_k = a_0 + n_k (shape parameter) - bk=b0+Tkb_k = b_0 + T_k (rate parameter) Sufficient statistics: posterior fully characterized (ak,bk)(a_k, b_k).","code":""},{"path":"/hybrid_suggestions.html","id":"id_23-historical-control-specification","dir":"","previous_headings":"2. Mathematical Framework","what":"2.3 Historical Control Specification","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"historical control hazard λhist,k\\lambda_{\\text{hist},k} fixed constant, typically derived : λhist,k=log(2)mhist,k\\lambda_{\\text{hist},k} = \\frac{\\log(2)}{m_{\\text{hist},k}} mhist,km_{\\text{hist},k} historical median survival time population relevant arm kk. Key point: place prior λhist,k\\lambda_{\\text{hist},k}. enters calculations fixed benchmark.","code":""},{"path":"/hybrid_suggestions.html","id":"id_24-within-arm-comparison-vs-fixed-historical","dir":"","previous_headings":"2. Mathematical Framework","what":"2.4 Within-Arm Comparison (vs Fixed Historical)","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"Hazard ratio: HRk(hist)=λkλhist,k\\text{HR}_k^{(\\text{hist})} = \\frac{\\lambda_k}{\\lambda_{\\text{hist},k}} Decision quantity — probability HR target threshold ckc_k: pksingle=P(HRk(hist)<ck∣data)=P(λk<ck⋅λhist,k∣data)p_k^{\\text{single}} = P\\left(\\text{HR}_k^{(\\text{hist})} < c_k \\mid \\text{data}\\right) = P\\left(\\lambda_k < c_k \\cdot \\lambda_{\\text{hist},k} \\mid \\text{data}\\right) Closed-form computation: Since λk∣data∼Gamma(ak,bk)\\lambda_k \\mid \\text{data} \\sim \\text{Gamma}(a_k, b_k): pksingle=FGamma(ck⋅λhist,k;ak,bk)p_k^{\\text{single}} = F_{\\text{Gamma}}\\left(c_k \\cdot \\lambda_{\\text{hist},k}; a_k, b_k\\right) FGamma(x;,b)F_{\\text{Gamma}}(x; , b) CDF Gamma distribution shape aa rate bb. R:","code":"p_single <- pgamma(c_k * lambda_hist_k, shape = a_k, rate = b_k)"},{"path":"/hybrid_suggestions.html","id":"id_25-between-arm-comparison","dir":"","previous_headings":"2. Mathematical Framework","what":"2.5 Between-Arm Comparison","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"Hazard ratio arms jj ll: HRjl=λjλl\\text{HR}_{jl} = \\frac{\\lambda_j}{\\lambda_l} Decision quantity: pjlbetween=P(HRjl<1∣data)=P(λjλl<1∣data)p_{jl}^{\\text{}} = P\\left(\\text{HR}_{jl} < 1 \\mid \\text{data}\\right) = P\\left(\\frac{\\lambda_j}{\\lambda_l} < 1 \\mid \\text{data}\\right) Distribution ratio: λj∼Gamma(aj,bj)\\lambda_j \\sim \\text{Gamma}(a_j, b_j) λl∼Gamma(al,bl)\\lambda_l \\sim \\text{Gamma}(a_l, b_l) independently, : λj/bjλl/bl∼BetaPrime(aj,al)\\frac{\\lambda_j / b_j}{\\lambda_l / b_l} \\sim \\text{BetaPrime}(a_j, a_l) equivalently, using F-distribution relationship: alaj⋅bjbl⋅λjλl∼F(2aj,2al)\\frac{a_l}{a_j} \\cdot \\frac{b_j}{b_l} \\cdot \\frac{\\lambda_j}{\\lambda_l} \\sim F(2a_j, 2a_l) Closed-form computation: P(λjλl<c)=FF(c⋅bjbl⋅alaj;2aj,2al)P\\left(\\frac{\\lambda_j}{\\lambda_l} < c\\right) = F_F\\left(c \\cdot \\frac{b_j}{b_l} \\cdot \\frac{a_l}{a_j}; 2a_j, 2a_l\\right) FF(x;d1,d2)F_F(x; d_1, d_2) CDF F-distribution degrees freedom d1d_1 d2d_2. c=1c = 1 (testing whether arm jj superior arm ll): pjlbetween=FF(bjbl⋅alaj;2aj,2al)p_{jl}^{\\text{}} = F_F\\left(\\frac{b_j}{b_l} \\cdot \\frac{a_l}{a_j}; 2a_j, 2a_l\\right) R: general form (HR < c):","code":"p_between <- pf(   q = (b_j / b_l) * (a_l / a_j),   df1 = 2 * a_j,   df2 = 2 * a_l ) compute_p_hr_less_than_c <- function(a_j, b_j, a_l, b_l, c = 1) {   pf(     q = c * (b_j / b_l) * (a_l / a_j),     df1 = 2 * a_j,     df2 = 2 * a_l   ) }"},{"path":[]},{"path":[]},{"path":"/hybrid_suggestions.html","id":"id_31-single-arm-decision-rules","dir":"","previous_headings":"3. Decision Rules","what":"3.1 Single-Arm Decision Rules","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"interim analysis, active arm kk: Efficacy: Arm kk demonstrates efficacy vs historical : pksingle=P(HRk(hist)<ck∣data)>γeffsinglep_k^{\\text{single}} = P\\left(\\text{HR}_k^{(\\text{hist})} < c_k \\mid \\text{data}\\right) > \\gamma_{\\text{eff}}^{\\text{single}} Futility: Arm kk dropped futility : pksingle=P(HRk(hist)<ck∣data)<γfutsinglep_k^{\\text{single}} = P\\left(\\text{HR}_k^{(\\text{hist})} < c_k \\mid \\text{data}\\right) < \\gamma_{\\text{fut}}^{\\text{single}} Typical values: - ck=0.8c_k = 0.8 (target 20% improvement historical) - γeffsingle=0.90\\gamma_{\\text{eff}}^{\\text{single}} = 0.90 (90% posterior probability efficacy) - γfutsingle=0.10\\gamma_{\\text{fut}}^{\\text{single}} = 0.10 (10% posterior probability futility)","code":""},{"path":"/hybrid_suggestions.html","id":"id_32-between-arm-decision-rules","dir":"","previous_headings":"3. Decision Rules","what":"3.2 Between-Arm Decision Rules","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"interim analysis (primarily STATE_BETWEEN, computed throughout): Efficacy: Arm jj superior arm ll : pjlbetween=P(HRjl<1∣data)>γeffbetweenp_{jl}^{\\text{}} = P\\left(\\text{HR}_{jl} < 1 \\mid \\text{data}\\right) > \\gamma_{\\text{eff}}^{\\text{}} Futility: Stop -arm comparison futility : pjlbetween<γfutbetweenp_{jl}^{\\text{}} < \\gamma_{\\text{fut}}^{\\text{}} Typical values: - γeffbetween=0.975\\gamma_{\\text{eff}}^{\\text{}} = 0.975 (stringent confirmatory) - γfutbetween=0.05\\gamma_{\\text{fut}}^{\\text{}} = 0.05","code":""},{"path":"/hybrid_suggestions.html","id":"id_33-transition-trigger-rules","dir":"","previous_headings":"3. Decision Rules","what":"3.3 Transition Trigger Rules","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"trial moves STATE_SINGLE STATE_CONSIDER_CONVERSION trigger condition met. Configurable options:","code":""},{"path":"/hybrid_suggestions.html","id":"id_34-conversion-decision-rules","dir":"","previous_headings":"3. Decision Rules","what":"3.4 Conversion Decision Rules","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"STATE_CONSIDER_CONVERSION, compute predictive probability πpred(Nadd)\\pi_{\\text{pred}}(N_{\\text{add}}) candidate additional sample sizes. Go decision (proceed -arm phase): ∃Nadd∈𝒩candidates:πpred(Nadd)≥πgo\\exists N_{\\text{add}} \\\\mathcal{N}_{\\text{candidates}}: \\pi_{\\text{pred}}(N_{\\text{add}}) \\geq \\pi_{\\text{go}} multiple NaddN_{\\text{add}} satisfy , select smallest. -go decision (stop single-arm conclusions ): maxNadd∈𝒩candidatesπpred(Nadd)<πnogo\\max_{N_{\\text{add}} \\\\mathcal{N}_{\\text{candidates}}} \\pi_{\\text{pred}}(N_{\\text{add}}) < \\pi_{\\text{nogo}} Typical values: - πgo=0.70\\pi_{\\text{go}} = 0.70 (70% chance -arm success proceed) - πnogo=0.20\\pi_{\\text{nogo}} = 0.20 (20% worth continuing) - 𝒩candidates={30,40,50,…,100}\\mathcal{N}_{\\text{candidates}} = \\{30, 40, 50, \\ldots, 100\\} per arm","code":""},{"path":[]},{"path":"/hybrid_suggestions.html","id":"id_41-state-definitions","dir":"","previous_headings":"4. State Machine Architecture","what":"4.1 State Definitions","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"","code":"typedef enum {   STATE_SINGLE,              // Primary monitoring on within-arm comparisons   STATE_CONSIDER_CONVERSION, // Evaluating whether to extend to between-arm   STATE_BETWEEN,             // Full between-arm comparison phase   STATE_STOP                 // Trial complete } TrialState;"},{"path":"/hybrid_suggestions.html","id":"id_42-state-transition-logic","dir":"","previous_headings":"4. State Machine Architecture","what":"4.2 State Transition Logic","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"","code":"┌─────────────────────────────────────────────────────────────────────────────┐ │                        STATE TRANSITION DIAGRAM                              │ ├─────────────────────────────────────────────────────────────────────────────┤ │                                                                              │ │                          ┌─────────────────┐                                │ │                          │  STATE_SINGLE   │                                │ │                          └────────┬────────┘                                │ │                                   │                                         │ │            ┌──────────────────────┼──────────────────────┐                  │ │            │                      │                      │                  │ │            ▼                      ▼                      ▼                  │ │   ┌────────────────┐    ┌────────────────┐    ┌─────────────────────┐      │ │   │ All arms hit   │    │ Max N reached  │    │ Transition trigger  │      │ │   │ futility       │    │ (no trigger)   │    │ met                 │      │ │   └───────┬────────┘    └───────┬────────┘    └──────────┬──────────┘      │ │           │                     │                        │                  │ │           │                     │                        ▼                  │ │           │                     │             ┌─────────────────────────┐   │ │           │                     │             │ STATE_CONSIDER_CONVERSION│   │ │           │                     │             └──────────┬──────────────┘   │ │           │                     │                        │                  │ │           │                     │         ┌──────────────┴──────────────┐   │ │           │                     │         │                             │   │ │           │                     │         ▼                             ▼   │ │           │                     │  ┌─────────────┐              ┌──────────┐│ │           │                     │  │ PP ≥ pp_go  │              │PP < nogo ││ │           │                     │  └──────┬──────┘              └────┬─────┘│ │           │                     │         │                          │      │ │           │                     │         ▼                          │      │ │           │                     │  ┌─────────────────┐               │      │ │           │                     │  │  STATE_BETWEEN  │               │      │ │           │                     │  └────────┬────────┘               │      │ │           │                     │           │                        │      │ │           │                     │    ┌──────┴──────┐                 │      │ │           │                     │    │             │                 │      │ │           │                     │    ▼             ▼                 │      │ │           │                     │ ┌──────┐    ┌────────┐             │      │ │           │                     │ │Eff/  │    │ Max N  │             │      │ │           │                     │ │Fut   │    │reached │             │      │ │           │                     │ └──┬───┘    └───┬────┘             │      │ │           │                     │    │            │                  │      │ │           ▼                     ▼    ▼            ▼                  ▼      │ │        ┌────────────────────────────────────────────────────────────────┐   │ │        │                        STATE_STOP                              │   │ │        │  • Compile final conclusions (single-arm and/or between-arm)   │   │ │        └────────────────────────────────────────────────────────────────┘   │ │                                                                              │ └─────────────────────────────────────────────────────────────────────────────┘"},{"path":"/hybrid_suggestions.html","id":"id_43-pseudo-code-for-state-transitions","dir":"","previous_headings":"4. State Machine Architecture","what":"4.3 Pseudo-code for State Transitions","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"","code":"update_trial_state <- function(trial) {      switch(trial$state,          \"STATE_SINGLE\" = {       # Update posteriors       trial <- update_posteriors(trial)              # Check single-arm futility (drop arms)       for (k in trial$active_arms) {         if (trial$p_single[k] < trial$design$gamma_single_fut) {           trial <- drop_arm(trial, k, reason = \"futility\")         }       }              # Check if all arms dropped       if (length(trial$active_arms) == 0) {         trial$state <- \"STATE_STOP\"         trial$conclusion <- \"all_arms_futile\"         return(trial)       }              # Check transition trigger       trigger_met <- check_transition_trigger(trial)       if (trigger_met) {         trial$state <- \"STATE_CONSIDER_CONVERSION\"         return(trial)       }              # Check max sample size       if (trial$n_enrolled >= trial$design$n_max_single_phase) {         trial$state <- \"STATE_STOP\"         trial$conclusion <- \"max_n_single_phase\"         return(trial)       }              # Continue enrollment       trial     },          \"STATE_CONSIDER_CONVERSION\" = {       # Compute predictive probability for each candidate N_add       pp_results <- compute_pp_curve(trial)              # Find minimum N_add achieving pp_go (if any)       viable_n <- pp_results$n_add[pp_results$pp >= trial$design$pp_go]              if (length(viable_n) > 0) {         # Go decision: proceed to between-arm phase         trial$n_add_selected <- min(viable_n)         trial$n_max_between <- trial$n_enrolled + trial$n_add_selected * length(trial$active_arms)         trial$state <- \"STATE_BETWEEN\"       } else if (max(pp_results$pp) < trial$design$pp_nogo) {         # No-go decision: stop with single-arm conclusions         trial$state <- \"STATE_STOP\"         trial$conclusion <- \"conversion_nogo\"       } else {         # Ambiguous: could implement additional logic or default to no-go         trial$state <- \"STATE_STOP\"         trial$conclusion <- \"conversion_ambiguous\"       }              trial     },          \"STATE_BETWEEN\" = {       # Update posteriors       trial <- update_posteriors(trial)              # Check between-arm efficacy       if (trial$p_between > trial$design$gamma_between_eff) {         trial$state <- \"STATE_STOP\"         trial$conclusion <- \"between_arm_efficacy\"         return(trial)       }              # Check between-arm futility       if (trial$p_between < trial$design$gamma_between_fut) {         trial$state <- \"STATE_STOP\"         trial$conclusion <- \"between_arm_futility\"         return(trial)       }              # Check max sample size       if (trial$n_enrolled >= trial$n_max_between) {         trial$state <- \"STATE_STOP\"         trial$conclusion <- \"max_n_between_phase\"         return(trial)       }              # Continue enrollment       trial     },          \"STATE_STOP\" = {       # Terminal state - no transitions       trial     }   ) }"},{"path":[]},{"path":"/hybrid_suggestions.html","id":"id_51-core-algorithm","dir":"","previous_headings":"5. Predictive Probability Engine","what":"5.1 Core Algorithm","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"predictive probability πpred(Nadd)\\pi_{\\text{pred}}(N_{\\text{add}}) answers: “Given current data, enroll NaddN_{\\text{add}} additional patients per arm, probability final -arm comparison meet efficacy criterion?” Algorithm:","code":"Input:   - Current posterior parameters: (a_A, b_A), (a_B, b_B)   - Additional patients per arm: N_add   - Accrual rate, follow-up time   - Success criterion: γ_between_eff   - Number of Monte Carlo samples: n_outer  Output:   - π_pred: Predictive probability of success  Algorithm:   success_count ← 0    FOR i = 1 TO n_outer:     # Step 1: Draw \"true\" hazards from current posterior     λ_A^(i) ~ Gamma(a_A, b_A)     λ_B^(i) ~ Gamma(a_B, b_B)      # Step 2: Simulate future events and exposure under these \"true\" hazards     (n_A^future, T_A^future) ← simulate_future(λ_A^(i), N_add, accrual, followup)     (n_B^future, T_B^future) ← simulate_future(λ_B^(i), N_add, accrual, followup)      # Step 3: Compute final posterior parameters (accumulate sufficient stats)     a_A^final ← a_A + n_A^future     b_A^final ← b_A + T_A^future     a_B^final ← a_B + n_B^future     b_B^final ← b_B + T_B^future      # Step 4: Compute P(HR_AB < 1 | final data) using closed form     p_between^(i) ← F_F(b_A^final/b_B^final × a_B^final/a_A^final; 2a_A^final, 2a_B^final)      # Step 5: Check success criterion     IF p_between^(i) > γ_between_eff THEN       success_count ← success_count + 1    RETURN success_count / n_outer"},{"path":"/hybrid_suggestions.html","id":"id_52-simulating-future-events","dir":"","previous_headings":"5. Predictive Probability Engine","what":"5.2 Simulating Future Events","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"exponential survival hazard λ\\lambda, accrual rate rr patients/month, analysis time τ\\tau last patient enrolled:","code":"simulate_future_arm <- function(lambda, n_patients, accrual_rate, followup_months) {   # Enrollment times (uniform accrual)   enrollment_duration <- n_patients / accrual_rate   enrollment_times <- sort(runif(n_patients, 0, enrollment_duration))      # Analysis time   analysis_time <- enrollment_duration + followup_months      # Simulate survival times   survival_times <- rexp(n_patients, rate = lambda)      # Calendar time of event   event_times <- enrollment_times + survival_times      # Observed time (censored at analysis)   observed_times <- pmin(survival_times, analysis_time - enrollment_times)   event_indicators <- (event_times <= analysis_time)      # Sufficient statistics   n_events <- sum(event_indicators)   total_exposure <- sum(observed_times)      list(     n_events = n_events,     total_exposure = total_exposure   ) }"},{"path":"/hybrid_suggestions.html","id":"id_53-complete-predictive-probability-function","dir":"","previous_headings":"5. Predictive Probability Engine","what":"5.3 Complete Predictive Probability Function","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"","code":"compute_pp_between_success <- function(   a_post,                    # Named vector: c(A = ..., B = ...)   b_post,                    # Named vector: c(A = ..., B = ...)   n_additional_per_arm,      # Scalar or vector to evaluate   accrual_rate,              # Patients per month per arm   followup_months,           # Follow-up after last patient   gamma_between_eff,         # Success threshold (e.g., 0.975)   n_outer = 1000             # Monte Carlo samples ) {      # Handle vector of candidate N values   if (length(n_additional_per_arm) > 1) {     return(sapply(n_additional_per_arm, function(n) {       compute_pp_between_success(         a_post, b_post, n, accrual_rate, followup_months, gamma_between_eff, n_outer       )     }))   }      success_count <- 0      for (i in seq_len(n_outer)) {          # Step 1: Draw \"true\" hazards from current posterior     lambda_A <- rgamma(1, shape = a_post[\"A\"], rate = b_post[\"A\"])     lambda_B <- rgamma(1, shape = a_post[\"B\"], rate = b_post[\"B\"])          # Step 2: Simulate future events and exposure     fut_A <- simulate_future_arm(lambda_A, n_additional_per_arm, accrual_rate, followup_months)     fut_B <- simulate_future_arm(lambda_B, n_additional_per_arm, accrual_rate, followup_months)          # Step 3: Update posterior (accumulate sufficient stats)     a_final <- c(       A = a_post[\"A\"] + fut_A$n_events,       B = a_post[\"B\"] + fut_B$n_events     )     b_final <- c(       A = b_post[\"A\"] + fut_A$total_exposure,       B = b_post[\"B\"] + fut_B$total_exposure     )          # Step 4: Compute P(HR_AB < 1 | final data) - closed form     p_between <- pf(       q = (b_final[\"A\"] / b_final[\"B\"]) * (a_final[\"B\"] / a_final[\"A\"]),       df1 = 2 * a_final[\"A\"],       df2 = 2 * a_final[\"B\"]     )          # Step 5: Check success criterion     if (p_between > gamma_between_eff) {       success_count <- success_count + 1     }   }      success_count / n_outer }"},{"path":"/hybrid_suggestions.html","id":"id_54-finding-required-sample-size","dir":"","previous_headings":"5. Predictive Probability Engine","what":"5.4 Finding Required Sample Size","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"","code":"find_n_for_target_pp <- function(   a_post, b_post,   target_pp,                  # Target predictive probability (e.g., 0.80)   accrual_rate,   followup_months,   gamma_between_eff,   n_range = c(10, 200),       # Search range for N per arm   tolerance = 5,              # Tolerance for binary search   n_outer = 1000 ) {      # Binary search for minimum N achieving target PP   lower <- n_range[1]   upper <- n_range[2]      # Check boundaries   pp_lower <- compute_pp_between_success(     a_post, b_post, lower, accrual_rate, followup_months, gamma_between_eff, n_outer   )   pp_upper <- compute_pp_between_success(     a_post, b_post, upper, accrual_rate, followup_months, gamma_between_eff, n_outer   )      if (pp_lower >= target_pp) {     return(list(n_required = lower, pp_achieved = pp_lower, converged = TRUE))   }   if (pp_upper < target_pp) {     return(list(n_required = NA, pp_achieved = pp_upper, converged = FALSE,                 message = \"Target PP not achievable within range\"))   }      # Binary search   while ((upper - lower) > tolerance) {     mid <- round((lower + upper) / 2)     pp_mid <- compute_pp_between_success(       a_post, b_post, mid, accrual_rate, followup_months, gamma_between_eff, n_outer     )          if (pp_mid >= target_pp) {       upper <- mid     } else {       lower <- mid     }   }      list(     n_required = upper,     pp_achieved = compute_pp_between_success(       a_post, b_post, upper, accrual_rate, followup_months, gamma_between_eff, n_outer * 2     ),     converged = TRUE   ) }"},{"path":"/hybrid_suggestions.html","id":"id_55-computing-the-full-pp-curve","dir":"","previous_headings":"5. Predictive Probability Engine","what":"5.5 Computing the Full PP Curve","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"","code":"compute_pp_curve <- function(trial) {   # Extract current posterior parameters   a_post <- trial$posterior$a   b_post <- trial$posterior$b      # Candidate additional sample sizes   n_candidates <- trial$design$conversion$n_max_candidates      # Compute PP for each candidate   pp_values <- compute_pp_between_success(     a_post = a_post,     b_post = b_post,     n_additional_per_arm = n_candidates,     accrual_rate = trial$design$accrual_rate,     followup_months = trial$design$followup_months,     gamma_between_eff = trial$design$between_arm_criteria$eff_prob,     n_outer = trial$design$conversion$n_outer_pp   )      data.frame(     n_add = n_candidates,     pp = pp_values   ) }"},{"path":[]},{"path":"/hybrid_suggestions.html","id":"id_61-package-structure","dir":"","previous_headings":"6. Software Architecture","what":"6.1 Package Structure","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"","code":"evolveTrial/ ├── R/ │   ├── hybrid_design.R           # Design specification │   ├── hybrid_trial.R            # Trial state and simulation │   ├── hybrid_posterior.R        # Posterior computations (closed-form) │   ├── hybrid_decisions.R        # Decision rule implementations │   ├── hybrid_predictive.R       # Predictive probability engine │   ├── hybrid_simulate.R         # Monte Carlo simulation wrapper │   ├── hybrid_summary.R          # Operating characteristics summary │   ├── single_arm_trial.R        # Existing (minimal changes) │   ├── multiarm_trial.R          # Existing (minimal changes) │   └── utils.R                   # Shared utilities ├── tests/ │   ├── test_hybrid_posterior.R   # Unit tests for posterior computations │   ├── test_hybrid_decisions.R   # Unit tests for decision rules │   ├── test_hybrid_predictive.R  # Unit tests for PP engine │   ├── test_hybrid_simulate.R    # Integration tests │   └── test_hybrid_edge_cases.R  # Edge case tests ├── vignettes/ │   └── hybrid_design_workflow.Rmd └── man/     └── ..."},{"path":"/hybrid_suggestions.html","id":"id_62-core-s3-classes","dir":"","previous_headings":"6. Software Architecture","what":"6.2 Core S3 Classes","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"","code":"# ============================================================================= # DESIGN SPECIFICATION CLASS # =============================================================================  #' Create a Hybrid Single-to-Between Arm Survival Design #' #' @param arms Character vector of arm names #' @param hist_median_surv Named numeric vector of historical median survival (months) #' @param single_arm_criteria List with hr_threshold, eff_prob, fut_prob #' @param between_arm_criteria List with eff_prob, fut_prob #' @param conversion List with trigger, pp_go, pp_nogo, n_max_candidates, etc. #' @param constraints List with n_max_total, max_duration_months, etc. #' @param interims List with timing, events_per_interim, etc. #' @param randomization List with scheme, initial_equal_n #' @param prior List with a0, b0 (gamma prior parameters) #'  #' @return Object of class \"hybrid_surv_design\" #' @export create_hybrid_surv_design <- function(   arms = c(\"A\", \"B\"),      hist_median_surv = c(A = 12, B = 12),      single_arm_criteria = list(     hr_threshold = 0.8,     eff_prob = 0.90,     fut_prob = 0.10   ),      between_arm_criteria = list(     eff_prob = 0.975,     fut_prob = 0.05   ),      conversion = list(     trigger = \"any_single_success\",     pp_go = 0.70,     pp_nogo = 0.20,     n_max_candidates = seq(30, 100, by = 10),     n_outer_pp = 1000   ),      constraints = list(     n_max_total = 200,     n_max_single_phase = 100,     max_duration_months = 48   ),      interims = list(     timing = \"event_driven\",     events_per_interim = 20,     max_interims = 10   ),      randomization = list(     scheme = \"equal\",     initial_equal_n = 20   ),      prior = list(     a0 = 0.001,     b0 = 0.001   ),      accrual_rate = 5,   followup_months = 12 ) {       # Validate inputs   stopifnot(length(arms) >= 2)   stopifnot(all(arms %in% names(hist_median_surv)))   stopifnot(single_arm_criteria$hr_threshold > 0 && single_arm_criteria$hr_threshold < 1)   stopifnot(conversion$trigger %in% c(\"any_single_success\", \"all_single_success\", \"k_of_K\"))      # Compute historical hazards from median survival   hist_hazard <- setNames(log(2) / hist_median_surv[arms], arms)      # Construct design object   design <- list(     arms = arms,     K = length(arms),     hist_median_surv = hist_median_surv[arms],     hist_hazard = hist_hazard,     single_arm_criteria = single_arm_criteria,     between_arm_criteria = between_arm_criteria,     conversion = conversion,     constraints = constraints,     interims = interims,     randomization = randomization,     prior = prior,     accrual_rate = accrual_rate,     followup_months = followup_months   )      class(design) <- c(\"hybrid_surv_design\", \"list\")   design }  # Print method print.hybrid_surv_design <- function(x, ...) {   cat(\"Hybrid Single-to-Between Arm Survival Design\\n\")   cat(\"=============================================\\n\\n\")   cat(\"Arms:\", paste(x$arms, collapse = \", \"), \"\\n\")   cat(\"Historical median survival:\", paste(x$hist_median_surv, \"months\", collapse = \", \"), \"\\n\\n\")   cat(\"Single-arm criteria:\\n\")   cat(\"  HR threshold:\", x$single_arm_criteria$hr_threshold, \"\\n\")   cat(\"  Efficacy prob:\", x$single_arm_criteria$eff_prob, \"\\n\")   cat(\"  Futility prob:\", x$single_arm_criteria$fut_prob, \"\\n\\n\")   cat(\"Between-arm criteria:\\n\")   cat(\"  Efficacy prob:\", x$between_arm_criteria$eff_prob, \"\\n\")   cat(\"  Futility prob:\", x$between_arm_criteria$fut_prob, \"\\n\\n\")   cat(\"Conversion:\\n\")   cat(\"  Trigger:\", x$conversion$trigger, \"\\n\")   cat(\"  PP go threshold:\", x$conversion$pp_go, \"\\n\")   cat(\"  PP no-go threshold:\", x$conversion$pp_nogo, \"\\n\")   invisible(x) }  # ============================================================================= # TRIAL STATE CLASS # =============================================================================  #' Initialize a Hybrid Trial #' #' @param design Object of class \"hybrid_surv_design\" #' @return Object of class \"hybrid_trial\" initialize_hybrid_trial <- function(design) {      trial <- list(     design = design,     state = \"STATE_SINGLE\",          # Data     patients = data.frame(       id = integer(),       arm = character(),       enrollment_time = numeric(),       event_time = numeric(),       observed_time = numeric(),       event = logical()     ),     n_enrolled = setNames(rep(0L, design$K), design$arms),          # Sufficient statistics for posterior     posterior = list(       a = setNames(rep(design$prior$a0, design$K), design$arms),       b = setNames(rep(design$prior$b0, design$K), design$arms)     ),          # Current probabilities     p_single = setNames(rep(NA_real_, design$K), design$arms),     p_between = NA_real_,          # Arm status     active_arms = design$arms,     dropped_arms = character(),     successful_arms = character(),  # Single-arm efficacy achieved          # Conversion info     conversion_triggered = FALSE,     n_add_selected = NA_integer_,     n_max_between = NA_integer_,     pp_at_conversion = NA_real_,          # Timeline     current_time = 0,     interim_count = 0,          # Final conclusions     conclusion = NULL,     final_p_single = NULL,     final_p_between = NULL   )      class(trial) <- c(\"hybrid_trial\", \"list\")   trial }"},{"path":"/hybrid_suggestions.html","id":"id_63-core-functions","dir":"","previous_headings":"6. Software Architecture","what":"6.3 Core Functions","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"","code":"# ============================================================================= # POSTERIOR COMPUTATIONS # =============================================================================  #' Update Posterior Parameters from Trial Data #' #' @param trial Object of class \"hybrid_trial\" #' @param analysis_time Time at which to compute posterior (for censoring) #' @return Updated trial object update_posteriors <- function(trial, analysis_time = NULL) {      if (is.null(analysis_time)) {     analysis_time <- trial$current_time   }      for (k in trial$design$arms) {     # Get patients in this arm     arm_data <- trial$patients[trial$patients$arm == k, ]          if (nrow(arm_data) == 0) {       trial$posterior$a[k] <- trial$design$prior$a0       trial$posterior$b[k] <- trial$design$prior$b0     } else {       # Compute observed times (censored at analysis_time)       time_on_study <- pmin(         arm_data$event_time - arm_data$enrollment_time,         analysis_time - arm_data$enrollment_time       )       time_on_study <- pmax(time_on_study, 0)  # Ensure non-negative              events <- arm_data$event & (arm_data$event_time <= analysis_time)              # Update sufficient statistics       n_events <- sum(events)       total_exposure <- sum(time_on_study)              trial$posterior$a[k] <- trial$design$prior$a0 + n_events       trial$posterior$b[k] <- trial$design$prior$b0 + total_exposure     }   }      # Compute decision quantities   trial <- compute_decision_quantities(trial)      trial }  #' Compute Decision Quantities (Single-arm and Between-arm Probabilities) #' #' @param trial Object of class \"hybrid_trial\" #' @return Updated trial object with p_single and p_between compute_decision_quantities <- function(trial) {      # Single-arm probabilities: P(HR_k^hist < c_k | data)   for (k in trial$design$arms) {     c_k <- trial$design$single_arm_criteria$hr_threshold     lambda_hist_k <- trial$design$hist_hazard[k]          # Threshold on lambda scale     lambda_threshold <- c_k * lambda_hist_k          # P(lambda_k < threshold) = Gamma CDF     trial$p_single[k] <- pgamma(       q = lambda_threshold,       shape = trial$posterior$a[k],       rate = trial$posterior$b[k]     )   }      # Between-arm probability (for two-arm case: P(HR_AB < 1))   # For K > 2, could compute pairwise or vs \"best\"   if (trial$design$K == 2) {     arms <- trial$design$arms     a_A <- trial$posterior$a[arms[1]]     b_A <- trial$posterior$b[arms[1]]     a_B <- trial$posterior$a[arms[2]]     b_B <- trial$posterior$b[arms[2]]          # P(lambda_A / lambda_B < 1) using F distribution     trial$p_between <- pf(       q = (b_A / b_B) * (a_B / a_A),       df1 = 2 * a_A,       df2 = 2 * a_B     )   } else {     # For K > 2, implement pairwise or other comparison strategy     # Placeholder: compare first arm vs pooled others, or implement max comparison     trial$p_between <- NA_real_   }      trial }  # ============================================================================= # DECISION RULES # =============================================================================  #' Check Single-Arm Efficacy for an Arm #' @return Logical check_single_arm_efficacy <- function(trial, arm) {   trial$p_single[arm] > trial$design$single_arm_criteria$eff_prob }  #' Check Single-Arm Futility for an Arm #' @return Logical check_single_arm_futility <- function(trial, arm) {   trial$p_single[arm] < trial$design$single_arm_criteria$fut_prob }  #' Check Between-Arm Efficacy #' @return Logical check_between_arm_efficacy <- function(trial) {   trial$p_between > trial$design$between_arm_criteria$eff_prob }  #' Check Between-Arm Futility #' @return Logical check_between_arm_futility <- function(trial) {   trial$p_between < trial$design$between_arm_criteria$fut_prob }  #' Check Transition Trigger #' @return Logical check_transition_trigger <- function(trial) {   trigger <- trial$design$conversion$trigger      switch(trigger,     \"any_single_success\" = {       any(sapply(trial$active_arms, function(k) check_single_arm_efficacy(trial, k)))     },     \"all_single_success\" = {       all(sapply(trial$active_arms, function(k) check_single_arm_efficacy(trial, k)))     },     \"k_of_K\" = {       k_required <- trial$design$conversion$k_required       sum(sapply(trial$active_arms, function(k) check_single_arm_efficacy(trial, k))) >= k_required     },     FALSE   ) }  #' Drop an Arm #' @return Updated trial object drop_arm <- function(trial, arm, reason = \"futility\") {   trial$active_arms <- setdiff(trial$active_arms, arm)   trial$dropped_arms <- c(trial$dropped_arms, arm)   attr(trial$dropped_arms, \"reasons\") <- c(     attr(trial$dropped_arms, \"reasons\"),     setNames(reason, arm)   )   trial }"},{"path":"/hybrid_suggestions.html","id":"id_64-simulation-engine","dir":"","previous_headings":"6. Software Architecture","what":"6.4 Simulation Engine","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"","code":"# ============================================================================= # SINGLE TRIAL SIMULATION # =============================================================================  #' Simulate a Single Hybrid Trial #' #' @param design Object of class \"hybrid_surv_design\" #' @param scenario List with true_hazard (named vector) and other simulation params #' @param seed Random seed #' @return Object of class \"hybrid_trial\" with complete trajectory simulate_hybrid_trial <- function(design, scenario, seed = NULL) {      if (!is.null(seed)) set.seed(seed)      # Initialize trial   trial <- initialize_hybrid_trial(design)      # Run until terminal state  while (trial$state != \"STATE_STOP\") {          # Enroll patients until next interim     trial <- enroll_patients_until_interim(trial, scenario)          # Update posteriors at interim     trial <- update_posteriors(trial)     trial$interim_count <- trial$interim_count + 1          # Apply state-specific logic and transitions     trial <- update_trial_state(trial)   }      # Finalize   trial$final_p_single <- trial$p_single   trial$final_p_between <- trial$p_between      trial }  #' Enroll Patients Until Next Interim Analysis #' #' @param trial Object of class \"hybrid_trial\" #' @param scenario Simulation scenario with true hazards #' @return Updated trial object enroll_patients_until_interim <- function(trial, scenario) {      # Determine target for next interim   if (trial$design$interims$timing == \"event_driven\") {     # Enroll until we have enough events     target_events <- trial$design$interims$events_per_interim * (trial$interim_count + 1)          while (count_events(trial) < target_events &&             sum(trial$n_enrolled) < trial$design$constraints$n_max_total) {       trial <- enroll_one_patient(trial, scenario)       trial$current_time <- trial$current_time + 1 / trial$design$accrual_rate     }        } else if (trial$design$interims$timing == \"calendar\") {     # Enroll until calendar time     target_time <- trial$design$interims$months_per_interim * (trial$interim_count + 1)          while (trial$current_time < target_time &&             sum(trial$n_enrolled) < trial$design$constraints$n_max_total) {       trial <- enroll_one_patient(trial, scenario)       trial$current_time <- trial$current_time + 1 / trial$design$accrual_rate     }   }      trial }  #' Enroll One Patient #' #' @param trial Object of class \"hybrid_trial\" #' @param scenario Simulation scenario #' @return Updated trial object enroll_one_patient <- function(trial, scenario) {      # Randomize to an active arm   if (trial$design$randomization$scheme == \"equal\") {     arm <- sample(trial$active_arms, 1)   } else {     # Implement RAR if needed     arm <- sample(trial$active_arms, 1)   }      # Generate survival time under true hazard   true_hazard <- scenario$true_hazard[arm]   survival_time <- rexp(1, rate = true_hazard)      # Create patient record   new_patient <- data.frame(     id = nrow(trial$patients) + 1,     arm = arm,     enrollment_time = trial$current_time,     event_time = trial$current_time + survival_time,     observed_time = NA,  # Will be computed at analysis     event = TRUE,  # Will be updated for censoring     stringsAsFactors = FALSE   )      trial$patients <- rbind(trial$patients, new_patient)   trial$n_enrolled[arm] <- trial$n_enrolled[arm] + 1      trial }  #' Count Total Events Observed by Current Time count_events <- function(trial) {   sum(trial$patients$event_time <= trial$current_time) }  # ============================================================================= # MULTIPLE TRIAL SIMULATION # =============================================================================  #' Simulate Multiple Hybrid Trials and Compute Operating Characteristics #' #' @param design Object of class \"hybrid_surv_design\" #' @param scenario Simulation scenario #' @param n_sims Number of simulations #' @param parallel Logical, use parallel processing #' @param n_cores Number of cores (NULL for auto-detect) #' @return Object of class \"hybrid_sim_results\" #' @export simulate_hybrid_trials <- function(   design,   scenario,   n_sims = 1000,   parallel = TRUE,   n_cores = NULL ) {      if (parallel) {     if (is.null(n_cores)) {       n_cores <- parallel::detectCores() - 1     }          cl <- parallel::makeCluster(n_cores)     on.exit(parallel::stopCluster(cl))          # Export required objects     parallel::clusterExport(cl, c(\"design\", \"scenario\"), envir = environment())     parallel::clusterEvalQ(cl, library(evolveTrial))          results <- parallel::parLapply(cl, 1:n_sims, function(i) {       simulate_hybrid_trial(design, scenario, seed = i)     })        } else {     results <- lapply(1:n_sims, function(i) {       simulate_hybrid_trial(design, scenario, seed = i)     })   }      # Compile operating characteristics   ocs <- compile_operating_characteristics(results, design, scenario)      structure(     list(       design = design,       scenario = scenario,       n_sims = n_sims,       trials = results,       ocs = ocs     ),     class = c(\"hybrid_sim_results\", \"list\")   ) }  #' Compile Operating Characteristics from Simulation Results compile_operating_characteristics <- function(results, design, scenario) {      n_sims <- length(results)      # Extract outcomes   conclusions <- sapply(results, function(x) x$conclusion)   states_reached <- sapply(results, function(x) x$conversion_triggered)   n_enrolled_total <- sapply(results, function(x) sum(x$n_enrolled))   n_interims <- sapply(results, function(x) x$interim_count)      # Single-arm outcomes   single_arm_efficacy <- sapply(design$arms, function(k) {     mean(sapply(results, function(x) k %in% x$successful_arms))   })      # Between-arm outcomes   reached_between <- mean(states_reached)   between_efficacy_given_reached <- mean(     sapply(results[states_reached], function(x) {       x$conclusion == \"between_arm_efficacy\"     })   )   between_efficacy_overall <- mean(conclusions == \"between_arm_efficacy\")      # Type I error (depends on scenario)   # If scenario is null (HR = 1), then between_efficacy is type I error      list(     # Sample size     mean_n = mean(n_enrolled_total),     sd_n = sd(n_enrolled_total),     median_n = median(n_enrolled_total),          # Single-arm     prob_single_arm_efficacy = single_arm_efficacy,          # Conversion     prob_conversion = reached_between,     mean_n_at_conversion = mean(sapply(results[states_reached], function(x) sum(x$n_enrolled))),          # Between-arm     prob_between_efficacy_given_conversion = between_efficacy_given_reached,     prob_between_efficacy_overall = between_efficacy_overall,          # By conclusion     conclusion_table = table(conclusions) / n_sims,          # Duration     mean_interims = mean(n_interims)   ) }"},{"path":[]},{"path":"/hybrid_suggestions.html","id":"id_71-design-parameter-vector-φ","dir":"","previous_headings":"7. BATON Calibration","what":"7.1 Design Parameter Vector (φ)","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"parameters optimized BATON: Total dimensions: 7 continuous parameters","code":""},{"path":"/hybrid_suggestions.html","id":"id_72-scenarios-for-calibration","dir":"","previous_headings":"7. BATON Calibration","what":"7.2 Scenarios for Calibration","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"","code":"# Standard scenario set for calibration calibration_scenarios <- list(      # Null scenarios (for Type I error control)   null_global = list(     name = \"Global null\",     true_hazard = c(A = 0.0578, B = 0.0578),  # Both equal to historical (12 mo median)     true_hr_vs_hist = c(A = 1.0, B = 1.0),     true_hr_between = 1.0   ),      null_between = list(     name = \"Both beat historical, no between-arm difference\",     true_hazard = c(A = 0.0462, B = 0.0462),  # Both 20% better than historical (15 mo median)     true_hr_vs_hist = c(A = 0.8, B = 0.8),     true_hr_between = 1.0   ),      # Alternative scenarios (for power)   alt_both_different = list(     name = \"A better than B, both beat historical\",     true_hazard = c(A = 0.0385, B = 0.0513),  # A: 18mo median, B: 13.5mo median     true_hr_vs_hist = c(A = 0.67, B = 0.89),     true_hr_between = 0.75  # A is 25% better than B   ),      alt_strong_difference = list(     name = \"Strong between-arm difference\",     true_hazard = c(A = 0.0347, B = 0.0578),  # A: 20mo median, B: 12mo median     true_hr_vs_hist = c(A = 0.6, B = 1.0),     true_hr_between = 0.6   ),      # Edge cases   one_arm_futile = list(     name = \"One arm futile\",     true_hazard = c(A = 0.0385, B = 0.0694),  # A: 18mo, B: 10mo (worse than hist)     true_hr_vs_hist = c(A = 0.67, B = 1.2),     true_hr_between = 0.55   ) )"},{"path":"/hybrid_suggestions.html","id":"id_73-objective-function","dir":"","previous_headings":"7. BATON Calibration","what":"7.3 Objective Function","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"","code":"#' BATON Objective Function for Hybrid Design Calibration #' #' @param phi Named vector of design parameters #' @param design_template Base design object #' @param scenarios List of calibration scenarios #' @param targets List of target operating characteristics #' @param n_sims Simulations per scenario #' @return List with objective value and constraint violations baton_objective <- function(   phi,   design_template,   scenarios,   targets,   n_sims = 5000 ) {      # Build design from phi   design <- build_design_from_phi(design_template, phi)      # Evaluate across scenarios   ocs_by_scenario <- lapply(scenarios, function(scen) {     sim_results <- simulate_hybrid_trials(design, scen, n_sims = n_sims, parallel = TRUE)     sim_results$ocs   })   names(ocs_by_scenario) <- names(scenarios)      # Compute constraint violations   constraints <- list()      # Type I error for single-arm (under global null)   constraints$single_type1 <- max(ocs_by_scenario$null_global$prob_single_arm_efficacy) - targets$single_type1_max      # Type I error for between-arm (under null_between where single-arm might succeed)   constraints$between_type1 <- ocs_by_scenario$null_between$prob_between_efficacy_overall - targets$between_type1_max      # Power for single-arm (under alt_both_different)   constraints$single_power <- targets$single_power_min - min(ocs_by_scenario$alt_both_different$prob_single_arm_efficacy)      # Power for between-arm (under alt_both_different)   constraints$between_power <- targets$between_power_min - ocs_by_scenario$alt_both_different$prob_between_efficacy_overall      # Compute objective (minimize expected sample size, subject to constraints)   # Weighted average across scenarios   expected_n <- weighted.mean(     sapply(ocs_by_scenario, function(x) x$mean_n),     w = targets$scenario_weights   )      # Add penalty for unnecessary conversions under null_between   conversion_penalty <- ocs_by_scenario$null_between$prob_conversion * targets$conversion_penalty_weight      objective_value <- expected_n + conversion_penalty      list(     value = objective_value,     constraints = constraints,     feasible = all(sapply(constraints, function(x) x <= 0)),     ocs = ocs_by_scenario   ) }  #' Build Design Object from Parameter Vector build_design_from_phi <- function(design_template, phi) {      design <- design_template      design$single_arm_criteria$eff_prob <- phi[\"gamma_single_eff\"]   design$single_arm_criteria$fut_prob <- phi[\"gamma_single_fut\"]   design$single_arm_criteria$hr_threshold <- phi[\"hr_threshold\"]   design$between_arm_criteria$eff_prob <- phi[\"gamma_between_eff\"]   design$between_arm_criteria$fut_prob <- phi[\"gamma_between_fut\"]   design$conversion$pp_go <- phi[\"pp_go\"]   design$conversion$pp_nogo <- phi[\"pp_nogo\"]      design }"},{"path":"/hybrid_suggestions.html","id":"id_74-calibration-wrapper","dir":"","previous_headings":"7. BATON Calibration","what":"7.4 Calibration Wrapper","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"","code":"#' Calibrate Hybrid Design Using BATON #' #' @param design_template Base design object #' @param scenarios Calibration scenarios #' @param targets Target operating characteristics #' @param baton_config BATON configuration #' @return Calibration results #' @export calibrate_hybrid_design <- function(   design_template,      scenarios = calibration_scenarios,      targets = list(     single_type1_max = 0.10,     between_type1_max = 0.05,     single_power_min = 0.80,     between_power_min = 0.80,     scenario_weights = c(0.2, 0.2, 0.3, 0.2, 0.1),     conversion_penalty_weight = 10   ),      baton_config = list(     n_initial = 20,     n_iterations = 150,     n_sims_per_design = 3000,     n_validation_sims = 20000   ) ) {      # Define parameter bounds   bounds <- list(     gamma_single_eff = c(0.80, 0.99),     gamma_single_fut = c(0.01, 0.20),     hr_threshold = c(0.60, 0.90),     gamma_between_eff = c(0.95, 0.999),     gamma_between_fut = c(0.01, 0.10),     pp_go = c(0.50, 0.90),     pp_nogo = c(0.10, 0.40)   )      # Create objective wrapper for BATON   objective_wrapper <- function(phi) {     baton_objective(       phi = phi,       design_template = design_template,       scenarios = scenarios,       targets = targets,       n_sims = baton_config$n_sims_per_design     )   }      # Run BATON optimization   # (Assuming baton_optimize is available from BATON package)   result <- baton_optimize(     objective = objective_wrapper,     bounds = bounds,     n_initial = baton_config$n_initial,     n_iterations = baton_config$n_iterations,     constrained = TRUE   )      # Validate final design   final_design <- build_design_from_phi(design_template, result$best_phi)      validation <- lapply(scenarios, function(scen) {     sim_results <- simulate_hybrid_trials(       final_design, scen,        n_sims = baton_config$n_validation_sims,        parallel = TRUE     )     sim_results$ocs   })      # Local sensitivity analysis   sensitivity <- validate_local_neighborhood(     result$best_phi, design_template, scenarios, targets   )      list(     optimal_phi = result$best_phi,     optimal_design = final_design,     calibration_trace = result$trace,     validation = validation,     sensitivity = sensitivity,     targets = targets   ) }"},{"path":"/hybrid_suggestions.html","id":"id_75-local-validation","dir":"","previous_headings":"7. BATON Calibration","what":"7.5 Local Validation","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"","code":"#' Validate Design in Local Neighborhood of Optimal #' #' @param phi Optimal parameter vector #' @param design_template Base design #' @param scenarios Calibration scenarios #' @param targets Target OCs #' @param perturbation Relative perturbation (default 5%) #' @param n_sims Simulations per perturbed design validate_local_neighborhood <- function(   phi,   design_template,   scenarios,   targets,   perturbation = 0.05,   n_sims = 10000 ) {      results <- list()      for (param in names(phi)) {     # Perturb down     phi_low <- phi     phi_low[param] <- phi[param] * (1 - perturbation)          # Perturb up     phi_high <- phi     phi_high[param] <- phi[param] * (1 + perturbation)          # Evaluate both     oc_low <- baton_objective(phi_low, design_template, scenarios, targets, n_sims)     oc_high <- baton_objective(phi_high, design_template, scenarios, targets, n_sims)          results[[param]] <- list(       phi_low = phi_low[param],       phi_optimal = phi[param],       phi_high = phi_high[param],       feasible_low = oc_low$feasible,       feasible_high = oc_high$feasible,       objective_low = oc_low$value,       objective_high = oc_high$value,       sensitivity = (oc_high$value - oc_low$value) / (2 * perturbation * phi[param])     )   }      # Summary: is the design robust?   all_feasible <- all(sapply(results, function(x) x$feasible_low && x$feasible_high))   max_sensitivity <- max(abs(sapply(results, function(x) x$sensitivity)))      list(     by_parameter = results,     all_neighbors_feasible = all_feasible,     max_sensitivity = max_sensitivity,     robust = all_feasible && max_sensitivity < 100  # Threshold for \"robust\"   ) }"},{"path":[]},{"path":"/hybrid_suggestions.html","id":"phase-1-core-infrastructure-week-1-2","dir":"","previous_headings":"8. Implementation Phases","what":"Phase 1: Core Infrastructure (Week 1-2)","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"Objectives: - Implement posterior computation functions - Implement decision rule functions - Create design trial S3 classes Deliverables: Unit tests: - Verify posterior computations match Monte Carlo small examples - Verify F-distribution formula HR comparisons - Verify gamma CDF formula single-arm comparisons","code":"✓ create_hybrid_surv_design() ✓ initialize_hybrid_trial() ✓ update_posteriors() ✓ compute_decision_quantities() ✓ compute_p_hr_less_than_c() ✓ check_single_arm_efficacy() ✓ check_single_arm_futility() ✓ check_between_arm_efficacy() ✓ check_between_arm_futility() ✓ check_transition_trigger()"},{"path":"/hybrid_suggestions.html","id":"phase-2-predictive-probability-engine-week-2-3","dir":"","previous_headings":"8. Implementation Phases","what":"Phase 2: Predictive Probability Engine (Week 2-3)","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"Objectives: - Implement future data simulation - Implement PP computation - Implement sample size finding Deliverables: Unit tests: - Verify PP increases sample size - Verify PP approaches 1 true effect large - Verify PP approaches 0 true effect null - Benchmark computation time","code":"✓ simulate_future_arm() ✓ compute_pp_between_success() ✓ find_n_for_target_pp() ✓ compute_pp_curve()"},{"path":"/hybrid_suggestions.html","id":"phase-3-state-machine-and-simulation-week-3-4","dir":"","previous_headings":"8. Implementation Phases","what":"Phase 3: State Machine and Simulation (Week 3-4)","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"Objectives: - Implement state transition logic - Implement single trial simulation - Implement multi-trial simulation Deliverables: Integration tests: - Verify state transitions occur correctly - Verify extreme thresholds, design reduces pure single-arm pure -arm - Verify parallelization produces consistent results","code":"✓ update_trial_state() ✓ enroll_patients_until_interim() ✓ simulate_hybrid_trial() ✓ simulate_hybrid_trials() ✓ compile_operating_characteristics()"},{"path":"/hybrid_suggestions.html","id":"phase-4-baton-integration-week-4-5","dir":"","previous_headings":"8. Implementation Phases","what":"Phase 4: BATON Integration (Week 4-5)","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"Objectives: - Define calibration scenarios - Implement objective function - Implement calibration wrapper - Implement local validation Deliverables: Validation: - Run calibration test problem - Verify type error control - Verify power targets achieved - Document calibration trace","code":"✓ baton_objective() ✓ build_design_from_phi() ✓ calibrate_hybrid_design() ✓ validate_local_neighborhood()"},{"path":"/hybrid_suggestions.html","id":"phase-5-documentation-and-testing-week-5-6","dir":"","previous_headings":"8. Implementation Phases","what":"Phase 5: Documentation and Testing (Week 5-6)","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"Objectives: - Write vignette - Complete unit test coverage - Performance optimization Deliverables:","code":"✓ Vignette: hybrid_design_workflow.Rmd ✓ Full test coverage (>90%) ✓ Performance benchmarks ✓ Documentation for all exported functions"},{"path":[]},{"path":"/hybrid_suggestions.html","id":"id_91-unit-tests","dir":"","previous_headings":"9. Testing Strategy","what":"9.1 Unit Tests","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"","code":"# tests/test_hybrid_posterior.R  test_that(\"Gamma CDF formula for single-arm is correct\", {   # Compare closed form to Monte Carlo   a <- 10   b <- 5   threshold <- 1.5      # Closed form   p_closed <- pgamma(threshold, shape = a, rate = b)      # Monte Carlo   set.seed(123)   samples <- rgamma(100000, shape = a, rate = b)   p_mc <- mean(samples < threshold)      expect_equal(p_closed, p_mc, tolerance = 0.01) })  test_that(\"F distribution formula for between-arm HR is correct\", {   # Compare closed form to Monte Carlo   a_A <- 15   b_A <- 8   a_B <- 12   b_B <- 6      # Closed form   p_closed <- pf(     q = (b_A / b_B) * (a_B / a_A),     df1 = 2 * a_A,     df2 = 2 * a_B   )      # Monte Carlo   set.seed(123)   lambda_A <- rgamma(100000, shape = a_A, rate = b_A)   lambda_B <- rgamma(100000, shape = a_B, rate = b_B)   p_mc <- mean(lambda_A / lambda_B < 1)      expect_equal(p_closed, p_mc, tolerance = 0.01) })  test_that(\"Posterior update accumulates sufficient statistics correctly\", {   design <- create_hybrid_surv_design()   trial <- initialize_hybrid_trial(design)      # Add some patients manually   trial$patients <- data.frame(     id = 1:10,     arm = rep(c(\"A\", \"B\"), each = 5),     enrollment_time = 0,     event_time = c(2, 3, 5, 8, 10, 1, 4, 6, 7, 9),     observed_time = NA,     event = TRUE   )   trial$current_time <- 12      trial <- update_posteriors(trial)      # Check sufficient statistics   expect_equal(trial$posterior$a[\"A\"], design$prior$a0 + 5)   expect_equal(trial$posterior$a[\"B\"], design$prior$a0 + 5) })"},{"path":"/hybrid_suggestions.html","id":"id_92-integration-tests","dir":"","previous_headings":"9. Testing Strategy","what":"9.2 Integration Tests","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"","code":"# tests/test_hybrid_simulate.R  test_that(\"Design reduces to single-arm when between-arm threshold is impossible\", {   design <- create_hybrid_surv_design(     between_arm_criteria = list(eff_prob = 1.0, fut_prob = 0.0)  # Never achievable   )      scenario <- list(true_hazard = c(A = 0.04, B = 0.06))      results <- simulate_hybrid_trials(design, scenario, n_sims = 100)      # Should never reach between-arm efficacy   expect_equal(results$ocs$prob_between_efficacy_overall, 0) })  test_that(\"Type I error is controlled under null scenario\", {   skip_on_cran()  # Long-running test      design <- create_hybrid_surv_design()  # Default calibrated design      null_scenario <- list(true_hazard = c(A = 0.0578, B = 0.0578))  # HR = 1      results <- simulate_hybrid_trials(design, null_scenario, n_sims = 10000)      # Between-arm type I error should be < 0.05 (or whatever target)   expect_lt(results$ocs$prob_between_efficacy_overall, 0.06)  # Allow small margin })"},{"path":"/hybrid_suggestions.html","id":"id_93-edge-case-tests","dir":"","previous_headings":"9. Testing Strategy","what":"9.3 Edge Case Tests","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"","code":"# tests/test_hybrid_edge_cases.R  test_that(\"Trial handles all arms dropped for futility\", {   design <- create_hybrid_surv_design(     single_arm_criteria = list(hr_threshold = 0.5, eff_prob = 0.9, fut_prob = 0.5)   )      # Scenario where both arms are worse than historical   bad_scenario <- list(true_hazard = c(A = 0.08, B = 0.08))  # Worse than 0.0578      trial <- simulate_hybrid_trial(design, bad_scenario, seed = 123)      expect_equal(trial$state, \"STATE_STOP\")   expect_true(trial$conclusion %in% c(\"all_arms_futile\", \"max_n_single_phase\")) })  test_that(\"Trial handles conversion at first interim\", {   design <- create_hybrid_surv_design(     single_arm_criteria = list(hr_threshold = 0.95, eff_prob = 0.5, fut_prob = 0.01)   )      # Scenario with strong effect   strong_scenario <- list(true_hazard = c(A = 0.03, B = 0.04))      trial <- simulate_hybrid_trial(design, strong_scenario, seed = 123)      # Should trigger conversion early   expect_true(trial$conversion_triggered) })"},{"path":[]},{"path":"/hybrid_suggestions.html","id":"a1-derivation-of-phr--c-using-f-distribution","dir":"","previous_headings":"Appendix A: Mathematical Derivations","what":"A.1 Derivation of P(HR < c) Using F Distribution","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"Let λA∼Gamma(aA,bA)\\lambda_A \\sim \\text{Gamma}(a_A, b_A) λB∼Gamma(aB,bB)\\lambda_B \\sim \\text{Gamma}(a_B, b_B) independent. want P(λA/λB<c)P(\\lambda_A / \\lambda_B < c). Step 1: Standardize rates. Let X=λA/bA∼Gamma(aA,1)X = \\lambda_A / b_A \\sim \\text{Gamma}(a_A, 1) Y=λB/bB∼Gamma(aB,1)Y = \\lambda_B / b_B \\sim \\text{Gamma}(a_B, 1). λA/λB=(bA/bB)⋅(X/Y)\\lambda_A / \\lambda_B = (b_A / b_B) \\cdot (X / Y). Step 2: Use Gamma--F relationship. X∼Gamma(,1)X \\sim \\text{Gamma}(, 1) Y∼Gamma(b,1)Y \\sim \\text{Gamma}(b, 1) independent, : X/aY/b∼F(2a,2b)\\frac{X/}{Y/b} \\sim F(2a, 2b) X/Y=(/b)⋅FX/Y = (/b) \\cdot F F∼F(2a,2b)F \\sim F(2a, 2b). Step 3: Combine. λAλB=bAbB⋅XY=bAbB⋅aAaB⋅F\\frac{\\lambda_A}{\\lambda_B} = \\frac{b_A}{b_B} \\cdot \\frac{X}{Y} = \\frac{b_A}{b_B} \\cdot \\frac{a_A}{a_B} \\cdot F F∼F(2aA,2aB)F \\sim F(2a_A, 2a_B). Step 4: Compute probability. P(λAλB<c)=P(F<c⋅bBbA⋅aBaA)=FF(c⋅bB⋅aBbA⋅aA;2aA,2aB)P\\left(\\frac{\\lambda_A}{\\lambda_B} < c\\right) = P\\left(F < c \\cdot \\frac{b_B}{b_A} \\cdot \\frac{a_B}{a_A}\\right) = F_F\\left(c \\cdot \\frac{b_B \\cdot a_B}{b_A \\cdot a_A}; 2a_A, 2a_B\\right) Wait, let recheck . : λAλB<c⇔bAbB⋅aAaB⋅F<c⇔F<c⋅bBbA⋅aBaA\\frac{\\lambda_A}{\\lambda_B} < c \\iff \\frac{b_A}{b_B} \\cdot \\frac{a_A}{a_B} \\cdot F < c \\iff F < c \\cdot \\frac{b_B}{b_A} \\cdot \\frac{a_B}{a_A} Hmm, ’s different wrote earlier. Let recalculate. Actually, correct relationship : X∼Gamma(,1)X \\sim \\text{Gamma}(, 1), 2X∼χ2(2a)2X \\sim \\chi^2(2a). λA∼Gamma(aA,bA)\\lambda_A \\sim \\text{Gamma}(a_A, b_A), 2bAλA∼χ2(2aA)2 b_A \\lambda_A \\sim \\chi^2(2a_A). ratio: λA/aAλB/aB⋅bAbB=2bAλA/(2aA)2bBλB/(2aB)∼F(2aA,2aB)\\frac{\\lambda_A / a_A}{\\lambda_B / a_B} \\cdot \\frac{b_A}{b_B} = \\frac{2 b_A \\lambda_A / (2 a_A)}{2 b_B \\lambda_B / (2 a_B)} \\sim F(2a_A, 2a_B) Therefore: λAλB=aAaB⋅bBbA⋅F\\frac{\\lambda_A}{\\lambda_B} = \\frac{a_A}{a_B} \\cdot \\frac{b_B}{b_A} \\cdot F : P(λAλB<c)=P(F<c⋅aBaA⋅bAbB)P\\left(\\frac{\\lambda_A}{\\lambda_B} < c\\right) = P\\left(F < c \\cdot \\frac{a_B}{a_A} \\cdot \\frac{b_A}{b_B}\\right) correct formula : P(HRAB<c)=FF(c⋅aB⋅bAaA⋅bB;2aA,2aB)P(\\text{HR}_{AB} < c) = F_F\\left(c \\cdot \\frac{a_B \\cdot b_A}{a_A \\cdot b_B}; 2a_A, 2a_B\\right) c=1c = 1: P(HRAB<1)=FF(aB⋅bAaA⋅bB;2aA,2aB)P(\\text{HR}_{AB} < 1) = F_F\\left(\\frac{a_B \\cdot b_A}{a_A \\cdot b_B}; 2a_A, 2a_B\\right) Verification R:","code":"# Verify with Monte Carlo a_A <- 15; b_A <- 8 a_B <- 12; b_B <- 6  # Closed form p_closed <- pf(   q = (a_B * b_A) / (a_A * b_B),   df1 = 2 * a_A,   df2 = 2 * a_B )  # Monte Carlo set.seed(123) lambda_A <- rgamma(1e6, shape = a_A, rate = b_A) lambda_B <- rgamma(1e6, shape = a_B, rate = b_B) p_mc <- mean(lambda_A / lambda_B < 1)  c(closed = p_closed, mc = p_mc) # Should be approximately equal"},{"path":"/hybrid_suggestions.html","id":"a2-corrected-implementation","dir":"","previous_headings":"Appendix A: Mathematical Derivations","what":"A.2 Corrected Implementation","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"","code":"#' Compute P(lambda_j / lambda_l < c) for independent Gamma posteriors #'  #' @param a_j Shape parameter for numerator (arm j) #' @param b_j Rate parameter for numerator (arm j) #' @param a_l Shape parameter for denominator (arm l) #' @param b_l Rate parameter for denominator (arm l) #' @param c Threshold for hazard ratio (default 1) #' @return Probability P(HR < c) compute_p_hr_less_than_c <- function(a_j, b_j, a_l, b_l, c = 1) {   pf(     q = c * (a_l * b_j) / (a_j * b_l),     df1 = 2 * a_j,     df2 = 2 * a_l   ) }"},{"path":"/hybrid_suggestions.html","id":"appendix-b-glossary","dir":"","previous_headings":"","what":"Appendix B: Glossary","title":"Hybrid Single-to-Between Arm Bayesian Adaptive Trial Design: Complete Specification","text":"End specification document.","code":""},{"path":"/index.html","id":"evolvetrial","dir":"","previous_headings":"","what":"Adaptive Clinical Trial Utilities","title":"Adaptive Clinical Trial Utilities","text":"evolveTrial provides utilities designing simulating Bayesian adaptive platform umbrella clinical trials time--event endpoints. package supports ARPA-H ADAPT breast cancer platform trial design.","code":""},{"path":"/index.html","id":"key-features","dir":"","previous_headings":"","what":"Key Features","title":"Adaptive Clinical Trial Utilities","text":"Multi-arm adaptive trials: Simulate trials comparing experimental arms reference arm proportional hazards Single-arm vs historical control: Evaluate efficacy relative historical benchmarks Bayesian decision rules: Interim stopping efficacy futility based posterior probabilities Piecewise exponential hazards: Flexible time--event modeling interval-specific hazards Information gates: Control interim timing via minimum events, median follow-, person-time requirements Operating characteristics: Type error, power, expected sample size, probability early termination C++ acceleration: Posterior sampling hazard computations via Rcpp high performance","code":""},{"path":[]},{"path":"/index.html","id":"prerequisites-for-compiling-c-code","dir":"","previous_headings":"Installation","what":"Prerequisites for Compiling C++ Code","title":"Adaptive Clinical Trial Utilities","text":"package contains C++ code (via Rcpp) must compiled installation. users need install additional tools installing evolveTrial.","code":""},{"path":"/index.html","id":"windows-users","dir":"","previous_headings":"Installation > Prerequisites for Compiling C++ Code","what":"Windows Users","title":"Adaptive Clinical Trial Utilities","text":"must install Rtools installing packages C++ code: 1. Download Rtools : https://cran.r-project.org/bin/windows/Rtools/ 2. Choose version matching R version (e.g., Rtools44 R 4.4.x) 3. Run installer default settings 4. Restart R/RStudio installation verify Rtools installed correctly:","code":"Sys.which(\"make\") # Should return a path like \"C:/rtools44/usr/bin/make.exe\""},{"path":"/index.html","id":"macos-users","dir":"","previous_headings":"Installation > Prerequisites for Compiling C++ Code","what":"macOS Users","title":"Adaptive Clinical Trial Utilities","text":"must install Xcode Command Line Tools: dialog appear - click “Install” wait completion (~5-10 minutes). Apple Silicon Macs (M1/M2/M3), may also need gfortran: verify toolchain ready:","code":"# Run this in Terminal (not R) xcode-select --install # Install Homebrew if not already installed /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"  # Install gfortran brew install gcc # In R, check for C++ compiler system(\"clang++ --version\")"},{"path":"/index.html","id":"linux-users","dir":"","previous_headings":"Installation > Prerequisites for Compiling C++ Code","what":"Linux Users","title":"Adaptive Clinical Trial Utilities","text":"Linux distributions include necessary compilers. :","code":"# Ubuntu/Debian sudo apt-get install r-base-dev  # Fedora/RHEL sudo dnf install R-devel"},{"path":"/index.html","id":"from-github-recommended","dir":"","previous_headings":"Installation","what":"From GitHub (Recommended)","title":"Adaptive Clinical Trial Utilities","text":"Install development version GitHub using one methods:","code":"# Using pak (fastest, handles compilation automatically) install.packages(\"pak\") pak::pak(\"naimurashid/evolveTrial\")  # Or using remotes install.packages(\"remotes\") remotes::install_github(\"naimurashid/evolveTrial\")  # Or using devtools install.packages(\"devtools\") devtools::install_github(\"naimurashid/evolveTrial\")"},{"path":"/index.html","id":"dependencies","dir":"","previous_headings":"Installation","what":"Dependencies","title":"Adaptive Clinical Trial Utilities","text":"package requires: Core: data.table, ggplot2, magrittr, progress, tidyselect Suggested: dplyr, gt, openxlsx, ggrepel, knitr, rmarkdown dependencies installed automatically install evolveTrial.","code":""},{"path":"/index.html","id":"development-installation","dir":"","previous_headings":"Installation","what":"Development Installation","title":"Adaptive Clinical Trial Utilities","text":"development work latest features:","code":"# Clone the repository git clone https://github.com/naimurashid/evolveTrial.git  # Load in R session devtools::load_all(\"path/to/evolveTrial\")"},{"path":"/index.html","id":"troubleshooting-installation","dir":"","previous_headings":"Installation","what":"Troubleshooting Installation","title":"Adaptive Clinical Trial Utilities","text":"“Error: compilation failed” “make: found” - Windows: Rtools installed PATH. Reinstall Rtools restart R. - macOS: Xcode Command Line Tools installed. Run xcode-select --install Terminal. “fatal error: ‘RcppArmadillo.h’ file found” “ld: library found -lgfortran” (macOS) Installation hangs times Still issues? - Check R version 4.0 higher: R.version.string - Open issue : https://github.com/naimurashid/evolveTrial/issues","code":"# Install RcppArmadillo first install.packages(\"RcppArmadillo\") # Then retry evolveTrial installation # Install gfortran via Homebrew brew install gcc # Try installing without vignettes (faster) remotes::install_github(\"naimurashid/evolveTrial\", build_vignettes = FALSE)"},{"path":"/index.html","id":"diagnosing-interim-gating-choices","dir":"","previous_headings":"","what":"Diagnosing interim gating choices","title":"Adaptive Clinical Trial Utilities","text":"early stopping seem occur simulations, often information gates (minimum events, median follow-, required person-time) postpone first informative interim look late trial. helper estimate_vsref_gate_timing() gives quick lower-bound heuristics gates can satisfied deterministic accrual. configuration joint lower bound roughly 18 months, meaning 3-month calendar beats first eligible interim look occur near sixth look. Adjusting information gates (example lowering person-time fraction minimum median follow-) yields earlier opportunities efficacy/futility stopping.","code":"library(evolveTrial)  args <- list(   arm_names = c(\"Doublet\", \"Triplet\"),   reference_arm_name = \"Doublet\",   overall_accrual_rate = 3,   randomization_probs = c(Doublet = 0.5, Triplet = 0.5),   max_total_patients_per_arm = c(Doublet = 70, Triplet = 70),   max_follow_up_sim = 24,   min_events_per_arm = 8,   min_median_followup_per_arm = 3,   min_person_time_frac_per_arm = 0.15 )  estimate_vsref_gate_timing(args)"},{"path":[]},{"path":"/index.html","id":"example-1-multi-arm-trial-experimental-vs-reference","dir":"","previous_headings":"Minimal Working Examples","what":"Example 1: Multi-arm Trial (Experimental vs Reference)","title":"Adaptive Clinical Trial Utilities","text":"Simulate two-arm trial comparing Triplet therapy Doublet (reference) interim efficacy futility stopping:","code":"library(evolveTrial)  # Define trial arguments args <- list(   # Arm configuration   arm_names = c(\"Doublet\", \"Triplet\"),   reference_arm_name = \"Doublet\",   randomization_probs = c(Doublet = 0.5, Triplet = 0.5),   overall_accrual_rate = 3,    # Sample size limits   max_total_patients_per_arm = c(Doublet = 70, Triplet = 70),   max_follow_up_sim = 24,    # Piecewise hazards (8 3-month intervals)   pw_hazards = list(     Doublet = rep(0.12, 8),  # Median ~6 months     Triplet = rep(0.077, 8)  # Median ~9 months (HR = 0.67)   ),   interval_width = 3,    # Bayesian decision thresholds   efficacy_prob_threshold_vsref = 0.99,   futility_prob_threshold_vsref = 0.10,    # Information gates   min_events_per_arm = 8,   min_median_followup_per_arm = 3,   min_person_time_frac_per_arm = 0.15,    # Interim schedule   beat_interval = 3,    # MCMC settings   n_posterior_draws = 5000 )  # Run Monte Carlo simulation (100 replicates for demo) result <- run_single_scenario(args, n_sim = 100, seed = 2025)  # View key operating characteristics summary(result) #> Power: ~80%, Type I error: ~10%, Expected N: ~85 per arm"},{"path":"/index.html","id":"example-2-single-arm-vs-historical-control","dir":"","previous_headings":"Minimal Working Examples","what":"Example 2: Single-arm vs Historical Control","title":"Adaptive Clinical Trial Utilities","text":"Evaluate single experimental arm historical median survival:","code":"library(evolveTrial)  # Define trial arguments for single-arm design args_sa <- list(   # Arm configuration (vs historical control)   arm_names = c(\"Control\", \"Experimental\"),   reference_arm_name = \"Control\",   use_historical_control = TRUE,   randomization_probs = c(Control = 0, Experimental = 1),   overall_accrual_rate = 2,    # Sample size   max_total_patients_per_arm = c(Control = 0, Experimental = 60),   max_follow_up_sim = 24,    # Hazards: Historical median 6 months, experimental median 9 months   pw_hazards = list(     Control = rep(0.116, 8),      # Historical: median 6 mo     Experimental = rep(0.077, 8)  # Expected: median 9 mo   ),   interval_width = 3,    # Decision thresholds vs historical   efficacy_prob_threshold_hc = 0.95,   futility_prob_threshold_hc = 0.05,    # Information gates   min_events_hc = 15,    # Interim schedule   beat_interval = 3,   n_posterior_draws = 5000 )  # Run simulation result_sa <- run_single_scenario(args_sa, n_sim = 100, seed = 2025)  # View operating characteristics summary(result_sa)"},{"path":"/index.html","id":"example-3-grid-search-for-optimal-thresholds","dir":"","previous_headings":"Minimal Working Examples","what":"Example 3: Grid Search for Optimal Thresholds","title":"Adaptive Clinical Trial Utilities","text":"Find efficacy/futility thresholds meet operating characteristic targets:","code":"library(evolveTrial)  # Base trial configuration args <- list(   arm_names = c(\"Control\", \"Experimental\"),   reference_arm_name = \"Control\",   use_historical_control = TRUE,   randomization_probs = c(Control = 0, Experimental = 1),   overall_accrual_rate = 2,   max_total_patients_per_arm = c(Control = 0, Experimental = 60),   max_follow_up_sim = 24,   pw_hazards = list(     Control = rep(0.116, 8),     Experimental = rep(0.077, 8)   ),   interval_width = 3,   min_events_hc = 15,   beat_interval = 3,   n_posterior_draws = 5000 )  # Define threshold grid grid <- expand.grid(   efficacy_prob_threshold_hc = c(0.90, 0.95, 0.99),   futility_prob_threshold_hc = c(0.05, 0.10, 0.15) )  # Evaluate grid (use evaluate_hc_grid for historical control) results <- evaluate_hc_grid(   base_args = args,   grid = grid,   n_sim = 500,   parallel = TRUE,   seed = 2025 )  # Filter feasible designs (type I <= 0.10, power >= 0.80) feasible <- filter_feasible_designs(   results,   alpha_cap = 0.10,   power_floor = 0.80 )  # Recommend optimal design (minimizes expected N) best <- recommend_design(feasible) print(best)"},{"path":[]},{"path":"/index.html","id":"package-structure","dir":"","previous_headings":"","what":"Package Structure","title":"Adaptive Clinical Trial Utilities","text":"","code":"evolveTrial/ ├── R/ │   ├── simulation_driver.R      # Main simulation functions │   ├── design_analysis.R        # Grid search and optimization │   ├── gate_diagnostics.R       # Information gate utilities │   ├── interim_logic.R          # Stopping rule implementation │   ├── posterior_helpers.R      # Bayesian posterior computations │   └── data_generation.R        # Time-to-event data generation ├── src/ │   └── *.cpp                    # C++ acceleration code └── vignettes/     └── design-overview.Rmd      # Detailed methodology"},{"path":"/index.html","id":"related-packages","dir":"","previous_headings":"","what":"Related Packages","title":"Adaptive Clinical Trial Utilities","text":"evolveBO: Bayesian optimization calibrating evolveTrial designs adaptive-trial-bo-paper: Research manuscript case studies","code":""},{"path":"/reference/adopt_calibration.html","id":null,"dir":"Reference","previous_headings":"","what":"Adopt a calibrated design configuration — adopt_calibration","title":"Adopt a calibrated design configuration — adopt_calibration","text":"Picks selected row grid_calibrate() returns updated arguments plus two-scenario list (null vs alternative) subsequent exploration.","code":""},{"path":"/reference/adopt_calibration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adopt a calibrated design configuration — adopt_calibration","text":"","code":"adopt_calibration(cal, base_args, null_med, alt_med, which = 1L)"},{"path":"/reference/adopt_calibration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adopt a calibrated design configuration — adopt_calibration","text":"cal Output grid_calibrate(). base_args Baseline argument list. null_med Control-arm median null. alt_med Experimental median alternative. Integer index specifying row cal$top adopt.","code":""},{"path":"/reference/adopt_calibration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adopt a calibrated design configuration — adopt_calibration","text":"list containing updated arguments (args_star), selected row (pick), two-scenario list (scens2).","code":""},{"path":"/reference/apply_recommended_to_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a recommended early-stopping configuration to the argument list — apply_recommended_to_args","title":"Apply a recommended early-stopping configuration to the argument list — apply_recommended_to_args","text":"Apply recommended early-stopping configuration argument list","code":""},{"path":"/reference/apply_recommended_to_args.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a recommended early-stopping configuration to the argument list — apply_recommended_to_args","text":"","code":"apply_recommended_to_args(args_star, rec_row)"},{"path":"/reference/apply_recommended_to_args.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a recommended early-stopping configuration to the argument list — apply_recommended_to_args","text":"args_star Baseline argument list (typically adopt_calibration()). rec_row Single-row data.table produced recommend_design_from_early().","code":""},{"path":"/reference/apply_recommended_to_args.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a recommended early-stopping configuration to the argument list — apply_recommended_to_args","text":"Modified argument list recommended early-stopping settings.","code":""},{"path":"/reference/binary_interim_decision.html","id":null,"dir":"Reference","previous_headings":"","what":"Binary interim decision check — binary_interim_decision","title":"Binary interim decision check — binary_interim_decision","text":"Evaluates whether stop efficacy futility interim look binary endpoint trial.","code":""},{"path":"/reference/binary_interim_decision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Binary interim decision check — binary_interim_decision","text":"","code":"binary_interim_decision(n_responses, n_total, args, diagnostics = FALSE)"},{"path":"/reference/binary_interim_decision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Binary interim decision check — binary_interim_decision","text":"n_responses Number responders n_total Total enrolled args Trial arguments containing thresholds diagnostics Print diagnostic messages","code":""},{"path":"/reference/binary_interim_decision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Binary interim decision check — binary_interim_decision","text":"List decision (\"continue\", \"stop_efficacy\", \"stop_futility\") probabilities","code":""},{"path":"/reference/calculate_binary_probs.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate binary endpoint interim probabilities — calculate_binary_probs","title":"Calculate binary endpoint interim probabilities — calculate_binary_probs","text":"Computes posterior probabilities efficacy futility decisions binary endpoint trials.","code":""},{"path":"/reference/calculate_binary_probs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate binary endpoint interim probabilities — calculate_binary_probs","text":"","code":"calculate_binary_probs(   n_responses,   n_total,   p0,   p1,   alpha_prior = 1,   beta_prior = 1 )"},{"path":"/reference/calculate_binary_probs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate binary endpoint interim probabilities — calculate_binary_probs","text":"n_responses Number responders observed n_total Total patients enrolled p0 Null hypothesis response rate (futility) p1 Alternative hypothesis response rate (efficacy target) alpha_prior Beta prior shape1 (default 1) beta_prior Beta prior shape2 (default 1)","code":""},{"path":"/reference/calculate_binary_probs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate binary endpoint interim probabilities — calculate_binary_probs","text":"List pr_eff (P(p > p0)) pr_fut (P(p < p1))","code":""},{"path":"/reference/calculate_interval_metrics_fast.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate interval-specific metrics from patient data — calculate_interval_metrics_fast","title":"Calculate interval-specific metrics from patient data — calculate_interval_metrics_fast","text":"Recalculates events person-time using lightweight base-R operations.","code":""},{"path":"/reference/calculate_interval_metrics_fast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate interval-specific metrics from patient data — calculate_interval_metrics_fast","text":"","code":"calculate_interval_metrics_fast(patient_data, interval_cutpoints)"},{"path":"/reference/calculate_interval_metrics_fast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate interval-specific metrics from patient data — calculate_interval_metrics_fast","text":"patient_data Data frame columns observed_time event_status. interval_cutpoints Numeric vector interval boundaries.","code":""},{"path":"/reference/calculate_interval_metrics_fast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate interval-specific metrics from patient data — calculate_interval_metrics_fast","text":"list events_per_interval person_time_per_interval vectors.","code":""},{"path":"/reference/calculate_median_survival_matrix_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate median survival for multiple hazard samples (C++ implementation) — calculate_median_survival_matrix_cpp","title":"Calculate median survival for multiple hazard samples (C++ implementation) — calculate_median_survival_matrix_cpp","text":"Vectorized version processes entire matrix posterior hazard samples. row posterior sample; column interval.","code":""},{"path":"/reference/calculate_median_survival_matrix_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate median survival for multiple hazard samples (C++ implementation) — calculate_median_survival_matrix_cpp","text":"","code":"calculate_median_survival_matrix_cpp(hazard_samples, interval_lengths)"},{"path":"/reference/calculate_median_survival_matrix_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate median survival for multiple hazard samples (C++ implementation) — calculate_median_survival_matrix_cpp","text":"hazard_samples Matrix num_samples rows num_intervals columns interval_lengths Numeric vector interval lengths (durations)","code":""},{"path":"/reference/calculate_median_survival_matrix_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate median survival for multiple hazard samples (C++ implementation) — calculate_median_survival_matrix_cpp","text":"Numeric vector median survival times (length num_samples)","code":""},{"path":"/reference/calculate_median_survival_piecewise.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate median survival for piecewise exponential model — calculate_median_survival_piecewise","title":"Calculate median survival for piecewise exponential model — calculate_median_survival_piecewise","text":"Computes median survival time piecewise exponential model. 0.5 survival reached end last interval, continue past last cutpoint last interval's hazard (open-ended tail). return Inf last hazard exactly zero.","code":""},{"path":"/reference/calculate_median_survival_piecewise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate median survival for piecewise exponential model — calculate_median_survival_piecewise","text":"","code":"calculate_median_survival_piecewise(hazard_rates, interval_lengths)"},{"path":"/reference/calculate_median_survival_piecewise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate median survival for piecewise exponential model — calculate_median_survival_piecewise","text":"hazard_rates Numeric vector hazard rates interval. interval_lengths Numeric vector interval lengths (durations).","code":""},{"path":"/reference/calculate_median_survival_piecewise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate median survival for piecewise exponential model — calculate_median_survival_piecewise","text":"Median survival time (numeric scalar, possibly Inf).","code":""},{"path":"/reference/calculate_median_survival_piecewise_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate median survival for piecewise exponential model (C++ implementation) — calculate_median_survival_piecewise_cpp","title":"Calculate median survival for piecewise exponential model (C++ implementation) — calculate_median_survival_piecewise_cpp","text":"Computes median survival time piecewise exponential model. 0.5 survival reached end last interval, continues past last cutpoint last interval's hazard (open-ended tail). returns Inf last hazard exactly zero.","code":""},{"path":"/reference/calculate_median_survival_piecewise_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate median survival for piecewise exponential model (C++ implementation) — calculate_median_survival_piecewise_cpp","text":"","code":"calculate_median_survival_piecewise_cpp(hazard_rates, interval_lengths)"},{"path":"/reference/calculate_median_survival_piecewise_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate median survival for piecewise exponential model (C++ implementation) — calculate_median_survival_piecewise_cpp","text":"hazard_rates Numeric vector hazard rates interval interval_lengths Numeric vector interval lengths (durations)","code":""},{"path":"/reference/calculate_median_survival_piecewise_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate median survival for piecewise exponential model (C++ implementation) — calculate_median_survival_piecewise_cpp","text":"Median survival time (numeric scalar, possibly Inf)","code":""},{"path":"/reference/calibrate_alpha.html","id":null,"dir":"Reference","previous_headings":"","what":"Calibrate interim and final thresholds for single-arm designs — calibrate_alpha","title":"Calibrate interim and final thresholds for single-arm designs — calibrate_alpha","text":"Sweeps candidate interim final posterior probability thresholds returns best combination achieving desired type error null scenario(s).","code":""},{"path":"/reference/calibrate_alpha.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calibrate interim and final thresholds for single-arm designs — calibrate_alpha","text":"","code":"calibrate_alpha(   base_args,   scens_null,   thr_grid_interim = c(0.9, 0.95, 0.975),   thr_grid_final = c(0.95, 0.975, 0.99),   sims = 300 )"},{"path":"/reference/calibrate_alpha.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calibrate interim and final thresholds for single-arm designs — calibrate_alpha","text":"base_args Baseline argument list passed run_scenarios(). scens_null Scenario list representing null hypotheses. thr_grid_interim Numeric vector interim success thresholds try. thr_grid_final Numeric vector final success thresholds try. sims Number simulations per candidate setting.","code":""},{"path":"/reference/calibrate_alpha.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calibrate interim and final thresholds for single-arm designs — calibrate_alpha","text":"list containing chosen thresholds corresponding estimated type error.","code":""},{"path":"/reference/compare_simon_to_bo.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate BO calibration against Simon enumeration — compare_simon_to_bo","title":"Validate BO calibration against Simon enumeration — compare_simon_to_bo","text":"Runs BO calibration binary simulator compares exact Simon design.","code":""},{"path":"/reference/compare_simon_to_bo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate BO calibration against Simon enumeration — compare_simon_to_bo","text":"","code":"compare_simon_to_bo(   p0,   p1,   alpha = 0.1,   beta = 0.2,   n_max_search = 100,   bo_fit = NULL,   num_sims = 10000 )"},{"path":"/reference/compare_simon_to_bo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate BO calibration against Simon enumeration — compare_simon_to_bo","text":"p0 Null response rate p1 Alternative response rate alpha Type error constraint beta Type II error constraint (1 - power) n_max_search Maximum N Simon search bo_fit Optional: pre-computed BO fit object num_sims Number simulations Monte Carlo validation","code":""},{"path":"/reference/compare_simon_to_bo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate BO calibration against Simon enumeration — compare_simon_to_bo","text":"Data frame comparing Simon (exact) vs BO (calibrated) designs","code":""},{"path":"/reference/create_simulation_cluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a reusable evolveTrial simulation cluster — create_simulation_cluster","title":"Create a reusable evolveTrial simulation cluster — create_simulation_cluster","text":"Creates parallel cluster optimized evolveTrial simulations. cluster can reused across multiple calls run_simulation_pure() passing via cluster parameter, avoiding overhead repeated cluster creation/destruction.","code":""},{"path":"/reference/create_simulation_cluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a reusable evolveTrial simulation cluster — create_simulation_cluster","text":"","code":"create_simulation_cluster(   workers = NULL,   cluster_type = c(\"auto\", \"FORK\", \"PSOCK\") )"},{"path":"/reference/create_simulation_cluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a reusable evolveTrial simulation cluster — create_simulation_cluster","text":"workers Integer; number worker processes. Defaults parallel::detectCores() - 1. cluster_type One \"auto\" (default), \"FORK\", \"PSOCK\". Auto selects FORK Unix systems (faster) PSOCK Windows.","code":""},{"path":"/reference/create_simulation_cluster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a reusable evolveTrial simulation cluster — create_simulation_cluster","text":"parallel cluster object can passed run_simulation_pure() via cluster parameter.","code":""},{"path":"/reference/create_simulation_cluster.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a reusable evolveTrial simulation cluster — create_simulation_cluster","text":"function particularly useful Bayesian optimization workflows run_simulation_pure() called hundreds times. creating cluster reusing , can eliminate 5-10 second cluster spawn/teardown overhead per call. FORK clusters (default Unix) significantly faster : Worker processes inherit parent environment (package loading) Data shared via copy--write (serialization overhead) Remember call release_cluster() done free resources.","code":""},{"path":[]},{"path":"/reference/create_simulation_cluster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a reusable evolveTrial simulation cluster — create_simulation_cluster","text":"","code":"if (FALSE) { # \\dontrun{ # Create cluster once cl <- create_simulation_cluster(workers = 8)  # Use in repeated BO evaluations for (i in 1:100) {   result <- run_simulation_pure(     num_simulations = 500,     ...,     parallel_replicates = TRUE,     cluster = cl   ) }  # Clean up release_cluster(cl) } # }"},{"path":"/reference/dot-use_cpp_posterior.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if C++ posterior sampling should be used — .use_cpp_posterior","title":"Check if C++ posterior sampling should be used — .use_cpp_posterior","text":"Checks environment variable EVOLVETRIAL_USE_CPP determine whether use C++ implementation (default: TRUE)","code":""},{"path":"/reference/dot-use_cpp_posterior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if C++ posterior sampling should be used — .use_cpp_posterior","text":"","code":".use_cpp_posterior()"},{"path":"/reference/dot-use_cpp_posterior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if C++ posterior sampling should be used — .use_cpp_posterior","text":"Logical indicating whether use C++ version","code":""},{"path":"/reference/draw_posterior_hazard_samples.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw posterior hazard samples (DISPATCHER) — draw_posterior_hazard_samples","title":"Draw posterior hazard samples (DISPATCHER) — draw_posterior_hazard_samples","text":"Routes C++ R implementation based EVOLVETRIAL_USE_CPP. Default: C++ better performance. Draws samples posterior distribution hazard rates interval Bayesian piecewise exponential model Gamma priors.","code":""},{"path":"/reference/draw_posterior_hazard_samples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw posterior hazard samples (DISPATCHER) — draw_posterior_hazard_samples","text":"","code":"draw_posterior_hazard_samples(   num_intervals,   events_per_interval,   person_time_per_interval,   prior_alpha_params,   prior_beta_params,   num_samples = 1000 )  draw_posterior_hazard_samples(   num_intervals,   events_per_interval,   person_time_per_interval,   prior_alpha_params,   prior_beta_params,   num_samples = 1000 )"},{"path":"/reference/draw_posterior_hazard_samples.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw posterior hazard samples (DISPATCHER) — draw_posterior_hazard_samples","text":"num_intervals Number intervals piecewise model. events_per_interval Integer vector observed events per interval. person_time_per_interval Numeric vector person-time risk per interval. prior_alpha_params Numeric vector Gamma prior shape parameters. prior_beta_params Numeric vector Gamma prior rate parameters. num_samples Number posterior samples draw (default 1000).","code":""},{"path":"/reference/draw_posterior_hazard_samples.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw posterior hazard samples (DISPATCHER) — draw_posterior_hazard_samples","text":"Matrix posterior hazard samples Matrix num_samples rows num_intervals columns hazard samples.","code":""},{"path":"/reference/draw_posterior_hazard_samples_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw posterior hazard samples (C++ implementation) — draw_posterior_hazard_samples_cpp","title":"Draw posterior hazard samples (C++ implementation) — draw_posterior_hazard_samples_cpp","text":"Draws samples posterior distribution hazard rates interval Bayesian piecewise exponential model Gamma priors.","code":""},{"path":"/reference/draw_posterior_hazard_samples_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw posterior hazard samples (C++ implementation) — draw_posterior_hazard_samples_cpp","text":"","code":"draw_posterior_hazard_samples_cpp(   num_intervals,   events_per_interval,   person_time_per_interval,   prior_alpha_params,   prior_beta_params,   num_samples )"},{"path":"/reference/draw_posterior_hazard_samples_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw posterior hazard samples (C++ implementation) — draw_posterior_hazard_samples_cpp","text":"num_intervals Number intervals piecewise model events_per_interval Integer vector observed events per interval person_time_per_interval Numeric vector person-time risk per interval prior_alpha_params Numeric vector Gamma prior shape parameters prior_beta_params Numeric vector Gamma prior rate parameters num_samples Number posterior samples draw","code":""},{"path":"/reference/draw_posterior_hazard_samples_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw posterior hazard samples (C++ implementation) — draw_posterior_hazard_samples_cpp","text":"Matrix num_samples rows num_intervals columns hazard samples","code":""},{"path":"/reference/draw_posterior_hazard_samples_r.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw posterior hazard samples (ORIGINAL R VERSION) — draw_posterior_hazard_samples_r","title":"Draw posterior hazard samples (ORIGINAL R VERSION) — draw_posterior_hazard_samples_r","text":"Draw posterior hazard samples (ORIGINAL R VERSION)","code":""},{"path":"/reference/draw_posterior_hazard_samples_r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw posterior hazard samples (ORIGINAL R VERSION) — draw_posterior_hazard_samples_r","text":"","code":"draw_posterior_hazard_samples_r(   num_intervals,   events_per_interval,   person_time_per_interval,   prior_alpha_params,   prior_beta_params,   num_samples = 1000 )"},{"path":"/reference/draw_posterior_response_rate.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw posterior samples for binary response rate — draw_posterior_response_rate","title":"Draw posterior samples for binary response rate — draw_posterior_response_rate","text":"Uses Beta-Binomial conjugacy sample posterior distribution response rate.","code":""},{"path":"/reference/draw_posterior_response_rate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw posterior samples for binary response rate — draw_posterior_response_rate","text":"","code":"draw_posterior_response_rate(   n_responses,   n_total,   alpha_prior = 1,   beta_prior = 1,   num_samples = 1000 )"},{"path":"/reference/draw_posterior_response_rate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw posterior samples for binary response rate — draw_posterior_response_rate","text":"n_responses Number responders n_total Total number patients alpha_prior Beta prior shape1 parameter (default 1 uniform) beta_prior Beta prior shape2 parameter (default 1 uniform) num_samples Number posterior samples draw","code":""},{"path":"/reference/draw_posterior_response_rate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw posterior samples for binary response rate — draw_posterior_response_rate","text":"Numeric vector posterior samples response rate","code":""},{"path":"/reference/draw_posterior_response_rate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Draw posterior samples for binary response rate — draw_posterior_response_rate","text":"Prior: Beta(alpha_prior, beta_prior) Likelihood: Binomial(n, p) Posterior: Beta(alpha_prior + successes, beta_prior + failures)","code":""},{"path":"/reference/estimate_vsref_gate_timing.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate when the vs-reference interim gates can be satisfied — estimate_vsref_gate_timing","title":"Estimate when the vs-reference interim gates can be satisfied — estimate_vsref_gate_timing","text":"Provides lower-bound heuristics -arm (vs-reference) interim gating criteria can satisfied deterministic accrual.","code":""},{"path":"/reference/estimate_vsref_gate_timing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate when the vs-reference interim gates can be satisfied — estimate_vsref_gate_timing","text":"","code":"estimate_vsref_gate_timing(args)"},{"path":"/reference/estimate_vsref_gate_timing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate when the vs-reference interim gates can be satisfied — estimate_vsref_gate_timing","text":"args named list following structure passed run_simulation_pure() / run_scenarios(). function uses entries relevant vs-reference gating, namely arm_names, reference_arm_name, overall_accrual_rate, randomization_probs, max_total_patients_per_arm, max_follow_up_sim, min_events_per_arm, min_median_followup_per_arm, min_person_time_frac_per_arm.","code":""},{"path":"/reference/estimate_vsref_gate_timing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate when the vs-reference interim gates can be satisfied — estimate_vsref_gate_timing","text":"list two components: per_arm: data frame containing per-arm accrual rate         heuristic lower-bound times (months) gating         component. joint_lower_bound: maximum per-arm lower bounds,         representing earliest calendar time gates         plausibly satisfied simultaneously heuristics.","code":""},{"path":"/reference/estimate_vsref_gate_timing.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate when the vs-reference interim gates can be satisfied — estimate_vsref_gate_timing","text":"calculations assume constant accrual rate overall_accrual_rate split according randomization_probs. Person-time requirements approximated using relationship PT \\(\\approx\\) rate \\(\\times\\) time\\(^2\\) / 2 steady accrual, median follow-requirement approximated using rule--thumb median follow-exceed roughly half calendar time uniform accrual.","code":""},{"path":"/reference/estimate_vsref_gate_timing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate when the vs-reference interim gates can be satisfied — estimate_vsref_gate_timing","text":"","code":"args <- list(   arm_names = c(\"Doublet\", \"Triplet\"),   reference_arm_name = \"Doublet\",   overall_accrual_rate = 3,   randomization_probs = c(Doublet = 0.5, Triplet = 0.5),   max_total_patients_per_arm = c(Doublet = 70, Triplet = 70),   max_follow_up_sim = 24,   min_events_per_arm = 8,   min_median_followup_per_arm = 3,   min_person_time_frac_per_arm = 0.15 ) estimate_vsref_gate_timing(args) #> $per_arm #>             Arm AccrualRate MinEvents TimeForEvents MinMedianFollowup #> Doublet Doublet         1.5         8      5.333333                 3 #> Triplet Triplet         1.5         8      5.333333                 3 #>         TimeForMedianFollowup MinPersonTimeMonths TimeForPersonTime #> Doublet                     6                 252           18.3303 #> Triplet                     6                 252           18.3303 #>  #> $joint_lower_bound #> [1] 18.3303 #>"},{"path":"/reference/evaluate_ph_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate PH-based grid of designs — evaluate_ph_grid","title":"Evaluate PH-based grid of designs — evaluate_ph_grid","text":"Helper sweeps probability thresholds, gate settings, HR margins, returning operating characteristics plus expected sample sizes per arm.","code":""},{"path":"/reference/evaluate_ph_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate PH-based grid of designs — evaluate_ph_grid","text":"","code":"evaluate_ph_grid(   base_args,   grid,   scens,   sims = 2000,   seed = 4242,   parallel = TRUE )"},{"path":"/reference/evaluate_ph_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate PH-based grid of designs — evaluate_ph_grid","text":"base_args Baseline argument list passed run_scenarios(). grid data.table/data.frame describing design grid.  Must include columns label, thr_eff, thr_fut, margin, min_ev, min_pt, optionally hr_margin. scens Scenario list (e.g., scenarios_from_grid()). sims Number simulations per grid row. seed RNG seed. parallel Logical; use parallel execution.","code":""},{"path":"/reference/evaluate_ph_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate PH-based grid of designs — evaluate_ph_grid","text":"data.table summarising Type error, power, PETs, expected N per arm, control-arm expectations, total expected N null/alt. Evaluate proportional-hazards vs-reference designs grid Runs supplied grid thresholds/margins scenario list, collecting operating characteristics design. data.table summarising alpha, power, PETs, expected sample sizes labelled design.","code":""},{"path":"/reference/evolveTrial-package.html","id":null,"dir":"Reference","previous_headings":"","what":"evolveTrial: Adaptive Clinical Trial Utilities — evolveTrial-package","title":"evolveTrial: Adaptive Clinical Trial Utilities — evolveTrial-package","text":"Helpers Bayesian adaptive platform/umbrella clinical trials, including simulation, decision rules, reporting.","code":""},{"path":"/reference/evolveTrial-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"evolveTrial: Adaptive Clinical Trial Utilities — evolveTrial-package","text":"Maintainer: Naim Rashid naim@unc.edu","code":""},{"path":"/reference/exp_arms_from_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract experimental arm names from an argument list — exp_arms_from_args","title":"Extract experimental arm names from an argument list — exp_arms_from_args","text":"Extract experimental arm names argument list","code":""},{"path":"/reference/exp_arms_from_args.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract experimental arm names from an argument list — exp_arms_from_args","text":"","code":"exp_arms_from_args(args)"},{"path":"/reference/exp_arms_from_args.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract experimental arm names from an argument list — exp_arms_from_args","text":"args Argument list containing arm_names reference_arm_name.","code":""},{"path":"/reference/exp_arms_from_args.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract experimental arm names from an argument list — exp_arms_from_args","text":"Character vector experimental arm names.","code":""},{"path":"/reference/explore_early_stopping_from_cal.html","id":null,"dir":"Reference","previous_headings":"","what":"Explore early stopping knobs around a calibrated design — explore_early_stopping_from_cal","title":"Explore early stopping knobs around a calibrated design — explore_early_stopping_from_cal","text":"Sweeps futility thresholds, information gates, interim schedules around calibrated design characterise trade-offs alpha, power, PETs.","code":""},{"path":"/reference/explore_early_stopping_from_cal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Explore early stopping knobs around a calibrated design — explore_early_stopping_from_cal","text":"","code":"explore_early_stopping_from_cal(   cal,   base_args,   null_med,   alt_med,   base = c(\"null+delta\", \"alt\"),   futility_delta_grid = c(0, 1, 2, 3),   fut_thr_grid = c(0.6, 0.7, 0.8, 0.9),   min_events_grid = c(12, 18),   min_medFU_grid = c(3, 4.5),   schedule_modes = c(\"calendar\", \"persontime\"),   beat_grid = c(3, 6),   pt_milestones_choices = list(c(0.3, 0.45, 0.6, 0.8, 1)),   latest_calendar_look_grid = c(Inf),   min_events_per_arm_grid = c(8, 12),   min_median_followup_per_arm_grid = c(0, 4.5),   min_person_time_frac_per_arm_grid = c(0, 0.25),   sims = 400,   seed = 123,   parallel = (.Platform$OS.type == \"unix\") )"},{"path":"/reference/explore_early_stopping_from_cal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Explore early stopping knobs around a calibrated design — explore_early_stopping_from_cal","text":"cal Calibration output grid_calibrate() similar. base_args Baseline argument list. null_med Control-arm median null. alt_med Experimental median alternative. base Futility baseline mode: \"null+delta\" \"alt\". futility_delta_grid Numeric vector deltas added null medians. fut_thr_grid Numeric vector futility probability thresholds. min_events_grid Global minimum event counts consider. min_medFU_grid Global minimum median follow-values. schedule_modes Character vector: \"calendar\", \"persontime\", . beat_grid Calendar beat schedules evaluate (months). pt_milestones_choices List person-time milestone vectors. latest_calendar_look_grid Backstop calendar times person-time schedules. min_events_per_arm_grid Per-arm minimum events gating. min_median_followup_per_arm_grid Per-arm minimum median follow-. min_person_time_frac_per_arm_grid Per-arm minimum person-time fractions. sims Number simulations per configuration. seed RNG seed. parallel Logical; use parallel processing.","code":""},{"path":"/reference/explore_early_stopping_from_cal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Explore early stopping knobs around a calibrated design — explore_early_stopping_from_cal","text":"data.table operating characteristics configuration.","code":""},{"path":"/reference/export_scenario_table_to_excel.html","id":null,"dir":"Reference","previous_headings":"","what":"Export a scenario summary table to Excel — export_scenario_table_to_excel","title":"Export a scenario summary table to Excel — export_scenario_table_to_excel","text":"Export scenario summary table Excel","code":""},{"path":"/reference/export_scenario_table_to_excel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Export a scenario summary table to Excel — export_scenario_table_to_excel","text":"","code":"export_scenario_table_to_excel(pretty_tbl, file_path = \"scenario_summary.xlsx\")"},{"path":"/reference/export_scenario_table_to_excel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Export a scenario summary table to Excel — export_scenario_table_to_excel","text":"pretty_tbl Data frame produced pretty_scenario_matrix(). file_path Output path Excel workbook.","code":""},{"path":"/reference/export_scenario_table_to_excel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Export a scenario summary table to Excel — export_scenario_table_to_excel","text":"Invisibly returns file_path.  Writes .xlsx file disk.","code":""},{"path":"/reference/export_scenario_table_to_png.html","id":null,"dir":"Reference","previous_headings":"","what":"Render the scenario summary table to a PNG image — export_scenario_table_to_png","title":"Render the scenario summary table to a PNG image — export_scenario_table_to_png","text":"Render scenario summary table PNG image","code":""},{"path":"/reference/export_scenario_table_to_png.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Render the scenario summary table to a PNG image — export_scenario_table_to_png","text":"","code":"export_scenario_table_to_png(   results_df,   file_path = \"scenario_summary.png\",   title = \"Bayesian Adaptive Design Summary\",   subtitle = NULL,   highlight_arm = \"Triplet\",   snapshot_engine = c(\"auto\", \"webshot2\", \"webshot\"),   vwidth = 1400,   vheight = 600,   zoom = 1 )"},{"path":"/reference/export_scenario_table_to_png.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Render the scenario summary table to a PNG image — export_scenario_table_to_png","text":"results_df Data frame returned run_scenarios(). file_path Output path PNG image. title Main title table. subtitle Optional subtitle. highlight_arm Arm name whose columns highlighted. snapshot_engine Rendering backend; one \"auto\", \"webshot2\", \"webshot\". vwidth Viewport width passed renderer. vheight Viewport height passed renderer. zoom Zoom factor passed renderer.","code":""},{"path":"/reference/export_scenario_table_to_png.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Render the scenario summary table to a PNG image — export_scenario_table_to_png","text":"Invisibly returns file_path.  Writes PNG (temporary HTML snapshot_engine = \"webshot\").","code":""},{"path":"/reference/filter_early_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter early-stopping designs by operating targets — filter_early_grid","title":"Filter early-stopping designs by operating targets — filter_early_grid","text":"Filter early-stopping designs operating targets","code":""},{"path":"/reference/filter_early_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter early-stopping designs by operating targets — filter_early_grid","text":"","code":"filter_early_grid(early_df, alpha_cap = 0.1, power_floor = 0.7)"},{"path":"/reference/filter_early_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter early-stopping designs by operating targets — filter_early_grid","text":"early_df data.table/data.frame produced explore_early_stopping_from_cal(). alpha_cap Maximum acceptable type error. power_floor Minimum acceptable power.","code":""},{"path":"/reference/filter_early_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter early-stopping designs by operating targets — filter_early_grid","text":"data.table containing subset meets supplied criteria.","code":""},{"path":"/reference/find_simon_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Find optimal Simon design — find_simon_design","title":"Find optimal Simon design — find_simon_design","text":"Searches Simon optimal minimax design meeting constraints. Uses optimized search early termination.","code":""},{"path":"/reference/find_simon_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find optimal Simon design — find_simon_design","text":"","code":"find_simon_design(   p0,   p1,   alpha = 0.1,   beta = 0.2,   n_max = 100,   criterion = c(\"optimal\", \"minimax\") )"},{"path":"/reference/find_simon_design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find optimal Simon design — find_simon_design","text":"p0 Null response rate p1 Alternative response rate alpha Maximum type error beta Maximum type II error (1 - power) n_max Maximum total sample size search criterion \"optimal\" (minimize E[N] null) \"minimax\" (minimize max N)","code":""},{"path":"/reference/find_simon_design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find optimal Simon design — find_simon_design","text":"Data frame design parameters operating characteristics","code":""},{"path":"/reference/get_binary_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Get binary trial metrics from registry — get_binary_metrics","title":"Get binary trial metrics from registry — get_binary_metrics","text":"Get binary trial metrics registry","code":""},{"path":"/reference/get_binary_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get binary trial metrics from registry — get_binary_metrics","text":"","code":"get_binary_metrics(registry_df, stage = NULL)"},{"path":"/reference/get_binary_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get binary trial metrics from registry — get_binary_metrics","text":"registry_df Binary registry data frame stage Optional: filter specific stage (1, 2, NULL )","code":""},{"path":"/reference/get_binary_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get binary trial metrics from registry — get_binary_metrics","text":"List n_enrolled, n_responses","code":""},{"path":"/reference/grid_calibrate.html","id":null,"dir":"Reference","previous_headings":"","what":"Calibrate historical-control thresholds over a grid — grid_calibrate","title":"Calibrate historical-control thresholds over a grid — grid_calibrate","text":"Evaluates grid interim/final thresholds superiority margins null alternative scenarios, returning full operating characteristics combination.","code":""},{"path":"/reference/grid_calibrate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calibrate historical-control thresholds over a grid — grid_calibrate","text":"","code":"grid_calibrate(   base_args,   null_med = 6,   alt_med = 9,   margins_abs = c(1, 2, 3),   interim_thr_grid = c(0.9, 0.95),   final_thr_grid = c(0.95, 0.975, 0.99),   sims = 400,   target_alpha = 0.1,   seed = 123,   parallel = TRUE )"},{"path":"/reference/grid_calibrate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calibrate historical-control thresholds over a grid — grid_calibrate","text":"base_args Baseline argument list passed run_scenarios(). null_med Control-arm median null hypothesis. alt_med Experimental median alternative. margins_abs Numeric vector absolute superiority margins (months). interim_thr_grid Interim success probabilities evaluate. final_thr_grid Final posterior success probabilities evaluate. sims Number simulations per grid point. target_alpha Target type error used ranking feasible designs. seed RNG seed. parallel Logical; run scenarios parallel.","code":""},{"path":"/reference/grid_calibrate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calibrate historical-control thresholds over a grid — grid_calibrate","text":"list components , feasible, top summarising grid results.","code":""},{"path":"/reference/make_state_binary.html","id":null,"dir":"Reference","previous_headings":"","what":"Create state container for binary endpoint trial — make_state_binary","title":"Create state container for binary endpoint trial — make_state_binary","text":"Create state container binary endpoint trial","code":""},{"path":"/reference/make_state_binary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create state container for binary endpoint trial — make_state_binary","text":"","code":"make_state_binary(arm_names, max_total_patients_per_arm)"},{"path":"/reference/make_state_binary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create state container for binary endpoint trial — make_state_binary","text":"arm_names Character vector arm names max_total_patients_per_arm Named integer vector max N per arm","code":""},{"path":"/reference/make_state_binary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create state container for binary endpoint trial — make_state_binary","text":"State list binary trial simulation","code":""},{"path":"/reference/ph_beta_mode_var.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute mode and variance of log-HR posterior for PH model (DISPATCHER) — ph_beta_mode_var","title":"Compute mode and variance of log-HR posterior for PH model (DISPATCHER) — ph_beta_mode_var","text":"Compute mode variance log-HR posterior PH model (DISPATCHER)","code":""},{"path":"/reference/ph_beta_mode_var.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute mode and variance of log-HR posterior for PH model (DISPATCHER) — ph_beta_mode_var","text":"","code":"ph_beta_mode_var(   E_C,   PT_C,   E_T,   PT_T,   alpha_prior,   beta_prior,   mu,   sigma,   tol = 1e-06,   max_iter = 50 )"},{"path":"/reference/ph_beta_mode_var.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute mode and variance of log-HR posterior for PH model (DISPATCHER) — ph_beta_mode_var","text":"E_C Events control arm (vector interval) PT_C Person-time control arm (vector interval) E_T Events treatment arm (vector interval) PT_T Person-time treatment arm (vector interval) alpha_prior Prior shape parameter hazard (vector interval) beta_prior Prior rate parameter hazard (vector interval) mu Prior mean log-HR sigma Prior SD log-HR tol Tolerance Newton-Raphson convergence (default 1e-6) max_iter Maximum iterations Newton-Raphson (default 50)","code":""},{"path":"/reference/ph_beta_mode_var.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute mode and variance of log-HR posterior for PH model (DISPATCHER) — ph_beta_mode_var","text":"Named list mode variance log-HR posterior","code":""},{"path":"/reference/ph_beta_mode_var_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute mode and variance of log-HR posterior for PH model (C++ implementation) — ph_beta_mode_var_cpp","title":"Compute mode and variance of log-HR posterior for PH model (C++ implementation) — ph_beta_mode_var_cpp","text":"Uses Newton-Raphson iteration find mode log-HR posterior proportional hazards model Gamma prior baseline hazards normal prior log-HR.","code":""},{"path":"/reference/ph_beta_mode_var_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute mode and variance of log-HR posterior for PH model (C++ implementation) — ph_beta_mode_var_cpp","text":"","code":"ph_beta_mode_var_cpp(   E_C,   PT_C,   E_T,   PT_T,   alpha_prior,   beta_prior,   mu,   sigma,   tol = 1e-06,   max_iter = 50L )"},{"path":"/reference/ph_beta_mode_var_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute mode and variance of log-HR posterior for PH model (C++ implementation) — ph_beta_mode_var_cpp","text":"E_C Integer vector control events per interval PT_C Numeric vector control person-time per interval E_T Integer vector treatment events per interval PT_T Numeric vector treatment person-time per interval alpha_prior Numeric vector Gamma prior shape parameters beta_prior Numeric vector Gamma prior rate parameters mu Log-HR prior mean sigma Log-HR prior SD tol Convergence tolerance (default 1e-6) max_iter Maximum Newton-Raphson iterations (default 50)","code":""},{"path":"/reference/ph_beta_mode_var_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute mode and variance of log-HR posterior for PH model (C++ implementation) — ph_beta_mode_var_cpp","text":"List \"mean\" \"sd\" log-HR posterior","code":""},{"path":"/reference/ph_beta_mode_var_r.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute mode and variance of log-HR posterior (ORIGINAL R VERSION) — ph_beta_mode_var_r","title":"Compute mode and variance of log-HR posterior (ORIGINAL R VERSION) — ph_beta_mode_var_r","text":"Compute mode variance log-HR posterior (ORIGINAL R VERSION)","code":""},{"path":"/reference/ph_beta_mode_var_r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute mode and variance of log-HR posterior (ORIGINAL R VERSION) — ph_beta_mode_var_r","text":"","code":"ph_beta_mode_var_r(   E_C,   PT_C,   E_T,   PT_T,   alpha_prior,   beta_prior,   mu,   sigma,   tol = 1e-06,   max_iter = 50 )"},{"path":"/reference/plot_calibration.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot power versus type I error for calibration grids — plot_calibration","title":"Plot power versus type I error for calibration grids — plot_calibration","text":"Visualises output grid_calibrate() plotting power type error, optionally highlighting Pareto frontiers feasible designs.","code":""},{"path":"/reference/plot_calibration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot power versus type I error for calibration grids — plot_calibration","text":"","code":"plot_calibration(cal, target_alpha = 0.1, label_top_n = 3)"},{"path":"/reference/plot_calibration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot power versus type I error for calibration grids — plot_calibration","text":"cal List returned grid_calibrate(). target_alpha Type error threshold display. label_top_n Number feasible designs annotate.","code":""},{"path":"/reference/plot_calibration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot power versus type I error for calibration grids — plot_calibration","text":"ggplot object.","code":""},{"path":"/reference/plot_early_tradeoff.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot early-stopping trade-offs — plot_early_tradeoff","title":"Plot early-stopping trade-offs — plot_early_tradeoff","text":"Visualises power versus type error early-stopping exploration grid.","code":""},{"path":"/reference/plot_early_tradeoff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot early-stopping trade-offs — plot_early_tradeoff","text":"","code":"plot_early_tradeoff(   early_df,   target_alpha = 0.1,   fix_min_ev = NULL,   fix_mfu = NULL,   fix_beat = NULL )"},{"path":"/reference/plot_early_tradeoff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot early-stopping trade-offs — plot_early_tradeoff","text":"early_df data.table/data.frame returned explore_early_stopping_from_cal(). target_alpha Type error target show reference line. fix_min_ev Optional scalar filter min_events. fix_mfu Optional scalar filter min_medFU. fix_beat Optional scalar filter calendar beats.","code":""},{"path":"/reference/plot_early_tradeoff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot early-stopping trade-offs — plot_early_tradeoff","text":"ggplot object (filtered data ggplot2 unavailable).","code":""},{"path":"/reference/precompute_ctrl_posteriors.html","id":null,"dir":"Reference","previous_headings":"","what":"Pre-compute control arm posteriors for caching in multi-arm comparisons — precompute_ctrl_posteriors","title":"Pre-compute control arm posteriors for caching in multi-arm comparisons — precompute_ctrl_posteriors","text":"PERFORMANCE: comparing multiple experimental arms control, function computes control posteriors avoid redundant computation.","code":""},{"path":"/reference/precompute_ctrl_posteriors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pre-compute control arm posteriors for caching in multi-arm comparisons — precompute_ctrl_posteriors","text":"","code":"precompute_ctrl_posteriors(slCtrl, args, num_samples)"},{"path":"/reference/precompute_ctrl_posteriors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pre-compute control arm posteriors for caching in multi-arm comparisons — precompute_ctrl_posteriors","text":"slCtrl Control arm slice slice_arm_data_at_time() args Trial arguments containing prior parameters num_samples Number posterior samples","code":""},{"path":"/reference/precompute_ctrl_posteriors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pre-compute control arm posteriors for caching in multi-arm comparisons — precompute_ctrl_posteriors","text":"List lamC (hazard samples matrix) medCtrl (median vector)","code":""},{"path":"/reference/pretty_scenario_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise simulation output by scenario and arm — pretty_scenario_matrix","title":"Summarise simulation output by scenario and arm — pretty_scenario_matrix","text":"Aggregates per-arm results returned run_scenarios() pivots wide table (one row per scenario) downstream reporting.","code":""},{"path":"/reference/pretty_scenario_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise simulation output by scenario and arm — pretty_scenario_matrix","text":"","code":"pretty_scenario_matrix(results_df)"},{"path":"/reference/pretty_scenario_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise simulation output by scenario and arm — pretty_scenario_matrix","text":"results_df Data frame/data.table produced run_scenarios() containing least scenario Arm_Name.","code":""},{"path":"/reference/pretty_scenario_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise simulation output by scenario and arm — pretty_scenario_matrix","text":"data.frame one row per scenario columns arm's key operating characteristics.","code":""},{"path":"/reference/prob_response_below.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate posterior probability that response rate is below threshold — prob_response_below","title":"Calculate posterior probability that response rate is below threshold — prob_response_below","text":"P(p < threshold | data) using Beta posterior","code":""},{"path":"/reference/prob_response_below.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate posterior probability that response rate is below threshold — prob_response_below","text":"","code":"prob_response_below(   n_responses,   n_total,   threshold,   alpha_prior = 1,   beta_prior = 1 )"},{"path":"/reference/prob_response_below.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate posterior probability that response rate is below threshold — prob_response_below","text":"n_responses Number responders n_total Total number patients threshold Response rate threshold alpha_prior Beta prior shape1 parameter (default 1) beta_prior Beta prior shape2 parameter (default 1)","code":""},{"path":"/reference/prob_response_below.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate posterior probability that response rate is below threshold — prob_response_below","text":"Posterior probability P(p < threshold)","code":""},{"path":"/reference/prob_response_exceeds.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate posterior probability that response rate exceeds threshold — prob_response_exceeds","title":"Calculate posterior probability that response rate exceeds threshold — prob_response_exceeds","text":"P(p > threshold | data) using Beta posterior","code":""},{"path":"/reference/prob_response_exceeds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate posterior probability that response rate exceeds threshold — prob_response_exceeds","text":"","code":"prob_response_exceeds(   n_responses,   n_total,   threshold,   alpha_prior = 1,   beta_prior = 1 )"},{"path":"/reference/prob_response_exceeds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate posterior probability that response rate exceeds threshold — prob_response_exceeds","text":"n_responses Number responders n_total Total number patients threshold Response rate threshold alpha_prior Beta prior shape1 parameter (default 1) beta_prior Beta prior shape2 parameter (default 1)","code":""},{"path":"/reference/prob_response_exceeds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate posterior probability that response rate exceeds threshold — prob_response_exceeds","text":"Posterior probability P(p > threshold)","code":""},{"path":"/reference/recommend_design_from_early.html","id":null,"dir":"Reference","previous_headings":"","what":"Recommend a single early-stopping design — recommend_design_from_early","title":"Recommend a single early-stopping design — recommend_design_from_early","text":"Selects top-performing row early-stopping grid subject alpha/power (optionally PET) constraints.","code":""},{"path":"/reference/recommend_design_from_early.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recommend a single early-stopping design — recommend_design_from_early","text":"","code":"recommend_design_from_early(   df,   alpha_cap = 0.1,   power_floor = 0.8,   pet_fut_cap = NULL )"},{"path":"/reference/recommend_design_from_early.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recommend a single early-stopping design — recommend_design_from_early","text":"df data.table/data.frame explore_early_stopping_from_cal(). alpha_cap Maximum acceptable type error. power_floor Minimum acceptable power. pet_fut_cap Optional cap alternative PET futility.","code":""},{"path":"/reference/recommend_design_from_early.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recommend a single early-stopping design — recommend_design_from_early","text":"data.table row describing recommended design.","code":""},{"path":"/reference/release_cluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Release an evolveTrial simulation cluster — release_cluster","title":"Release an evolveTrial simulation cluster — release_cluster","text":"Stops releases resources cluster created create_simulation_cluster().","code":""},{"path":"/reference/release_cluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Release an evolveTrial simulation cluster — release_cluster","text":"","code":"release_cluster(cluster)"},{"path":"/reference/release_cluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Release an evolveTrial simulation cluster — release_cluster","text":"cluster cluster object created create_simulation_cluster() parallel::makeCluster().","code":""},{"path":"/reference/release_cluster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Release an evolveTrial simulation cluster — release_cluster","text":"NULL invisibly.","code":""},{"path":[]},{"path":"/reference/resolve_gate_vec.html","id":null,"dir":"Reference","previous_headings":"","what":"Resolve gate parameter vector for specified arms with optional scaling — resolve_gate_vec","title":"Resolve gate parameter vector for specified arms with optional scaling — resolve_gate_vec","text":"Internal helper converts gate parameters (may scalar, named vector, positional vector) named numeric vector specified arms. Optionally applies proportional scaling based randomization probabilities.","code":""},{"path":"/reference/resolve_gate_vec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Resolve gate parameter vector for specified arms with optional scaling — resolve_gate_vec","text":"","code":"resolve_gate_vec(   raw,   target_arms,   all_arm_names,   randomization_probs = NULL,   default = 0,   scale = FALSE )"},{"path":"/reference/resolve_gate_vec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Resolve gate parameter vector for specified arms with optional scaling — resolve_gate_vec","text":"raw Raw gate parameter value (scalar, named vector, positional vector). target_arms Character vector arm names resolve gates . all_arm_names Character vector arm names trial (positional matching). randomization_probs Optional named numeric vector randomization probabilities. default Default value raw NULL (default 0). scale Logical; TRUE raw scalar/NULL, apply proportional scaling dividing arm's randomization probability maximum probability (default FALSE).","code":""},{"path":"/reference/resolve_gate_vec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Resolve gate parameter vector for specified arms with optional scaling — resolve_gate_vec","text":"Named numeric vector one element per arm target_arms.","code":""},{"path":"/reference/run_scenarios.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate a design across multiple scenarios — run_scenarios","title":"Evaluate a design across multiple scenarios — run_scenarios","text":"Merges scenario override list base_args, runs run_simulation_pure() every scenario, binds results single table.","code":""},{"path":"/reference/run_scenarios.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate a design across multiple scenarios — run_scenarios","text":"","code":"run_scenarios(   base_args,   scens,   parallel = FALSE,   seed = NULL,   return_percentiles = FALSE,   percentile_probs = c(0, 0.25, 0.5, 0.75, 0.9, 1) )"},{"path":"/reference/run_scenarios.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate a design across multiple scenarios — run_scenarios","text":"base_args Named list arguments accepted run_simulation_pure(). scens List scenario override lists, typically scenarios_from_grid(). parallel Logical; TRUE uses parallel::mclapply() distribute scenarios across cores. seed Optional integer seed passed set.seed() simulations. return_percentiles Logical; TRUE, collect per-replicate sample sizes return percentile summaries. Default FALSE. percentile_probs Numeric vector probabilities percentile computation return_percentiles = TRUE. Default c(0, 0.25, 0.5, 0.75, 0.9, 1.0).","code":""},{"path":"/reference/run_scenarios.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate a design across multiple scenarios — run_scenarios","text":"return_percentiles = FALSE (default), data.table/data.frame containing combined operating characteristic summaries scenario column identifying originating scenario index. return_percentiles = TRUE, list : summary combined summary data.table return_percentiles = FALSE percentiles list percentile results, one per scenario","code":""},{"path":"/reference/run_scenarios.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate a design across multiple scenarios — run_scenarios","text":"","code":"if (FALSE) { # \\dontrun{ base_args <- list(   num_simulations = 200,   arm_names = c(\"Doublet\", \"Triplet\"),   reference_arm_name = \"Doublet\",   compare_arms_option = TRUE,   weibull_shape_true_arms = c(Doublet = 1.2, Triplet = 1.2),   weibull_median_true_arms = c(Doublet = 6, Triplet = 6),   null_median_arms = c(Doublet = 6, Triplet = 6),   futility_median_arms = c(Doublet = 6, Triplet = 6),   interval_cutpoints_sim = seq(0, 24, by = 3),   max_follow_up_sim = 24,   censor_max_time_sim = 24,   prior_alpha_params_model = rep(0.5, 8),   prior_beta_params_model = rep(0.5, 8),   num_posterior_draws = 400,   cohort_size_per_arm = 1,   max_total_patients_per_arm = c(Doublet = 60, Triplet = 60),   min_patients_for_analysis = 10,   efficacy_stopping_rule_hc = TRUE,   efficacy_threshold_current_prob_hc = 0.95,   posterior_futility_threshold_hc = 0.8,   futility_stopping_rule_hc = TRUE,   efficacy_threshold_vs_ref_prob = 0.98,   futility_threshold_vs_ref_prob = 0.6,   compare_arms_futility_margin = 0.4,   overall_accrual_rate = 3,   randomization_probs = c(Doublet = 1/3, Triplet = 2/3),   min_follow_up_at_final = 0,   min_events_for_analysis = 0,   min_median_followup = 0,   interim_calendar_beat = 3,   pred_success_pp_threshold_hc = 1,   pred_futility_pp_threshold_hc = 0,   num_posterior_draws_pred = 200 )  scens <- scenarios_from_grid(list(   weibull_median_true_arms = list(     c(Doublet = 6, Triplet = 6),     c(Doublet = 6, Triplet = 9)   ) ))  run_scenarios(base_args, scens, parallel = FALSE, seed = 123) } # }"},{"path":"/reference/run_simulation_binary.html","id":null,"dir":"Reference","previous_headings":"","what":"Run binary endpoint trial simulation — run_simulation_binary","title":"Run binary endpoint trial simulation — run_simulation_binary","text":"Simulates two-stage binary endpoint trial Bayesian decision rules. Supports Simon-style designs cohort-based enrollment.","code":""},{"path":"/reference/run_simulation_binary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run binary endpoint trial simulation — run_simulation_binary","text":"","code":"run_simulation_binary(   num_simulations,   arm_names,   true_response_prob,   n1_per_arm,   n_total_per_arm,   p0,   p1 = NULL,   efficacy_threshold_binary_prob = 0.95,   futility_threshold_binary_prob = 0.95,   r1_per_arm = NULL,   r_per_arm = NULL,   use_simon_rules = FALSE,   alpha_prior = 1,   beta_prior = 1,   disable_interim_eff_stop = FALSE,   diagnostics = FALSE,   progress = interactive() )"},{"path":"/reference/run_simulation_binary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run binary endpoint trial simulation — run_simulation_binary","text":"num_simulations Number Monte Carlo replicates arm_names Character vector arm names (typically single arm) true_response_prob Named numeric vector true response probabilities n1_per_arm Named integer vector stage 1 sample sizes n_total_per_arm Named integer vector total sample sizes p0 Null hypothesis response rate p1 Alternative hypothesis response rate efficacy_threshold_binary_prob Posterior probability threshold efficacy futility_threshold_binary_prob Posterior probability threshold futility r1_per_arm Optional: Simon-style stage 1 boundaries (stop X1 <= r1) r_per_arm Optional: Simon-style total boundaries (success X > r) use_simon_rules Use exact Simon counting rules instead Bayesian alpha_prior Beta prior shape1 (default 1) beta_prior Beta prior shape2 (default 1) disable_interim_eff_stop TRUE, stop efficacy interim (futility stopping interim, efficacy final). makes Bayesian design comparable Simon's two-stage design stops futility interim. diagnostics Print diagnostic messages progress Show progress bar (default TRUE interactive sessions)","code":""},{"path":"/reference/run_simulation_binary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run binary endpoint trial simulation — run_simulation_binary","text":"Data frame operating characteristics per arm","code":""},{"path":"/reference/run_simulation_pure.html","id":null,"dir":"Reference","previous_headings":"","what":"Run a full set of evolveTrial simulations for a design specification — run_simulation_pure","title":"Run a full set of evolveTrial simulations for a design specification — run_simulation_pure","text":"run_simulation_pure() workhorse simulator evolveTrial.  enrols patients according supplied accrual plan, applies interim gating/decision rules, optionally rebalances interval cut points, carries replicate forward final analysis.  Operating characteristics returned summarised per arm.","code":""},{"path":"/reference/run_simulation_pure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run a full set of evolveTrial simulations for a design specification — run_simulation_pure","text":"","code":"run_simulation_pure(   num_simulations,   arm_names,   reference_arm_name,   compare_arms_option,   weibull_shape_true_arms,   weibull_median_true_arms,   null_median_arms = NULL,   futility_median_arms = NULL,   interval_cutpoints_sim,   max_follow_up_sim,   censor_max_time_sim,   prior_alpha_params_model,   prior_beta_params_model,   num_posterior_draws,   num_posterior_draws_interim = NULL,   cohort_size_per_arm,   max_total_patients_per_arm,   min_patients_for_analysis = NULL,   efficacy_stopping_rule_hc = FALSE,   efficacy_threshold_current_prob_hc = NULL,   posterior_futility_threshold_hc = NULL,   efficacy_threshold_hc_prob = NULL,   futility_threshold_hc_prob = NULL,   futility_stopping_rule_hc = FALSE,   efficacy_stopping_rule_vs_ref = FALSE,   futility_stopping_rule_vs_ref = FALSE,   efficacy_threshold_vs_ref_prob = NULL,   futility_threshold_vs_ref_prob = NULL,   compare_arms_futility_margin = 0,   compare_arms_hr_margin = NULL,   use_ph_model_vs_ref = FALSE,   ph_loghr_prior_mean = 0,   ph_loghr_prior_sd = 1,   median_pfs_success_threshold_arms = NULL,   final_success_posterior_prob_threshold = 0.85,   median_pfs_futility_threshold_arms = NULL,   final_futility_posterior_prob_threshold = 0.85,   overall_accrual_rate,   randomization_probs,   min_follow_up_at_final = 0,   max_trial_time = Inf,   min_events_for_analysis = NULL,   min_median_followup = NULL,   min_events_hc = NULL,   min_median_followup_hc = NULL,   interim_calendar_beat = 2,   diagnostics = FALSE,   pred_success_pp_threshold_hc = 1,   pred_futility_pp_threshold_hc = 0,   num_posterior_draws_pred = 100,   predictive_fast = FALSE,   min_events_per_arm = NULL,   min_median_followup_per_arm = NULL,   min_person_time_frac_per_arm = 0,   person_time_milestones = NULL,   latest_calendar_look = Inf,   rebalance_after_events = NULL,   parallel_replicates = FALSE,   num_workers = NULL,   cluster_type = c(\"auto\", \"PSOCK\", \"FORK\"),   cluster = NULL,   progress = interactive(),   return_percentiles = FALSE,   percentile_probs = c(0, 0.25, 0.5, 0.75, 0.9, 1) )"},{"path":"/reference/run_simulation_pure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run a full set of evolveTrial simulations for a design specification — run_simulation_pure","text":"num_simulations Number Monte Carlo replicates run. arm_names Character vector naming trial arms. reference_arm_name Character scalar naming control/reference arm. compare_arms_option Logical; TRUE evaluates vs-reference logic, FALSE evaluates arms independently historical control targets. weibull_shape_true_arms Named numeric vector Weibull shape parameters truth. weibull_median_true_arms Named numeric vector true median PFS (months) arm. null_median_arms Named numeric vector null (historical control) medians used single-arm evaluations. futility_median_arms Named numeric vector futility medians single-arm logic. interval_cutpoints_sim Numeric vector interval boundaries (months) piecewise exponential modelling. max_follow_up_sim Maximum administrative follow-time (months). censor_max_time_sim Upper bound random censoring draws (months). prior_alpha_params_model Numeric vector Gamma prior shape parameters piecewise exponential hazards. prior_beta_params_model Numeric vector Gamma prior rate parameters piecewise exponential hazards. num_posterior_draws Number posterior draws used final analyses. num_posterior_draws_interim Optional integer overriding number posterior draws used interim looks. cohort_size_per_arm Size enrolment batch per arm (typically 1). max_total_patients_per_arm Named integer vector per-arm sample size caps. min_patients_for_analysis Minimum number patients required evaluate arm single-arm path. specified, defaults 0, allowing interim analyses occur even patients. Set higher value prevent interim analyses certain number patients enrolled. efficacy_stopping_rule_hc Logical; enable interim efficacy checks historical-control path. efficacy_threshold_current_prob_hc DEPRECATED. Use efficacy_threshold_hc_prob instead. Interim success probability threshold single-arm logic. posterior_futility_threshold_hc DEPRECATED. Use futility_threshold_hc_prob instead. Interim futility probability threshold single-arm logic. efficacy_threshold_hc_prob Interim success probability threshold single-arm logic (preferred harmonized name). futility_threshold_hc_prob Interim futility probability threshold single-arm logic (preferred harmonized name). futility_stopping_rule_hc Logical; enable interim futility checks single-arm path. efficacy_stopping_rule_vs_ref Logical; enable interim efficacy checks vs-reference path. futility_stopping_rule_vs_ref Logical; enable interim futility checks vs-reference path. efficacy_threshold_vs_ref_prob Posterior superiority threshold vs-reference decisions. futility_threshold_vs_ref_prob Posterior inferiority threshold vs-reference decisions. compare_arms_futility_margin Absolute median difference used defining vs-reference futility. compare_arms_hr_margin Optional hazard-ratio margin used use_ph_model_vs_ref = TRUE. use_ph_model_vs_ref Logical; use proportional-hazards joint model vs-reference comparisons. ph_loghr_prior_mean Mean normal prior log hazard ratio (PH model). ph_loghr_prior_sd Standard deviation normal prior log hazard ratio. median_pfs_success_threshold_arms Named numeric vector median PFS thresholds declaring final success per arm. final_success_posterior_prob_threshold Posterior probability threshold final success declarations. median_pfs_futility_threshold_arms Named numeric vector median PFS futility thresholds final analyses. final_futility_posterior_prob_threshold Posterior probability threshold final futility declarations. overall_accrual_rate Expected accrual rate (patients per month). randomization_probs Named numeric vector randomisation probabilities. min_follow_up_at_final Additional follow-(months) required last enrolment final analysis. max_trial_time Maximum calendar time (months) entire trial. cutoff trial start, trial terminates regardless stopping rules. Default Inf (time limit). min_events_for_analysis DEPRECATED. Use min_events_hc instead. Minimum events required interim review (global gate). min_median_followup DEPRECATED. Use min_median_followup_hc instead. Minimum median follow-required interim review (global gate). min_events_hc Minimum events required single-arm interim review (preferred harmonized name). min_median_followup_hc Minimum median follow-required single-arm interim review (preferred harmonized name). interim_calendar_beat Calendar spacing (months) scheduled interim looks person-time milestones used. diagnostics Logical; TRUE prints interim diagnostic messages. pred_success_pp_threshold_hc Predictive probability threshold interim success single-arm predictive look (enabled). pred_futility_pp_threshold_hc Predictive probability threshold interim futility single-arm predictive look (enabled). num_posterior_draws_pred Number posterior draws used inside predictive probability calculations. predictive_fast Logical; switch analytic predictive approximations. min_events_per_arm Optional per-arm minimum event gate vs-reference. min_median_followup_per_arm Optional per-arm minimum median follow-gate vs-reference. min_person_time_frac_per_arm Optional per-arm proportion planned person-time required evaluating vs-reference decisions. person_time_milestones Optional numeric vector (fractions total planned person-time) triggering interim looks. latest_calendar_look Backstop calendar time person-time schedules. rebalance_after_events Optional integer; non-NULL piecewise cut points re-estimated number events accrued. parallel_replicates Logical; TRUE, distribute Monte Carlo replicates across parallel cluster. num_workers Optional integer specifying number workers parallel_replicates = TRUE. Defaults parallel::detectCores() - 1. cluster_type Type parallel cluster spawn distributing replicates. One \"auto\" (default, uses FORK Unix, PSOCK Windows), \"PSOCK\", \"FORK\". FORK clusters faster Linux/macOS share memory require package loading workers. cluster Optional pre-existing parallel cluster reuse. provided, cluster used parallel execution stopped exit. enables cluster pooling repeated calls (e.g., Bayesian optimization). Create evolveTrial::create_simulation_cluster() parallel::makeCluster(). progress Logical; show simulation progress bar running sequentially. Automatically disabled parallel replicate execution. return_percentiles Logical; TRUE, store per-replicate sample sizes return percentile summaries addition means. Default FALSE. percentile_probs Numeric vector probabilities percentile computation return_percentiles = TRUE. Default c(0, 0.25, 0.5, 0.75, 0.9, 1.0) gives min, 25th, median, 75th, 90th, max.","code":""},{"path":"/reference/run_simulation_pure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run a full set of evolveTrial simulations for a design specification — run_simulation_pure","text":"return_percentiles = FALSE (default), data frame one row per arm columns summarising operating characteristics type error / power, PETs, final decision probabilities, expected sample size, expected events, expected trial duration (calendar months). return_percentiles = TRUE, list two elements: summary data frame return_percentiles = FALSE percentiles list elements N (named list percentile vectors per arm) probs (probability values used)","code":""},{"path":"/reference/run_simulation_pure.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run a full set of evolveTrial simulations for a design specification — run_simulation_pure","text":"parallel_replicates = TRUE, results vary based num_workers due different random number stream partitioning. exact reproducibility across runs, use parallel_replicates = FALSE. package development devtools::load_all(), parallel workers load installed package version, development code. testing development changes, either use parallel_replicates = FALSE reinstall package devtools::install().","code":""},{"path":"/reference/sample_vs_ref_medians_independent.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample medians for vs-ref independent model (DISPATCHER) — sample_vs_ref_medians_independent","title":"Sample medians for vs-ref independent model (DISPATCHER) — sample_vs_ref_medians_independent","text":"Routes C++ R implementation based EVOLVETRIAL_USE_CPP. Samples hazards independently arm (borrowing).","code":""},{"path":"/reference/sample_vs_ref_medians_independent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample medians for vs-ref independent model (DISPATCHER) — sample_vs_ref_medians_independent","text":"","code":"sample_vs_ref_medians_independent(   slCtrl,   slTrt,   args,   num_samples,   ctrl_cache = NULL )"},{"path":"/reference/sample_vs_ref_medians_independent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample medians for vs-ref independent model (DISPATCHER) — sample_vs_ref_medians_independent","text":"slCtrl Control arm slice (list metrics$events_per_interval, metrics$person_time_per_interval) slTrt Treatment arm slice (list metrics$events_per_interval, metrics$person_time_per_interval) args List simulation args including prior_alpha_params_model, prior_beta_params_model, interval_cutpoints_sim num_samples Number posterior samples draw ctrl_cache Optional cached control arm posteriors multi-arm optimization (list lamC, medCtrl, interval_lengths)","code":""},{"path":"/reference/sample_vs_ref_medians_independent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample medians for vs-ref independent model (DISPATCHER) — sample_vs_ref_medians_independent","text":"List medCtrl, medTrt (posterior median samples), logHR (NULL independent model)","code":""},{"path":"/reference/sample_vs_ref_medians_independent_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample medians for vs-ref independent model (C++ implementation) — sample_vs_ref_medians_independent_cpp","title":"Sample medians for vs-ref independent model (C++ implementation) — sample_vs_ref_medians_independent_cpp","text":"End--end posterior sampler independent hazards model. Used single-arm trials multi-arm trials independent hazards.","code":""},{"path":"/reference/sample_vs_ref_medians_independent_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample medians for vs-ref independent model (C++ implementation) — sample_vs_ref_medians_independent_cpp","text":"","code":"sample_vs_ref_medians_independent_cpp(   E_C,   PT_C,   E_T,   PT_T,   alpha_prior,   beta_prior,   interval_lengths,   num_samples )"},{"path":"/reference/sample_vs_ref_medians_independent_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample medians for vs-ref independent model (C++ implementation) — sample_vs_ref_medians_independent_cpp","text":"E_C Integer vector control events per interval PT_C Numeric vector control person-time per interval E_T Integer vector treatment events per interval PT_T Numeric vector treatment person-time per interval alpha_prior Numeric vector Gamma prior shape parameters beta_prior Numeric vector Gamma prior rate parameters interval_lengths Numeric vector interval durations num_samples Number posterior samples","code":""},{"path":"/reference/sample_vs_ref_medians_independent_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample medians for vs-ref independent model (C++ implementation) — sample_vs_ref_medians_independent_cpp","text":"List \"medCtrl\" \"medTrt\" vectors (logHR independent model)","code":""},{"path":"/reference/sample_vs_ref_medians_independent_r.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample medians for vs-ref independent model (ORIGINAL R VERSION) — sample_vs_ref_medians_independent_r","title":"Sample medians for vs-ref independent model (ORIGINAL R VERSION) — sample_vs_ref_medians_independent_r","text":"Sample medians vs-ref independent model (ORIGINAL R VERSION)","code":""},{"path":"/reference/sample_vs_ref_medians_independent_r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample medians for vs-ref independent model (ORIGINAL R VERSION) — sample_vs_ref_medians_independent_r","text":"","code":"sample_vs_ref_medians_independent_r(slCtrl, slTrt, args, num_samples)"},{"path":"/reference/sample_vs_ref_medians_ph.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample medians for vs-ref PH model (DISPATCHER) — sample_vs_ref_medians_ph","title":"Sample medians for vs-ref PH model (DISPATCHER) — sample_vs_ref_medians_ph","text":"Routes C++ R implementation based EVOLVETRIAL_USE_CPP. Uses proportional hazards model borrowing strength across arms.","code":""},{"path":"/reference/sample_vs_ref_medians_ph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample medians for vs-ref PH model (DISPATCHER) — sample_vs_ref_medians_ph","text":"","code":"sample_vs_ref_medians_ph(slCtrl, slTrt, args, num_samples)"},{"path":"/reference/sample_vs_ref_medians_ph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample medians for vs-ref PH model (DISPATCHER) — sample_vs_ref_medians_ph","text":"slCtrl Control arm slice (list metrics$events_per_interval, metrics$person_time_per_interval) slTrt Treatment arm slice (list metrics$events_per_interval, metrics$person_time_per_interval) args List simulation args including prior_alpha_params_model, prior_beta_params_model, interval_cutpoints_sim, ph_loghr_prior_mean, ph_loghr_prior_sd, num_posterior_draws num_samples Number posterior samples draw","code":""},{"path":"/reference/sample_vs_ref_medians_ph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample medians for vs-ref PH model (DISPATCHER) — sample_vs_ref_medians_ph","text":"List medCtrl, medTrt (posterior median samples), logHR (log hazard ratio samples)","code":""},{"path":"/reference/sample_vs_ref_medians_ph_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample medians for vs-ref PH model (C++ implementation) — sample_vs_ref_medians_ph_cpp","title":"Sample medians for vs-ref PH model (C++ implementation) — sample_vs_ref_medians_ph_cpp","text":"End--end posterior sampler proportional hazards model. Samples log-HR posterior, baseline hazards, computes medians.","code":""},{"path":"/reference/sample_vs_ref_medians_ph_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample medians for vs-ref PH model (C++ implementation) — sample_vs_ref_medians_ph_cpp","text":"","code":"sample_vs_ref_medians_ph_cpp(   E_C,   PT_C,   E_T,   PT_T,   alpha_prior,   beta_prior,   interval_lengths,   mu,   sigma,   num_samples )"},{"path":"/reference/sample_vs_ref_medians_ph_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample medians for vs-ref PH model (C++ implementation) — sample_vs_ref_medians_ph_cpp","text":"E_C Integer vector control events per interval PT_C Numeric vector control person-time per interval E_T Integer vector treatment events per interval PT_T Numeric vector treatment person-time per interval alpha_prior Numeric vector Gamma prior shape parameters beta_prior Numeric vector Gamma prior rate parameters interval_lengths Numeric vector interval durations mu Log-HR prior mean sigma Log-HR prior SD num_samples Number posterior samples","code":""},{"path":"/reference/sample_vs_ref_medians_ph_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample medians for vs-ref PH model (C++ implementation) — sample_vs_ref_medians_ph_cpp","text":"List \"medCtrl\", \"medTrt\", \"logHR\" vectors","code":""},{"path":"/reference/sample_vs_ref_medians_ph_r.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample medians for vs-ref PH model (ORIGINAL R VERSION) — sample_vs_ref_medians_ph_r","title":"Sample medians for vs-ref PH model (ORIGINAL R VERSION) — sample_vs_ref_medians_ph_r","text":"Sample medians vs-ref PH model (ORIGINAL R VERSION)","code":""},{"path":"/reference/sample_vs_ref_medians_ph_r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample medians for vs-ref PH model (ORIGINAL R VERSION) — sample_vs_ref_medians_ph_r","text":"","code":"sample_vs_ref_medians_ph_r(slCtrl, slTrt, args, num_samples)"},{"path":"/reference/scenarios_from_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Build scenario overrides from a grid of design choices — scenarios_from_grid","title":"Build scenario overrides from a grid of design choices — scenarios_from_grid","text":"Expands named list options list scenario override lists can merged base_args prior simulation.","code":""},{"path":"/reference/scenarios_from_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build scenario overrides from a grid of design choices — scenarios_from_grid","text":"","code":"scenarios_from_grid(choices)"},{"path":"/reference/scenarios_from_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build scenario overrides from a grid of design choices — scenarios_from_grid","text":"choices Named list element either vector scalar values list whose elements per-arm vectors.","code":""},{"path":"/reference/scenarios_from_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build scenario overrides from a grid of design choices — scenarios_from_grid","text":"list scenario override lists.  underlying Cartesian grid attached attribute named \"grid\".","code":""},{"path":"/reference/scenarios_from_grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build scenario overrides from a grid of design choices — scenarios_from_grid","text":"","code":"scenarios_from_grid(list(   max_total_patients_per_arm = list(     c(Doublet = 60, Triplet = 60),     c(Doublet = 60, Triplet = 70)   ),   compare_arms_futility_margin = c(0.3, 0.4) )) #> [[1]] #> [[1]]$max_total_patients_per_arm #> Doublet Triplet  #>      60      60  #>  #> [[1]]$compare_arms_futility_margin #> [1] 0.3 #>  #>  #> [[2]] #> [[2]]$max_total_patients_per_arm #> Doublet Triplet  #>      60      70  #>  #> [[2]]$compare_arms_futility_margin #> [1] 0.3 #>  #>  #> [[3]] #> [[3]]$max_total_patients_per_arm #> Doublet Triplet  #>      60      60  #>  #> [[3]]$compare_arms_futility_margin #> [1] 0.4 #>  #>  #> [[4]] #> [[4]]$max_total_patients_per_arm #> Doublet Triplet  #>      60      70  #>  #> [[4]]$compare_arms_futility_margin #> [1] 0.4 #>  #>  #> attr(,\"grid\") #>   max_total_patients_per_arm compare_arms_futility_margin #> 1                          1                          0.3 #> 2                          2                          0.3 #> 3                          1                          0.4 #> 4                          2                          0.4"},{"path":"/reference/set_futility_medians.html","id":null,"dir":"Reference","previous_headings":"","what":"Adjust futility medians for experimental arms — set_futility_medians","title":"Adjust futility medians for experimental arms — set_futility_medians","text":"Adjust futility medians experimental arms","code":""},{"path":"/reference/set_futility_medians.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adjust futility medians for experimental arms — set_futility_medians","text":"","code":"set_futility_medians(   args,   null_med,   alt_med,   base = c(\"null+delta\", \"alt\"),   delta = 0 )"},{"path":"/reference/set_futility_medians.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adjust futility medians for experimental arms — set_futility_medians","text":"args Argument list whose futility_median_arms entry updated. null_med Numeric scalar representing null median. alt_med Numeric scalar representing alternative median. base Character scalar selecting \"null+delta\" \"alt\". delta Numeric offset added base = \"null+delta\".","code":""},{"path":"/reference/set_futility_medians.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adjust futility medians for experimental arms — set_futility_medians","text":"Modified argument list updated futility_median_arms.","code":""},{"path":"/reference/simon_final_efficacy.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Simon-style final efficacy rule — simon_final_efficacy","title":"Check Simon-style final efficacy rule — simon_final_efficacy","text":"classical Simon design, declare efficacy total responses > r","code":""},{"path":"/reference/simon_final_efficacy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Simon-style final efficacy rule — simon_final_efficacy","text":"","code":"simon_final_efficacy(n_responses, r)"},{"path":"/reference/simon_final_efficacy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check Simon-style final efficacy rule — simon_final_efficacy","text":"n_responses Total number responders r Total response threshold (success responses > r)","code":""},{"path":"/reference/simon_final_efficacy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Simon-style final efficacy rule — simon_final_efficacy","text":"TRUE efficacious","code":""},{"path":"/reference/simon_oc_exact.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Simon design operating characteristics analytically — simon_oc_exact","title":"Calculate Simon design operating characteristics analytically — simon_oc_exact","text":"Computes exact operating characteristics Simon two-stage design.","code":""},{"path":"/reference/simon_oc_exact.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Simon design operating characteristics analytically — simon_oc_exact","text":"","code":"simon_oc_exact(n1, r1, n, r, p)"},{"path":"/reference/simon_oc_exact.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Simon design operating characteristics analytically — simon_oc_exact","text":"n1 Stage 1 sample size r1 Stage 1 futility boundary (stop X1 <= r1) n Total sample size (n1 + n2) r Total response threshold efficacy (success X > r) p True response probability","code":""},{"path":"/reference/simon_oc_exact.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Simon design operating characteristics analytically — simon_oc_exact","text":"List : reject_prob: Probability rejecting null (power type error) pet: Probability early termination stage 1 en: Expected sample size","code":""},{"path":"/reference/simon_stage1_futility.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Simon-style stage 1 futility rule — simon_stage1_futility","title":"Check Simon-style stage 1 futility rule — simon_stage1_futility","text":"classical Simon design, stop stage 1 responses <= r1","code":""},{"path":"/reference/simon_stage1_futility.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Simon-style stage 1 futility rule — simon_stage1_futility","text":"","code":"simon_stage1_futility(n_responses, r1)"},{"path":"/reference/simon_stage1_futility.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check Simon-style stage 1 futility rule — simon_stage1_futility","text":"n_responses Number responders stage 1 r1 Stage 1 futility boundary (stop responses <= r1)","code":""},{"path":"/reference/simon_stage1_futility.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Simon-style stage 1 futility rule — simon_stage1_futility","text":"TRUE stop futility","code":""},{"path":"/reference/simulate_binary_response_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate binary response data for a cohort — simulate_binary_response_data","title":"Simulate binary response data for a cohort — simulate_binary_response_data","text":"Generates binary response outcomes n patients true response probability p.","code":""},{"path":"/reference/simulate_binary_response_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate binary response data for a cohort — simulate_binary_response_data","text":"","code":"simulate_binary_response_data(n, p, start_id = 1L)"},{"path":"/reference/simulate_binary_response_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate binary response data for a cohort — simulate_binary_response_data","text":"n Number patients p True response probability (0 1) start_id Starting patient ID (default 1)","code":""},{"path":"/reference/simulate_binary_response_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate binary response data for a cohort — simulate_binary_response_data","text":"Data frame columns: id, response (0/1)","code":""},{"path":"/reference/test_armadillo_random.html","id":null,"dir":"Reference","previous_headings":"","what":"Test Armadillo matrix operations — test_armadillo_random","title":"Test Armadillo matrix operations — test_armadillo_random","text":"Test Armadillo matrix operations","code":""},{"path":"/reference/test_armadillo_random.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test Armadillo matrix operations — test_armadillo_random","text":"","code":"test_armadillo_random(n)"},{"path":"/reference/test_armadillo_random.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test Armadillo matrix operations — test_armadillo_random","text":"n Matrix dimension","code":""},{"path":"/reference/test_armadillo_random.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test Armadillo matrix operations — test_armadillo_random","text":"Mean random normal matrix","code":""},{"path":"/reference/test_rcpp_sum.html","id":null,"dir":"Reference","previous_headings":"","what":"Test Rcpp setup — test_rcpp_sum","title":"Test Rcpp setup — test_rcpp_sum","text":"Simple test function verify Rcpp RcppArmadillo working.","code":""},{"path":"/reference/test_rcpp_sum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test Rcpp setup — test_rcpp_sum","text":"","code":"test_rcpp_sum(x)"},{"path":"/reference/test_rcpp_sum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test Rcpp setup — test_rcpp_sum","text":"x numeric vector","code":""},{"path":"/reference/test_rcpp_sum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test Rcpp setup — test_rcpp_sum","text":"Sum vector","code":""},{"path":[]},{"path":"/news/index.html","id":"breaking-changes-0-0-0-9000","dir":"Changelog","previous_headings":"","what":"Breaking Changes","title":"evolveTrial 0.0.0.9000","text":"Single-arm gate scaling: Single-arm (compare_arms_option = FALSE) now applies proportional scaling min_events_per_arm min_person_time_frac_per_arm based randomization_probs, matching vs-reference behavior. Arms lower randomization probabilities automatically get proportionally lower gates scalar gate values provided. Parameter naming harmonization: Updated parameter names consistency across comparison paths: efficacy_threshold_current_prob_hc → efficacy_threshold_hc_prob posterior_futility_threshold_hc → futility_threshold_hc_prob min_events_for_analysis → min_events_hc min_median_followup → min_median_followup_hc","code":""},{"path":"/news/index.html","id":"deprecated-parameters-0-0-0-9000","dir":"Changelog","previous_headings":"","what":"Deprecated Parameters","title":"evolveTrial 0.0.0.9000","text":"Old parameter names still supported deprecation warnings. Users migrate new names:","code":""},{"path":"/news/index.html","id":"new-features-0-0-0-9000","dir":"Changelog","previous_headings":"","what":"New Features","title":"evolveTrial 0.0.0.9000","text":"Added resolve_gate_vec() internal helper (R/gate_diagnostics.R) unified gate parameter resolution optional proportional scaling across comparison paths. Added comprehensive test suites single-arm scenarios: test-single-arm-gates.R: Basic edge cases proportional scaling, rebalancing, multiple gates test-single-arm-regression.R: Null/alternative scenarios, early stopping, final analysis validation test-path-parity.R: Parity tests ensuring single-arm vs-reference paths maintain consistent behavior","code":""},{"path":"/news/index.html","id":"code-quality-0-0-0-9000","dir":"Changelog","previous_headings":"","what":"Code Quality","title":"evolveTrial 0.0.0.9000","text":"Removed unused functions: run_single_arm_interim(), slice_arm_at_time(), posterior_scalar_draws() R/state_management.R (longer needed refactoring). Consolidated gate resolution logic: vs-reference single-arm paths now use resolve_gate_vec() helper, eliminating code duplication.","code":""},{"path":"/news/index.html","id":"package-maintenance-0-0-0-9000","dir":"Changelog","previous_headings":"","what":"Package Maintenance","title":"evolveTrial 0.0.0.9000","text":"Removed non-ASCII characters (emojis, Greek letters, smart quotes) source code Replaced library() calls requireNamespace() + :: proper package dependencies Reorganized DESCRIPTION: moved optional packages (gt, dplyr, openxlsx, etc.) Suggests Removed unused imports (ggpubr, survival, survminer) Added VignetteBuilder field proper vignette support Added complete @param documentation internal helper functions Fixed documentation mismatches explore_early_stopping_from_cal() Added @keywords internal tags non-exported functions Added stats::rnorm namespace imports Added missing global variable declarations Updated .Rbuildignore exclude development files Improved test coverage actual utility function tests","code":""},{"path":"/news/index.html","id":"bug-fixes-0-0-0-9000","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"evolveTrial 0.0.0.9000","text":"None development version","code":""},{"path":"/news/index.html","id":"new-features-0-0-0-9000-1","dir":"Changelog","previous_headings":"","what":"New Features","title":"evolveTrial 0.0.0.9000","text":"None development version (package active development)","code":""}]
