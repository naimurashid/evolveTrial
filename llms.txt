# evolveTrial

**evolveTrial** is an R package for designing and simulating Bayesian
adaptive clinical trials with time-to-event or binary endpoints. It
supports single-arm, multi-arm, and hybrid seamless
(single-arm-to-between-arm) trial designs with interim stopping rules
based on posterior probabilities.

The package was developed for the ARPA-H ADAPT breast cancer platform
trial and accompanies the JASA paper:

> Rashid, N. (2026). “Constrained Bayesian Optimization for Calibration
> of Bayesian Adaptive Clinical Trials.” *Journal of the American
> Statistical Association*.

## Features

- **Single-arm vs historical control**: evaluate efficacy against a
  historical benchmark with Bayesian posterior probability decision
  rules
- **Multi-arm adaptive trials**: compare experimental arms to a
  reference arm under proportional hazards
- **Hybrid seamless designs**: 4-state machine transitioning from
  single-arm monitoring to between-arm comparison with
  predictive-probability-based conversion decisions
- **Binary endpoints**: Simon two-stage designs with exact operating
  characteristics
- **Piecewise exponential hazards**: flexible time-to-event modeling
  with interval-specific rates
- **C++ acceleration**: posterior sampling, hazard computations, and
  hybrid trial simulation via Rcpp and RcppArmadillo
- **Design calibration**: grid search over decision thresholds with
  Pareto-optimal filtering
- **Operating characteristics**: type I error, power, expected sample
  size, probability of early termination, and conversion rates

## Installation

### C++ Compiler Prerequisites

evolveTrial contains compiled C++ code (via Rcpp/RcppArmadillo) that
must be built during installation. You need a working C++ toolchain.

#### Windows

Install **Rtools** before installing evolveTrial:

1.  Download from <https://cran.r-project.org/bin/windows/Rtools/>
2.  Choose the version matching your R version (e.g., Rtools44 for R
    4.4.x)
3.  Run the installer with default settings
4.  Restart R/RStudio

Verify:

``` r
Sys.which("make")
#> Should return a path like "C:/rtools44/usr/bin/make.exe"
```

#### macOS

Install **Xcode Command Line Tools**:

``` bash
xcode-select --install
```

On Apple Silicon (M1/M2/M3/M4), you may also need gfortran for
RcppArmadillo:

``` bash
brew install gcc
```

Verify:

``` r
system("clang++ --version")
```

#### Linux (Ubuntu/Debian)

``` bash
sudo apt-get install r-base-dev build-essential liblapack-dev libblas-dev
```

#### Linux (Fedora/RHEL)

``` bash
sudo dnf install R-devel gcc-c++ lapack-devel blas-devel
```

### Install from GitHub

R \>= 4.1 is recommended due to Rcpp/RcppArmadillo usage.

``` r
# Using pak (recommended)
install.packages("pak")
pak::pak("naimurashid/evolveTrial")

# Or using remotes
install.packages("remotes")
remotes::install_github("naimurashid/evolveTrial")

# Or using devtools
install.packages("devtools")
devtools::install_github("naimurashid/evolveTrial")
```

### Install from Local Source

``` bash
git clone https://github.com/naimurashid/evolveTrial.git
```

``` r
devtools::install("path/to/evolveTrial")
# Or for development:
devtools::load_all("path/to/evolveTrial")
```

### Troubleshooting

| Error                                      | Fix                                                                           |
|--------------------------------------------|-------------------------------------------------------------------------------|
| `compilation failed` or `make: not found`  | Install Rtools (Windows) or Xcode CLI tools (macOS)                           |
| `'RcppArmadillo.h' file not found`         | `install.packages("RcppArmadillo")` then retry                                |
| `library not found for -lgfortran` (macOS) | `brew install gcc`                                                            |
| Installation times out                     | `remotes::install_github("naimurashid/evolveTrial", build_vignettes = FALSE)` |

## Quick Start Examples

### Example 1: Single-Arm Survival Trial

Simulate a single-arm trial evaluating an experimental therapy against a
historical control median of 6 months, with an expected treatment median
of 9 months.

``` r
library(evolveTrial)

result <- run_simulation_pure(
  num_simulations           = 500,
  arm_names                 = "Experimental",
  reference_arm_name        = "Experimental",
  compare_arms_option       = "none",
  weibull_shape_true_arms   = c(Experimental = 1),
  weibull_median_true_arms  = c(Experimental = 9),
  interval_cutpoints_sim    = c(0, 3, 6, 9, 12, 15, 18, 21, 24),
  max_follow_up_sim         = 24,
  censor_max_time_sim       = 24,
  prior_alpha_params_model  = rep(0.01, 8),
  prior_beta_params_model   = rep(0.01, 8),
  num_posterior_draws       = 5000,
  cohort_size_per_arm       = c(Experimental = 1),
  max_total_patients_per_arm = c(Experimental = 60),
  efficacy_stopping_rule_hc = TRUE,
  efficacy_threshold_hc_prob = 0.95,
  futility_stopping_rule_hc  = TRUE,
  futility_threshold_hc_prob = 0.05,
  median_pfs_success_threshold_arms = c(Experimental = 6),
  overall_accrual_rate      = 2,
  randomization_probs       = c(Experimental = 1),
  min_events_hc             = 15,
  interim_calendar_beat     = 3
)

# Result is a data.frame -- inspect directly
print(result)
#>      Arm_Name True_Median Type_I_Error_or_Power PET_Efficacy PET_Futility ...
#> 1 Experimental           9                  0.82         0.45         0.02 ...
```

### Example 2: Binary Simon Two-Stage Design

Find an optimal Simon design and verify its operating characteristics
via simulation.

``` r
library(evolveTrial)

# Find optimal Simon design: H0: p=0.20, H1: p=0.40
design <- find_simon_design(p0 = 0.20, p1 = 0.40, alpha = 0.05, beta = 0.20)
print(design)
#>   n1 r1  n  r n2 EN_null EN_alt PET_null PET_alt type1_error power criterion
#> 1 13  2 43 11 30    21.8   34.2     0.60    0.26       0.048  0.81   optimal

# Confirm via simulation using the Simon design parameters
result <- run_simulation_binary(
  num_simulations              = 2000,
  arm_names                    = "Arm_A",
  true_response_prob           = c(Arm_A = 0.40),
  n1_per_arm                   = c(Arm_A = design$n1),
  n_total_per_arm              = c(Arm_A = design$n),
  p0                           = 0.20,
  r1_per_arm                   = c(Arm_A = design$r1),
  r_per_arm                    = c(Arm_A = design$r),
  use_simon_rules              = TRUE
)

print(result)
#>   Arm_Name True_Response_Prob Type_I_Error_or_Power PET_Efficacy PET_Futility ...
```

### Example 3: Hybrid Seamless SA-to-BA Trial

Simulate a hybrid trial that begins with single-arm monitoring and can
convert to a between-arm comparison if sufficient evidence accumulates.

``` r
library(evolveTrial)

# Define the hybrid design parameter vector
theta <- create_hybrid_theta(
  eff_sa            = 0.90,
  fut_sa            = 0.10,
  hr_threshold_sa   = 0.80,
  ev_sa             = 15,
  nmax_sa           = 40,
  conversion_trigger = "any_single_success",
  pp_go             = 0.70,
  pp_nogo           = 0.20,
  ss_method         = "predictive",
  max_additional_n  = 60,
  eff_ba            = 0.975,
  fut_ba            = 0.05,
  ev_ba             = 15,
  nmax_ba           = 80
)

# Base trial configuration
base_args <- list(
  interval_cutpoints_sim   = c(0, 3, 6, 9, 12, 15, 18, 21, 24),
  prior_alpha_params_model = rep(0.01, 8),
  prior_beta_params_model  = rep(0.01, 8),
  overall_accrual_rate     = 3,
  interim_calendar_beat    = 3,
  num_posterior_draws      = 5000
)

# Scenario: historical median 6 mo, reference 6 mo, experimental 9 mo
scenario <- list(historical_median = 6, ref_median = 6, exp_median = 9)

oc <- compute_hybrid_oc_rcpp(
  hybrid_theta    = theta,
  base_args       = base_args,
  scenario_params = scenario,
  num_simulations = 1000,
  seed            = 42,
  trial_mode      = "hybrid"
)

cat("Power:", round(oc$power, 3), "\n")
cat("Type I:", round(oc$type1, 3), "\n")
cat("E[N] under null:", round(oc$EN_null, 1), "\n")
cat("P(conversion):", round(oc$P_conversion, 3), "\n")
```

## Core API Reference

### Simulation Functions

| Function                                                          | Purpose                                                               |
|-------------------------------------------------------------------|-----------------------------------------------------------------------|
| [`run_simulation_pure()`](reference/run_simulation_pure.md)       | Simulate a single-arm or multi-arm trial with time-to-event endpoints |
| [`run_scenarios()`](reference/run_scenarios.md)                   | Run multiple scenario configurations over a shared baseline           |
| [`scenarios_from_grid()`](reference/scenarios_from_grid.md)       | Generate factorial scenario grid from parameter choices               |
| [`run_simulation_binary()`](reference/run_simulation_binary.md)   | Simulate a binary-endpoint trial (one- or two-stage)                  |
| [`compute_hybrid_oc_rcpp()`](reference/compute_hybrid_oc_rcpp.md) | Simulate hybrid seamless SA-to-BA trial via C++ engine                |
| [`create_hybrid_theta()`](reference/create_hybrid_theta.md)       | Construct the hybrid design parameter vector                          |

### Design Calibration

| Function                                                                            | Purpose                                                    |
|-------------------------------------------------------------------------------------|------------------------------------------------------------|
| [`grid_calibrate()`](reference/grid_calibrate.md)                                   | Grid search over thresholds for optimal design calibration |
| [`calibrate_alpha()`](reference/calibrate_alpha.md)                                 | Calibrate type I error across null scenarios               |
| [`explore_early_stopping_from_cal()`](reference/explore_early_stopping_from_cal.md) | Explore early stopping configurations from a calibration   |
| [`filter_early_grid()`](reference/filter_early_grid.md)                             | Filter designs meeting alpha/power constraints             |
| [`recommend_design_from_early()`](reference/recommend_design_from_early.md)         | Select best design from feasible set                       |
| [`adopt_calibration()`](reference/adopt_calibration.md)                             | Adopt a calibrated design into trial arguments             |

### Binary Endpoint Helpers

| Function                                                | Purpose                                            |
|---------------------------------------------------------|----------------------------------------------------|
| [`find_simon_design()`](reference/find_simon_design.md) | Find optimal or minimax Simon two-stage design     |
| [`simon_oc_exact()`](reference/simon_oc_exact.md)       | Exact operating characteristics for a Simon design |

### Visualization and Reporting

| Function                                                                          | Purpose                                         |
|-----------------------------------------------------------------------------------|-------------------------------------------------|
| [`pretty_scenario_matrix()`](reference/pretty_scenario_matrix.md)                 | Pivot simulation results to wide-format summary |
| [`plot_calibration()`](reference/plot_calibration.md)                             | Power vs type I error with Pareto frontier      |
| [`plot_early_tradeoff()`](reference/plot_early_tradeoff.md)                       | Early stopping trade-off visualization          |
| [`export_scenario_table_to_excel()`](reference/export_scenario_table_to_excel.md) | Export results to formatted Excel workbook      |
| [`export_scenario_table_to_png()`](reference/export_scenario_table_to_png.md)     | Export results to PNG via gt                    |

### Diagnostics

| Function                                                                  | Purpose                                                |
|---------------------------------------------------------------------------|--------------------------------------------------------|
| [`estimate_vsref_gate_timing()`](reference/estimate_vsref_gate_timing.md) | Estimate when information gates can first be satisfied |

### Decision Rule Functions

| Function                                                                    | Purpose                                         |
|-----------------------------------------------------------------------------|-------------------------------------------------|
| [`evaluate_sa_efficacy()`](reference/evaluate_sa_efficacy.md)               | Evaluate single-arm efficacy decision           |
| [`evaluate_sa_futility()`](reference/evaluate_sa_futility.md)               | Evaluate single-arm futility decision           |
| [`evaluate_ba_efficacy()`](reference/evaluate_ba_efficacy.md)               | Evaluate between-arm efficacy decision          |
| [`evaluate_ba_futility()`](reference/evaluate_ba_futility.md)               | Evaluate between-arm futility decision          |
| [`evaluate_conversion_trigger()`](reference/evaluate_conversion_trigger.md) | Evaluate SA-to-BA conversion readiness          |
| [`make_conversion_decision()`](reference/make_conversion_decision.md)       | Execute conversion decision with SSR            |
| [`perform_ssr()`](reference/perform_ssr.md)                                 | Sample size re-estimation for between-arm phase |

## Package Structure

    evolveTrial/
    ├── R/
    │   ├── simulation_driver.R          # run_simulation_pure(), run_scenarios(), scenarios_from_grid()
    │   ├── binary_endpoint.R            # run_simulation_binary(), find_simon_design(), simon_oc_exact()
    │   ├── hybrid_trial.R               # create_hybrid_theta(), hybrid trial orchestration
    │   ├── hybrid_sim_rcpp.R            # compute_hybrid_oc_rcpp()
    │   ├── hybrid_decisions.R           # SA/BA efficacy/futility evaluators, conversion logic
    │   ├── hybrid_ssr.R                 # perform_ssr()
    │   ├── state_management.R           # Trial state containers
    │   ├── design_analysis.R            # grid_calibrate(), plot_calibration(), pretty_scenario_matrix()
    │   ├── gate_diagnostics.R           # estimate_vsref_gate_timing()
    │   ├── interim_logic.R              # Stopping rule implementation
    │   ├── posterior_helpers.R           # Bayesian posterior computation (R)
    │   ├── posterior_cpp_dispatchers.R   # R-to-C++ dispatch for posterior draws
    │   ├── predictive_probabilities.R   # Predictive probability computation
    │   ├── data_generation.R            # Time-to-event data generation
    │   ├── globals.R                    # Package-wide constants
    │   ├── evolveTrial-package.R        # Package documentation
    │   ├── zzz_imports.R                # Import declarations
    │   └── RcppExports.R                # Auto-generated Rcpp bindings
    ├── src/
    │   ├── hybrid_trial_sim.cpp         # C++ hybrid trial simulation engine
    │   ├── posterior_sampling.cpp        # C++ posterior sampling with RcppArmadillo
    │   └── predictive_probability.cpp   # C++ predictive probability calculations
    ├── tests/testthat/                  # 16 test files
    ├── vignettes/
    │   └── design-overview.Rmd          # Methodology vignette
    ├── DESCRIPTION
    ├── NAMESPACE
    └── LICENSE                          # MIT

## Companion Package: BATON

[**BATON**](https://github.com/naimurashid/BATON) (Bayesian Adaptive
Trial Optimization) provides constrained Bayesian optimization for
calibrating evolveTrial designs. While evolveTrial evaluates operating
characteristics for a given design configuration, BATON searches over
the design space to find configurations that satisfy frequentist
constraints (e.g., type I error control) while optimizing an objective
(e.g., minimizing expected sample size or maximizing power). Together,
they form a complete pipeline for adaptive trial design calibration.

``` r
# Typical workflow:
# 1. Define trial structure in evolveTrial
# 2. Use BATON::bo_calibrate() to search over evolveTrial's parameter space
# 3. Extract optimal design with BATON::summarise_case_study()
```

## Running Tests

``` r
devtools::test()
```

## Citation

If you use evolveTrial in your work, please cite:

``` bibtex
@article{rashid2026constrained,
  title   = {Constrained {Bayesian} Optimization for Calibration of
             {Bayesian} Adaptive Clinical Trials},
  author  = {Rashid, Naim U.},
  journal = {Journal of the American Statistical Association},
  year    = {2026}
}
```

## License

MIT. See [LICENSE](LICENSE) for details.

# Package index

## All functions

- [`CONVERSION_TRIGGERS`](CONVERSION_TRIGGERS.md) : Conversion triggers
- [`FUTILITY_ACTIONS`](FUTILITY_ACTIONS.md) : Futility actions
- [`HYBRID_STATES`](HYBRID_STATES.md) : hybrid_trial.R Core hybrid
  single-arm to between-arm Bayesian adaptive trial simulator
- [`adopt_calibration()`](adopt_calibration.md) : Adopt a calibrated
  design configuration
- [`apply_futility_action()`](apply_futility_action.md) : Apply futility
  action to trial state
- [`apply_recommended_to_args()`](apply_recommended_to_args.md) : Apply
  a recommended early-stopping configuration to the argument list
- [`calculate_median_survival_matrix_cpp()`](calculate_median_survival_matrix_cpp.md)
  : Calculate median survival for multiple hazard samples (C++
  implementation)
- [`calculate_median_survival_piecewise_cpp()`](calculate_median_survival_piecewise_cpp.md)
  : Calculate median survival for piecewise exponential model (C++
  implementation)
- [`calculate_weibull_scale()`](calculate_weibull_scale.md) : Calculate
  Weibull scale from median survival time
- [`calibrate_alpha()`](calibrate_alpha.md) : Calibrate interim and
  final thresholds for single-arm designs
- [`check_conversion_trigger()`](check_conversion_trigger.md) : Check if
  conversion trigger is met
- [`classify_trial_outcome()`](classify_trial_outcome.md) : Classify
  final trial outcome
- [`compare_sa_vs_hybrid()`](compare_sa_vs_hybrid.md) : Compare SA-only
  vs Hybrid decision
- [`compare_simon_to_bo()`](compare_simon_to_bo.md) : Validate BO
  calibration against Simon enumeration
- [`compile_hybrid_results()`](compile_hybrid_results.md) : Compile
  hybrid trial results
- [`compute_ba_posterior()`](compute_ba_posterior.md) : Compute
  between-arm posterior probability
- [`compute_ba_posterior_cpp()`](compute_ba_posterior_cpp.md) : Compute
  between-arm posterior probability (C++)
- [`compute_ba_posterior_exponential()`](compute_ba_posterior_exponential.md)
  : Compute exact PP for exponential model (for validation)
- [`compute_ba_posterior_pwe_mc()`](compute_ba_posterior_pwe_mc.md) :
  Monte Carlo comparison for PWE posteriors
- [`compute_hybrid_oc_cpp()`](compute_hybrid_oc_cpp.md) : Compute hybrid
  trial operating characteristics (C++ implementation)
- [`compute_hybrid_oc_rcpp()`](compute_hybrid_oc_rcpp.md) : Compute
  operating characteristics using Rcpp
- [`compute_interval_metrics()`](compute_interval_metrics.md) : Compute
  interval-specific metrics from registry
- [`compute_interval_metrics_vectorized()`](compute_interval_metrics_vectorized.md)
  : Compute interval metrics (VECTORIZED)
- [`compute_oc_lambda()`](compute_oc_lambda.md) : Compute OC with direct
  lambda (hazard rate) input
- [`compute_p_between_arm()`](compute_p_between_arm.md) : Compute
  between-arm posterior probability
- [`compute_p_single_arm()`](compute_p_single_arm.md) : Compute
  single-arm posterior probability
- [`compute_pp_curve()`](compute_pp_curve.md) : Compute predictive
  probability curve
- [`compute_pp_curve_posterior()`](compute_pp_curve_posterior.md) :
  Compute PP curve using posterior method
- [`compute_pp_curve_predictive()`](compute_pp_curve_predictive.md) :
  Compute PP curve using predictive probability method
- [`compute_pp_efficacy_sa_cpp()`](compute_pp_efficacy_sa_cpp.md) :
  Compute predictive probability for single-arm efficacy (C++)
- [`compute_pp_futility_sa_cpp()`](compute_pp_futility_sa_cpp.md) :
  Compute predictive probability for single-arm futility (C++)
- [`compute_pp_posterior()`](compute_pp_posterior.md) : Compute PP using
  posterior method (fast approximation)
- [`compute_pp_posterior_single()`](compute_pp_posterior_single.md) :
  Compute posterior-based PP for single N_add
- [`compute_pp_predictive()`](compute_pp_predictive.md) : Compute PP
  using predictive method (Monte Carlo)
- [`compute_pp_predictive_cpp()`](compute_pp_predictive_cpp.md) :
  Compute predictive probability for hybrid trial conversion (C++)
- [`compute_pp_predictive_full()`](compute_pp_predictive_full.md) :
  Compute predictive probability for a single N_add value
- [`compute_pp_predictive_pwe()`](compute_pp_predictive_pwe.md) :
  Compute predictive probability with full PWE model
- [`compute_pwe_median()`](compute_pwe_median.md) : Compute median
  survival from PWE hazards
- [`compute_pwe_median_survival()`](compute_pwe_median_survival.md) :
  Compute median survival from PWE hazards
- [`compute_trial_oc()`](compute_trial_oc.md) : Compute operating
  characteristics for a single trial
- [`count_arm_events()`](count_arm_events.md) : Count events for an arm
  up to analysis time
- [`create_decision_report()`](create_decision_report.md) : Create
  structured decision report
- [`create_hybrid_state()`](create_hybrid_state.md) : Create initial
  hybrid trial state
- [`create_hybrid_theta()`](create_hybrid_theta.md) : Create hybrid
  design parameter structure
- [`create_simulation_cluster()`](create_simulation_cluster.md) : Create
  a reusable evolveTrial simulation cluster
- [`draw_posterior_hazard_samples()`](draw_posterior_hazard_samples.md)
  : Draw posterior hazard samples (DISPATCHER)
- [`draw_posterior_hazard_samples_cpp()`](draw_posterior_hazard_samples_cpp.md)
  : Draw posterior hazard samples (C++ implementation)
- [`draw_posterior_response_rate()`](draw_posterior_response_rate.md) :
  Draw posterior samples for binary response rate
- [`estimate_vsref_gate_timing()`](estimate_vsref_gate_timing.md) :
  Estimate when the vs-reference interim gates can be satisfied
- [`evaluate_ba_efficacy()`](evaluate_ba_efficacy.md) : Evaluate
  between-arm efficacy
- [`evaluate_ba_futility()`](evaluate_ba_futility.md) : Evaluate
  between-arm futility
- [`evaluate_conversion_trigger()`](evaluate_conversion_trigger.md) :
  Evaluate conversion trigger
- [`evaluate_ph_grid()`](evaluate_ph_grid.md) : Evaluate PH-based grid
  of designs
- [`evaluate_sa_efficacy()`](evaluate_sa_efficacy.md) :
  hybrid_decisions.R Decision rules for hybrid single-arm to between-arm
  trials
- [`evaluate_sa_futility()`](evaluate_sa_futility.md) : Evaluate
  single-arm futility for an arm
- [`exp_arms_from_args()`](exp_arms_from_args.md) : Extract experimental
  arm names from an argument list
- [`expected_information_gain()`](expected_information_gain.md) :
  Expected information gain from additional patients
- [`explore_early_stopping_from_cal()`](explore_early_stopping_from_cal.md)
  : Explore early stopping knobs around a calibrated design
- [`export_scenario_table_to_excel()`](export_scenario_table_to_excel.md)
  : Export a scenario summary table to Excel
- [`export_scenario_table_to_png()`](export_scenario_table_to_png.md) :
  Render the scenario summary table to a PNG image
- [`filter_early_grid()`](filter_early_grid.md) : Filter early-stopping
  designs by operating targets
- [`find_optimal_n_add()`](find_optimal_n_add.md) : Optimal N_add finder
- [`find_simon_design()`](find_simon_design.md) : Find optimal Simon
  design
- [`generate_decision_summary()`](generate_decision_summary.md) :
  Generate human-readable decision summary
- [`get_historical_hazard()`](get_historical_hazard.md) : Get historical
  hazard for an arm
- [`grid_calibrate()`](grid_calibrate.md) : Calibrate historical-control
  thresholds over a grid
- [`handle_sa_futility()`](handle_sa_futility.md) : Handle single-arm
  futility for an arm
- [`handle_state_between()`](handle_state_between.md) : Handle
  STATE_BETWEEN phase
- [`handle_state_consider_conversion()`](handle_state_consider_conversion.md)
  : Handle STATE_CONSIDER_CONVERSION phase
- [`handle_state_single()`](handle_state_single.md) : Handle
  STATE_SINGLE phase
- [`hybrid_sim_rcpp`](hybrid_sim_rcpp.md) : Rcpp-powered hybrid trial
  simulation wrapper
- [`is_trial_success()`](is_trial_success.md) : Determine if trial
  concluded with overall success
- [`make_conversion_decision()`](make_conversion_decision.md) : Make
  conversion decision based on PP curve
- [`perform_ssr()`](perform_ssr.md) : hybrid_ssr.R Sample Size
  Re-Estimation methods for hybrid trials
- [`ph_beta_mode_var()`](ph_beta_mode_var.md) : Compute mode and
  variance of log-HR posterior for PH model (DISPATCHER)
- [`ph_beta_mode_var_cpp()`](ph_beta_mode_var_cpp.md) : Compute mode and
  variance of log-HR posterior for PH model (C++ implementation)
- [`plot_calibration()`](plot_calibration.md) : Plot power versus type I
  error for calibration grids
- [`plot_early_tradeoff()`](plot_early_tradeoff.md) : Plot
  early-stopping trade-offs
- [`pretty_scenario_matrix()`](pretty_scenario_matrix.md) : Summarise
  simulation output by scenario and arm
- [`prob_response_below()`](prob_response_below.md) : Calculate
  posterior probability that response rate is below threshold
- [`prob_response_exceeds()`](prob_response_exceeds.md) : Calculate
  posterior probability that response rate exceeds threshold
- [`recommend_design_from_early()`](recommend_design_from_early.md) :
  Recommend a single early-stopping design
- [`release_cluster()`](release_cluster.md) : Release an evolveTrial
  simulation cluster
- [`run_hybrid_simulations_cpp()`](run_hybrid_simulations_cpp.md) : Run
  multiple hybrid trial simulations (C++ implementation)
- [`run_hybrid_simulations_rcpp()`](run_hybrid_simulations_rcpp.md) :
  Run hybrid simulations with Rcpp
- [`run_scenarios()`](run_scenarios.md) : Evaluate a design across
  multiple scenarios
- [`run_simulation_binary()`](run_simulation_binary.md) : Run binary
  endpoint trial simulation
- [`run_simulation_pure()`](run_simulation_pure.md) : Run a full set of
  evolveTrial simulations for a design specification
- [`sample_vs_ref_medians_independent()`](sample_vs_ref_medians_independent.md)
  : Sample medians for vs-ref independent model (DISPATCHER)
- [`sample_vs_ref_medians_independent_cpp()`](sample_vs_ref_medians_independent_cpp.md)
  : Sample medians for vs-ref independent model (C++ implementation)
- [`sample_vs_ref_medians_ph()`](sample_vs_ref_medians_ph.md) : Sample
  medians for vs-ref PH model (DISPATCHER)
- [`sample_vs_ref_medians_ph_cpp()`](sample_vs_ref_medians_ph_cpp.md) :
  Sample medians for vs-ref PH model (C++ implementation)
- [`scenarios_from_grid()`](scenarios_from_grid.md) : Build scenario
  overrides from a grid of design choices
- [`select_arms_for_ba()`](select_arms_for_ba.md) : Select arms for
  between-arm comparison
- [`set_futility_medians()`](set_futility_medians.md) : Adjust futility
  medians for experimental arms
- [`simon_oc_exact()`](simon_oc_exact.md) : Calculate Simon design
  operating characteristics analytically
- [`simulate_future_arm_data()`](simulate_future_arm_data.md) : Simulate
  future arm data under PWE model
- [`simulate_future_arm_pwe()`](simulate_future_arm_pwe.md) : Simulate
  future arm data under PWE model
- [`simulate_future_arm_pwe_cpp()`](simulate_future_arm_pwe_cpp.md) :
  Simulate future arm data under PWE model (C++)
- [`simulate_future_arm_pwe_vectorized()`](simulate_future_arm_pwe_vectorized.md)
  : Simulate future arm data under PWE model (VECTORIZED)
- [`simulate_hybrid_trial_cpp()`](simulate_hybrid_trial_cpp.md) :
  Simulate a single hybrid trial (C++ implementation)
- [`simulate_pwe_survival()`](simulate_pwe_survival.md) : Simulate
  survival time from PWE model
- [`simulate_pwe_survival_batch()`](simulate_pwe_survival_batch.md) :
  Simulate multiple survival times from PWE model (VECTORIZED)
- [`simulate_pwe_survival_batch_cpp()`](simulate_pwe_survival_batch_cpp.md)
  : Simulate PWE survival times (C++ vectorized)
- [`simulate_pwe_time()`](simulate_pwe_time.md) : Simulate survival time
  from PWE model
- [`test_armadillo_random()`](test_armadillo_random.md) : Test Armadillo
  matrix operations
- [`test_rcpp_sum()`](test_rcpp_sum.md) : Test Rcpp setup
- [`update_hybrid_state()`](update_hybrid_state.md) : Update hybrid
  trial state based on current conditions
- [`update_posteriors()`](update_posteriors.md) : Update posterior
  parameters from trial data
- [`validate_exponential_ba()`](validate_exponential_ba.md) : Validate
  MC against closed-form for exponential

# Articles

### All vignettes

- [design-overview](design-overview.md):
